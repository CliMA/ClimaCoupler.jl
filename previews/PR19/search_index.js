var documenterSearchIndex = {"docs":
[{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"EditURL = \"https://github.com/CliMA/CouplerMachine/blob/master/experiments/ClimateMachine/DesignTests/simple_2testcomp.jl\"","category":"page"},{"location":"generated/simple_2testcomp/#Diffusion-Equation-in-a-Vertical-Column","page":"Vertical Column Heat Diffusion","title":"Diffusion Equation in a Vertical Column","text":"","category":"section"},{"location":"generated/simple_2testcomp/#Setup","page":"Vertical Column Heat Diffusion","title":"Setup","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"A vertical diffusive column split over two Cartesian components (atmos & ocean columns)\nBoundary conditions used to set diffusive flux in other components have different vertical discretizations and timesteps\nThe coupler maps fields between the two components","category":"page"},{"location":"generated/simple_2testcomp/#Equations","page":"Vertical Column Heat Diffusion","title":"Equations","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"The RHS evaluation follows:","category":"page"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"fracpartial thetapartial t = - nabla cdot kappa(phi_init) nabla phi","category":"page"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"where","category":"page"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"theta is the tracer (e.g. potential temperature)\nkappa is the diffusivity tensor","category":"page"},{"location":"generated/simple_2testcomp/#Import-packages","page":"Vertical Column Heat Diffusion","title":"Import packages","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"using ClimateMachine\nusing MPI\nusing Statistics\n\n# To couple\nusing CouplerMachine\nusing Unitful, Dates\n\n# To create meshes & grids\nusing ClimateMachine.Ocean.Domains\nusing ClimateMachine.Grids\nimport ClimateMachine.DGMethods.NumericalFluxes: NumericalFluxSecondOrder\n\n# To setup some callbacks\nusing ClimateMachine.GenericCallbacks\n\n# To invoke timestepper\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.ODESolvers: solve!\nusing ClimateMachine.MPIStateArrays: weightedsum\n\nClimateMachine.init()\nconst FT = Float64;\n\nif !(:CplTestingBL in names(Main))\n    include(\"CplTestingBL.jl\") # allows re-run of script without restarting julia\nend\nusing .CplTestingBL","category":"page"},{"location":"generated/simple_2testcomp/#Set-simulation-parameters","page":"Vertical Column Heat Diffusion","title":"Set simulation parameters","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"couple_dt = 3600.0 # timestep at which coupled components sync\nnstepsA = 10 # atmos steps per coupled timestep\nnstepsO = 5 # ocean steps per coupled timestep\n\n#  Haney like relaxation time scale and a length scale (Haney, 1971).\n#  Air-sea exchange vigor is governed by length/time-scale.\nconst τ_airsea = FT(60 * 86400)\nconst L_airsea = FT(500)\nconst λ_airsea = FT(L_airsea / τ_airsea)\nfunction coupling_lambda()\n    return (λ_airsea)\nend;\n\n#  Background atmos and ocean diffusivities\nconst κᵃʰ = FT(1e4) * 0.0\nconst κᵃᶻ = FT(1e-1)\nconst κᵒʰ = FT(1e3) * 0.0\nconst κᵒᶻ = FT(1e-4)","category":"page"},{"location":"generated/simple_2testcomp/#Set-up-coupled-model","page":"Vertical Column Heat Diffusion","title":"Set up coupled model","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"Define component models and initialize the coupler","category":"page"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"function main(::Type{FT}) where {FT}\n    # Domain\n    Np = 4\n    ΩA = RectangularDomain(\n        Ne = (10, 10, 5),\n        Np = Np,\n        x = (0, 1e6),\n        y = (0, 1e6),\n        z = (0, 1e5),\n        periodicity = (true, true, false),\n    )\n    ΩO = RectangularDomain(\n        Ne = (10, 10, 4),\n        Np = Np,\n        x = (0, 1e6),\n        y = (0, 1e6),\n        z = (-4e3, 0),\n        periodicity = (true, true, false),\n    )\n\n    # Grid\n    btags = ((0,0),(0,0),(1,2))\n    gridA = DiscontinuousSpectralElementGrid(ΩA; boundary_tags = btags)\n    gridO = DiscontinuousSpectralElementGrid(ΩO; boundary_tags = btags)\n\n    # Numerics-specific options\n    numerics = (NFsecondorder = CplTestingBL.PenaltyNumFluxDiffusive(),)\n\n    # Callbacks (TODO)\n    callbacks = ()\n\n    # Collect spatial info, timestepping, balance law and DGmodel for the two components\n\n    # 1. Atmos component\n    mA = CplModel(;\n        grid = gridA,\n        equations = CplTestBL(\n            bl_propA,\n            (CoupledPrimaryBoundary(), ExteriorBoundary()),\n        ),\n        nsteps = nstepsA,\n        dt = couple_dt / nstepsA,\n        numerics...,\n    )\n\n    # 2. Ocean component\n    mO = CplModel(;\n        grid = gridO,\n        equations = CplTestBL(\n            bl_propO,\n            (ExteriorBoundary(), CoupledSecondaryBoundary()),\n        ),\n        nsteps = nstepsO,\n        dt = couple_dt / nstepsO,\n        numerics...,\n    )","category":"page"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"Create the coupler object for holding import/export fields and performs mappings and instantiate the coupled timestepper:","category":"page"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"    coupler = CplState()\n    coupler_register!(coupler, :Ocean_SST, deepcopy(mO.state.θ[mO.boundary]), mO.grid, DateTime(0), u\"°C\")\n    coupler_register!(coupler, :Atmos_MeanAirSeaθFlux, deepcopy(mA.state.F_accum[mA.boundary]), mA.grid, DateTime(0), u\"°C\")\n\n    compA = (pre_step = preatmos, component_model = mA, post_step = postatmos)\n    compO = (pre_step = preocean, component_model = mO, post_step = postocean)\n    component_list = (atmosphere = compA, ocean = compO)\n    cpl_solver = CplSolver(\n        component_list = component_list,\n        coupler = coupler,\n        coupling_dt = couple_dt,\n        t0 = 0.0,\n    )\n\n    return cpl_solver, callbacks\nend\n\nfunction run(cpl_solver, numberofsteps, cbvector)\n    solve!(\n        nothing,\n        cpl_solver;\n        numberofsteps = numberofsteps,\n        callbacks = cbvector,\n    )\nend","category":"page"},{"location":"generated/simple_2testcomp/#Define-pre_step-and-post_step-functions","page":"Vertical Column Heat Diffusion","title":"Define pre_step and post_step functions","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"Each component model must define pre_step and post_step functions. In the pre_step, a component imports necessary boundary state and flux data from the coupler. In the post_step, a component exports boundary data to the coupler to be later received by other components.","category":"page"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"function get_components(csolver)\n    mA = csolver.component_list.atmosphere.component_model\n    mO = csolver.component_list.ocean.component_model\n    return mA, mO\nend\n\nfunction preatmos(csolver)\n    mA, mO = get_components(csolver)\n\n    # Set boundary SST used in atmos to SST of ocean surface at start of coupling cycle.\n    mA.discretization.state_auxiliary.θ_secondary[mA.boundary] .=\n        coupler_get(csolver.coupler, :Ocean_SST, mA.grid, DateTime(0), u\"°C\")\n    # Set atmos boundary flux accumulator to 0.\n    mA.state.F_accum .= 0\n\n    @info(\n        \"preatmos\",\n        time = csolver.t,\n        total_θ_atmos = weightedsum(mA.state, 1),\n        total_θ_ocean = weightedsum(mO.state, 1),\n        total_θ = weightedsum(mA.state, 1) + weightedsum(mO.state, 1),\n        atmos_θ_surface_max = maximum(mA.state.θ[mA.boundary]),\n        ocean_θ_surface_max = maximum(mO.state.θ[mO.boundary]),\n    )\nend\n\nfunction postatmos(csolver)\n    mA, mO = get_components(csolver)\n\n    # Pass atmos exports to \"coupler\" namespace\n    # 1. Save mean θ flux at the Atmos boundary during the coupling period\n    coupler_put!(csolver.coupler, :Atmos_MeanAirSeaθFlux, mA.state.F_accum[mA.boundary] ./ csolver.dt,\n        mA.grid, DateTime(0), u\"°C\")\n\n    @info(\n        \"postatmos\",\n        time = time = csolver.t + csolver.dt,\n        total_θ_atmos = weightedsum(mA.state, 1),\n        total_θ_ocean = weightedsum(mO.state, 1),\n        total_F_accum = mean(mA.state.F_accum[mA.boundary]) * 1e6 * 1e6,\n        total_θ =\n            weightedsum(mA.state, 1) +\n            weightedsum(mO.state, 1) +\n            mean(mA.state.F_accum[mA.boundary]) * 1e6 * 1e6,\n        F_accum_max = maximum(mA.state.F_accum[mA.boundary]),\n        F_avg_max = maximum(mA.state.F_accum[mA.boundary] ./ csolver.dt),\n        atmos_θ_surface_max = maximum(mA.state.θ[mA.boundary]),\n        ocean_θ_surface_max = maximum(mO.state.θ[mO.boundary]),\n    )\nend\n\nfunction preocean(csolver)\n    mA, mO = get_components(csolver)\n\n    # Set mean air-sea theta flux\n    mO.discretization.state_auxiliary.F_prescribed[mO.boundary] .=\n        coupler_get(csolver.coupler, :Atmos_MeanAirSeaθFlux, mO.grid, DateTime(0), u\"°C\")\n    # Set ocean boundary flux accumulator to 0. (this isn't used)\n    mO.state.F_accum .= 0\n\n    @info(\n        \"preocean\",\n        time = csolver.t,\n        F_prescribed_max =\n            maximum(mO.discretization.state_auxiliary.F_prescribed[mO.boundary]),\n        F_prescribed_min =\n            maximum(mO.discretization.state_auxiliary.F_prescribed[mO.boundary]),\n        ocean_θ_surface_max = maximum(mO.state.θ[mO.boundary]),\n        ocean_θ_surface_min = maximum(mO.state.θ[mO.boundary]),\n    )\nend\n\nfunction postocean(csolver)\n    mA, mO = get_components(csolver)\n    @info(\n        \"postocean\",\n        time = csolver.t + csolver.dt,\n        ocean_θ_surface_max = maximum(mO.state.θ[mO.boundary]),\n        ocean_θ_surface_min = maximum(mO.state.θ[mO.boundary]),\n    )\n\n    # Pass ocean exports to \"coupler\" namespace\n    #  1. Ocean SST (value of θ at z=0)\n    coupler_put!(csolver.coupler, :Ocean_SST, mO.state.θ[mO.boundary], mO.grid, DateTime(0), u\"°C\")\nend","category":"page"},{"location":"generated/simple_2testcomp/#Specify-balance-law","page":"Vertical Column Heat Diffusion","title":"Specify balance law","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"# Set atmosphere initial state function\nfunction atmos_init_theta(xc, yc, zc, npt, el)\n    return 30.0\nend\n# Set atmosphere shadow boundary flux function\nfunction atmos_theta_shadow_boundary_flux(θᵃ, θᵒ, npt, el, xc, yc, zc)\n    if zc == 0.0\n        tflux = (1.0 / τ_airsea) * (θᵃ - θᵒ)\n    else\n        tflux = 0.0\n    end\n    return tflux\nend\n# Set atmsophere diffusion coeffs\nfunction atmos_calc_kappa_diff(_...)\n    return κᵃʰ, κᵃʰ, κᵃᶻ\nend\n# Set atmos source!\nfunction atmos_source_theta(θᵃ, npt, el, xc, yc, zc, θᵒ)\n    tsource = 0.0\n    if zc == 0.0\n        # tsource = -(1. / τ_airsea)*( θᵃ-θᵒ )\n    end\n    return tsource\nend\n# Set penalty term tau (for debugging)\nfunction atmos_get_penalty_tau(_...)\n    return FT(3.0 * 0.0)\nend\n# Create atmos component\nbl_propA = CplTestingBL.prop_defaults()\n\nbl_propA = (;bl_propA..., init_theta = atmos_init_theta,\n            theta_shadow_boundary_flux = atmos_theta_shadow_boundary_flux)\nbl_propA = (bl_propA..., init_theta = atmos_init_theta)\nbl_propA =\n    (bl_propA..., theta_shadow_boundary_flux = atmos_theta_shadow_boundary_flux)\nbl_propA = (bl_propA..., calc_kappa_diff = atmos_calc_kappa_diff)\nbl_propA = (bl_propA..., source_theta = atmos_source_theta)\nbl_propA = (bl_propA..., get_penalty_tau = atmos_get_penalty_tau)\nbl_propA = (bl_propA..., coupling_lambda = coupling_lambda)\n\n# Set initial temperature profile\nfunction ocean_init_theta(xc, yc, zc, npt, el)\n    return 20.0\nend\n# Set boundary source imported from atmos\nfunction ocean_source_theta(θ, npt, el, xc, yc, zc, air_sea_flux_import)\n    sval = 0.0\n    if zc == 0.0\n        # sval=air_sea_flux_import\n    end\n    return sval\nend\n# Set ocean diffusion coeffs\nfunction ocean_calc_kappa_diff(_...)\n    # return κᵒʰ,κᵒʰ,κᵒᶻ*FT(100.)\n    return κᵒʰ, κᵒʰ, κᵒᶻ # m^2 s^-1\nend\n# Set penalty term tau (for debugging)\nfunction ocean_get_penalty_tau(_...)\n    return FT(0.15 * 0.0)\nend\n# Create ocean component\nbl_propO = CplTestingBL.prop_defaults()\nbl_propO = (bl_propO..., init_theta = ocean_init_theta)\nbl_propO = (bl_propO..., source_theta = ocean_source_theta)\nbl_propO = (bl_propO..., calc_kappa_diff = ocean_calc_kappa_diff)\nbl_propO = (bl_propO..., get_penalty_tau = ocean_get_penalty_tau)\nbl_propO = (bl_propO..., coupling_lambda = coupling_lambda)","category":"page"},{"location":"generated/simple_2testcomp/#Run-simulation","page":"Vertical Column Heat Diffusion","title":"Run simulation","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"simulation, cbvector = main(Float64);\nnsteps = 10\nprintln(\"Initialized. Running...\")\nrun(simulation, nsteps, cbvector)","category":"page"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"","category":"page"},{"location":"generated/simple_2testcomp/","page":"Vertical Column Heat Diffusion","title":"Vertical Column Heat Diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"boundary_conditions_doc/#Boundary-Conditions-(BCs)","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"","category":"section"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"This section attempts to bridge mathematical considerations of BCs and their implementations in climate models.","category":"page"},{"location":"boundary_conditions_doc/#Types-of-boundary-conditions","page":"Boundary Conditions (BCs)","title":"Types of boundary conditions","text":"","category":"section"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"Dirichlet  θ = f\nNeumann  partial θ  partial n = f\nRobin  c_1θ +  c_2partial θ  partial n = f\nCauchy  θ = f_1  partial θ  partial n = f_2\nMixed\na mix of the above, each applied at a different section of the boundary","category":"page"},{"location":"boundary_conditions_doc/#Well-posedness-and-general-context","page":"Boundary Conditions (BCs)","title":"Well-posedness and general context","text":"","category":"section"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"Well-posedness, or the availability of a unique robust solution, is easier to prove in some problems than others. For example, using the heat-diffusion equation this section demonstrates that some combinations of the above boundary conditions do not produce a unique solution. The problem of imposing boundary conditions in climate models is more complex, so well-posedness is more difficult to prove analytically, as discussed below. \nExamples of imposing BCs:  \nDiffusion equation in steady state\nThe prognostic heat equation rewritten in terms of potential temperature, θ, is:\nfracpartial θpartial t = -  cdot (κ  θ)\nfor simplicity, we assume a steady state (partial  partial t = 0), a diffusivity of kappa = 1 m^2 s^-1 and that we're only in 1D (i.e.  = partial  partial x). Solving this requires two BCs in space (assuming we have no constraints in time), so we have: \nfracpartial^2 θpartial x^2 = 0\nupon integration in x we expect \nfracpartial θpartial x = c_1 and x = c_1x + c_2, where c_1 and c_2 are set by the boundary conditions. \nIf we have two Neumann boundary conditions (e.g. dTdx = 1 at both x_0 = 1 and x_N ), we can only obtain c_1 and the solution is not unique. We therefore need one of the boundaries to be constrained using a Dirichlet BC. \nAdvection-diffusion equation with a linear flux\nstepping up the ladder of complexity is the advection diffusion problem:   fracpartial θpartial t = -  cdot (vecu theta + κ  θ) = -  cdot (F_non-diffusive + F_diffusive)\nMiyaoka et al 17 have shown that by taking advantage of mass conservation, it is possible to derive a general BC for the advection-diffusion problem, as long as the flux is linear in theta (e.g. vecu(xyz)). Evidently, this is still insufficient for climate modelling purposes.\nNavier Stokes and climate models\nwell-posedness of the NS equations is still unknown (after all it is one of the Clay Mathematics Institute's Millennium Problems)\nin climate modelling it is often considered sufficient to use the general rule of thumb and use as many BCs as we have derivatives, without explicitly proving that the problem is analytically well posed. \nwe implicitly assume mass conservation and the divergence theorem like in the Miyaoka et al 17 study above\nin practice, for global atmospheric models there are different constraints on each of the two boundaries:\nlower boundary of the atmosphere\nImpenetrable: reflective BCs are imposed by setting w=0 and the tangential wind remains unchanged. This is the FreeSlip() BC for momentum, Impenetrable() for mass and Insulating() for energy/moisture/tracers which may be used for atmosphere-only idealized studies.  \nPrescribed: it is common to prescribe a constant (or variable if coupled to another model) surface temperature. This allows calculation of a surface sensible and latent heat fluxes, which are then added to any other sources of heat at the surface (e.g. radiation fluxes, etc). Once all surface fluxes are summed up, they are then passed to the atmospheric model as fluxes that enter the prognostic equations at the boundaries. E.g. see the Prescribed() BC, and CoupledPrimary(), CoupledSecondary() BCs for more complex setups.\nupper boundary of the atmosphere\nImpenetrable: reflective BCs are imposed by setting w=0 and the tangential wind remains unchanged. This is the FreeSlip() BC for momentum, Impenetrable() for mass and Insulating() for energy/moisture/tracers which may be used for atmosphere-only idealized studies.  \nOpen: it is undesirable to produce reflection in the upper levels, but open BCs are more difficult to implement\nSponge layer: an alternative to the above can be obtained by artificial (often linear or 2nd order) damping in the upper levels. The down side is that this sponge layer ofen takes up a substantial part of the model's depth.  ","category":"page"},{"location":"boundary_conditions_doc/#Implementation-in-the-ClimateMachine.jl","page":"Boundary Conditions (BCs)","title":"Implementation in the ClimateMachine.jl","text":"","category":"section"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"Boundaries in DG:\n    __________-  bc +\n   | element  |  |  |            - = internal state\n   | in       |  |  |           bc = boundary state \n   | question |  |  |            + = ghost state\n   |__________|  |  |\n              \\__ __/\n                 V\n    same location in space","category":"page"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"BCs in ClimateMachine.jl are imposed separately for the different compute kernels as illustrated by the CMFlowChart.\nFor the AtmosModel, the BCs that need to be considered are:","category":"page"},{"location":"boundary_conditions_doc/#Mass","page":"Boundary Conditions (BCs)","title":"Mass","text":"","category":"section"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"Impenetrable(): \nno normal component of mass flux, which means u at bc:   u_bc = vecu^- - (hatn cdot u^-) hatn\nIn conjunction with the CentralNumericalFlux at the boundary, this can be imposed via the ghost state as:\n  # use CentralNumericalFlux with this reflective ghost state  ​\n  function atmos_momentum_boundary_state!(_...)\n          ​state⁺.ρu = state⁻.ρu - 2 * dot(state⁻.ρu, n) .* SVector(n) \n  ​end\nPenetrable(): \nthis means no boundary condition (free surface)\n  # use the transmissive boundary flux: \n  function atmos_momentum_boundary_state!(_...)\n          ​state⁺.ρu = state⁻.ρu\n  ​end","category":"page"},{"location":"boundary_conditions_doc/#Momentum","page":"Boundary Conditions (BCs)","title":"Momentum","text":"","category":"section"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"NoSlip(): \nthis means u vanishes are the boundary (i.e. Dirichlet BC), so that u_bc = 0\nIn conjunction with the CentralNumericalFlux at the boundary, this can be imposed via the ghost state as:\n  function atmos_momentum_boundary_state!(nf::Union{NumericalFluxFirstOrder, NumericalFluxGradient}, _...)\n      state⁺.ρu = -state⁻.ρu\n  end\n  \n  # a stabilising penalty term can be used here:\n  numerical_boundary_flux_first_order!(_...) = ... end\n\n  atmos_momentum_normal_boundary_flux_second_order!(_...) = nothing # no contribution from nF_diffusive\nFreeSlip(): nabla_h cdotvecu = 0, hatn cdot u = 0\nno diffusive normal flux at the boundary and no drag on the tangential components\nu_bc\nis determined by the mass flux BC above","category":"page"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"        function atmos_momentum_boundary_state!(nf::NumericalFluxFirstOrder, _...)\n                state⁺.ρu -= 2 * dot(state⁻.ρu, n) .* SVector(n) # reflective to impose no normal flux\n        end\n        function atmos_momentum_boundary_state!(nf::NumericalFluxGradient, _...)\n                state⁺.ρu -= dot(state⁻.ρu, n) .* SVector(n) # non-reflective to capture the sign of the gradient\n        end\n        atmos_momentum_normal_boundary_flux_second_order!(_...) = nothing  # no contribution from nF_diffusive","category":"page"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"DragLaw():\nuse momentum constraints on u_bc, just like FreeSlip(), but with a non-zero second-order normal flux (nF_diffusive) \n  function atmos_momentum_boundary_state!(nf::Union{NumericalFluxFirstOrder, NumericalFluxGradient}, _...)\n      atmos_momentum_boundary_state!(nf, Impenetrable(FreeSlip()), _...)\n  end\n  function atmos_momentum_normal_boundary_flux_second_order!(_...)\n      fluxᵀn.ρu += C * state⁻.ρ * |u_h| * u_h # contribution from nF_diffusive\n  end","category":"page"},{"location":"boundary_conditions_doc/#Energy-/-Moisture-/-Tracers","page":"Boundary Conditions (BCs)","title":"Energy / Moisture / Tracers","text":"","category":"section"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"Insulating():\nno normal diffusive flux (nFdiffusive) across the boundary (homogeneous Neumann BC) imposed via the second order flux, with the first-order and gradient fluxes assuming u{bc}$ from the mass and momentum BCs for consistency\n  atmos_energy_boundary_state!(_...) \n      state⁺.ρe = state⁻.ρe\n  end\n  atmos_energy_normal_boundary_flux_second_order!( _...,) = nothing\nPrescribed(), CoupledPrimary(), CoupledSecondary()\nsame as Insulating(), but with a non-zero second-order normal flux (nF_diffusive)\n  atmos_energy_boundary_state!(_...) \n      state⁺.ρe = state⁻.ρe\n  end\n  function atmos_energy_normal_boundary_flux_second_order!(_...)\n      fluxᵀn.energy.ρe -= bc_energy.fn(state⁻, aux⁻, t)\n  end\nwhere bc_energy.fn can be a flux value or a relaxation function to a surface temperature (e.g. see the slab land/ocean, bulk formulation, or the M-O flux-based NishizawaEnergyFlux function). NB: Dirichlet BC is not normally applied in this context.","category":"page"},{"location":"boundary_conditions_doc/#BC-stability-in-DG-for-idealized-problems-(probably-delete-or-expand?)","page":"Boundary Conditions (BCs)","title":"BC stability in DG for idealized problems (probably delete or expand?)","text":"","category":"section"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"boundary fluxes (numerical + physical) are implementable in DG via boundary numerical fluxes, between the interior point (x^-) and its exterior ghost equivalent (x^+). These need to be applied depending on the problem at hand. For example in the advective problem, the BCs will need to consider the flow direction, so that information is carried in the correct direction (i.e. downstream). \nAdvection problem\nImposed BCs\nA) Impose BCs via numerical fluxes\ne.g. central boundary flux (or another numerical flux, e.g. Rusanov):\nutheta_bc = fracutheta^- + utheta^+2 = fracutheta^- + f_02\nB) Impose the flux directly at the boundary:   utheta_bc = f_0    which is implemented via the ghost point as theta^+ = theta^- + 2theta_0 rightarrow  reflection principle\nFor an advective problem Lyapunov function analysis shows that A) is more dissipative (and stable) but B) is closer to the analytical conservation solution \nFree endpoints / open boundaries   utheta_bc = utheta^-   which is implemented as theta^+ = theta^-  rightarrow transmissive / free boundary (endpoint is just what it is)\nDiffusion problem\ncall the diffusive flux sigma = kappapartial_x theta\nA) Neumann on theta\nis basically Dirichlet on sigma, so that the boundary is transmissive theta\nsigma_bc = fracsigma^- + sigma^+2   and sigma^+ = sigma^- + 2f_0\ntheta_bc = theta_0\nor sigma_bc = 0 are stable and conservative\nB) Dirichlet\ntransmissive on sigma_bc and explicit BCs on theta_bc are stable and conservative\nAdvection-diffusion problem\nbest choice for the numerical solution to mimic the analytical solution is  utheta_bc = 0 and sigma_bc=sigma^-\nbest choice for sufficient dissipation (and thus a more stable solution) is  utheta_bc = utheta^-  2 and theta_bc=0 and sigma_bc=sigma^-","category":"page"},{"location":"boundary_conditions_doc/#References:","page":"Boundary Conditions (BCs)","title":"References:","text":"","category":"section"},{"location":"boundary_conditions_doc/","page":"Boundary Conditions (BCs)","title":"Boundary Conditions (BCs)","text":"CliMA's numerics_old DesignDoc\nuseful Q&As \nTodd Lane's talk for climate modelling context","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"EditURL = \"https://github.com/CliMA/CouplerMachine/blob/master/experiments/ClimateMachine/AdvectionDiffusion/run_script_v2.jl\"","category":"page"},{"location":"generated/run_script_v2/#Advection-diffusion-on-a-Sphere","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"","category":"section"},{"location":"generated/run_script_v2/#Setup","page":"Advection-diffusion on a Sphere","title":"Setup","text":"","category":"section"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"Passive advection of an anomaly using non-divergent horizontal flow on the sphere (currently 300km/s but switching to Williamson stream function)\nHomogeneous tracer concentration of the outer shell couples to an inhomogeneous concentration of the inner shell","category":"page"},{"location":"generated/run_script_v2/#Equations","page":"Advection-diffusion on a Sphere","title":"Equations","text":"","category":"section"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"The RHS evaluation follows:","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"fracpartial thetapartial t = - nabla cdot (vecu theta + kappa nabla theta) qquad","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"where","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"theta is the tracer (e.g. potential temperature)\nvecu(u00) is a constant zonal velocity\nkappa is the diffusivity tensor.","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"Boundary Conditions","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"External boundary conditions (Neumann):","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"vecn cdot kappa nabla theta = 0 qquad textat  z = 4textkm -4textkm","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"where vecn is the upward pointing unit normal vector at the boundary.","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"Primary coupled boundary condition (forced by secondary domain):","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"vecn cdot kappa_a nabla theta =f_a= lambda (theta - theta_secondary) qquad textat atmos  z = 0","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"where lambda is a constant but will be replaced by a roughness coefficient factor in more complex test cases. f_a and kappa_a are, respectively, the flux and diffusivity of the atmosphere component.","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"Secondary coupled boundary condition (accumulated flux by primary domain or prescribed flux):","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"If accumulated,","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"vecn cdot kappa_onabla theta = f_o qquad textat ocean  z = 0 text (or pseudo subsurface)\nand","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"f_o = f_accum = int_tau_0^tau f_a dt","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"where τ-τ_0 gives the coupling cycle length. f_o and kappa_o are, respectively, the flux and diffusivity of the atmosphere component, with f_accum being the accumulated flux.","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"ATMOS\n------------- θ @z=0 [lowest atmos level]\n  A\n / \\          f = n⋅κ_a ∇θ = λ(θ−θ_secondary​)\n  |\n------------- θ_secondary​ @z=0 [highest ocean level]\nOCEAN","category":"page"},{"location":"generated/run_script_v2/#Import-packages","page":"Advection-diffusion on a Sphere","title":"Import packages","text":"","category":"section"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"using ClimateMachine, MPI\nusing ClimateMachine.DGMethods.NumericalFluxes\nusing ClimateMachine.DGMethods\n\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.ODESolvers: solve!\n\nusing ClimateMachine.Atmos: SphericalOrientation, latitude, longitude, AtmosFilterPerturbations\n\nusing CLIMAParameters\nusing CLIMAParameters.Planet: MSLP, R_d, day, grav, Omega, planet_radius\n\nusing ClimateMachine.Mesh.Filters\n\nusing ClimateMachine.BalanceLaws:\n    BalanceLaw,\n    AbstractStateType,\n    Prognostic,\n    Auxiliary,\n    Gradient,\n    GradientFlux,\n    GradientLaplacian,\n    Hyperdiffusive,\n    UpwardIntegrals,\n    DownwardIntegrals,\n    vars_state,\n    number_states\n\nusing CouplerMachine\n\nusing Unitful\nusing Dates: DateTime\nusing Statistics\nusing StaticArrays\n\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()\n\nClimateMachine.init()\nFT = Float64\n\n## Shared functions\ninclude(\"domains.jl\")\ninclude(\"abstractions.jl\")\ninclude(\"callbacks.jl\")\n\n# Main balance law and its components\ninclude(\"CplMainBL.jl\")","category":"page"},{"location":"generated/run_script_v2/#Set-simulation-parameters","page":"Advection-diffusion on a Sphere","title":"Set simulation parameters","text":"","category":"section"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"nstepsA = 10\nnstepsO = 5\n\n#  Background atmos and ocean diffusivities\nconst κᵃʰ = FT(1e4) * 0.0\nconst κᵃᶻ = FT(1e-1)\nconst κᵒʰ = FT(1e3) * 0.0\nconst κᵒᶻ = FT(1e-4)\nconst τ_airsea = FT(60 * 86400)\nconst L_airsea = FT(500)\nconst λ_airsea = FT(L_airsea / τ_airsea)\ncoupling_lambda() = (λ_airsea)\nconst u_max = FT(1e-5) # max. advective velocity in radians","category":"page"},{"location":"generated/run_script_v2/#Set-up-coupled-model","page":"Advection-diffusion on a Sphere","title":"Set up coupled model","text":"","category":"section"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"Define component models and initialize the coupler","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"function main(::Type{FT}) where {FT}\n\n    # Domain - Spherical Shells\n    # confusing name - better might be to use something like DeepSphericalShellDomain directly?\n    ΩO = DeepSphericalShellDomain(radius = FT(planet_radius(param_set)) - FT(4e3), height = FT(4e3))\n    ΩA = DeepSphericalShellDomain(radius = FT(planet_radius(param_set)) , height = FT(4e3))\n\n    # Grid\n    nelem = (;horizontal = 8, vertical = 4)\n    polynomialorder = (;horizontal = 5, vertical = 5)\n    overintegrationorder = (;horizontal = 1, vertical = 1)\n\n    gridA = DiscontinuousSpectralElementGrid(ΩA, nelem, polynomialorder)\n    gridO = DiscontinuousSpectralElementGrid(ΩO, nelem, polynomialorder)\n\n    # Numerics-specific options\n    numerics = (NFfirstorder = CentralNumericalFluxFirstOrder(), NFsecondorder = PenaltyNumFluxDiffusive(),\n                overint_params = (overintegrationorder, polynomialorder))\n\n    # Timestepping\n    Δt_ = calculate_dt(gridA, wavespeed = u_max*(ΩA.radius), diffusivity = maximum([κᵃʰ, κᵃᶻ]) )\n\n    t_time, end_time = ( 0  , 20Δt_ )\n\n    # Collect spatial info, timestepping, balance law and DGmodel for the two components\n    boundary_mask( xc, yc, zc ) = @. ( xc^2 + yc^2 + zc^2 )^0.5 ≈ planet_radius(param_set)","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"1. Atmos component","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"    # Prop atmos functions to override defaults\n    atmos_structure(λ, ϕ, r) = FT(30)#30.0 + 10.0 * cos(ϕ) * sin(5λ)\n    atmos_θⁱⁿⁱᵗ(npt, el, x, y, z) = atmos_structure( lon(x,y,z), lat(x,y,z), rad(x,y,z) )                # Set atmosphere initial state function\n    ##atmos_θ_shadowflux(θᵃ, θᵒ, npt, el, xc, yc, zc) = FT(0.0)\n    atmos_θ_shadowflux(θᵃ, θᵒ, npt, el, xc, yc, zc) = is_surface(xc,yc,zc) ? (1.0 / τ_airsea) * (θᵃ - θᵒ) : 0.0 # Set atmosphere shadow boundary flux function\n    atmos_calc_kappa_diff(_...) = κᵃʰ, κᵃʰ, κᵃᶻ               # Set atmos diffusion coeffs\n    atmos_source_θ(θᵃ, npt, el, xc, yc, zc, θᵒ) = FT(0.0)     # Set atmos source!\n    atmos_get_penalty_tau(_...) = FT(3.0 * 0.0)               # Set penalty term tau (for debugging)\n\n    ## Set atmos advective velocity (constant in time) and convert to Cartesian\n    uˡᵒⁿ(λ, ϕ, r) = u_max * r * cos(ϕ)\n    atmos_uⁱⁿⁱᵗ(npt, el, x, y, z) = (     0 * r̂(x,y,z)\n                                        + 0 * ϕ̂(x,y,z)\n                                        + uˡᵒⁿ(lon(x,y,z), lat(x,y,z), rad(x,y,z)) * λ̂(x,y,z) )\n\n    # Collect atmos props\n    bl_propA = prop_defaults()\n    bl_propA = (;bl_propA...,\n                init_theta = atmos_θⁱⁿⁱᵗ,\n                theta_shadow_boundary_flux = atmos_θ_shadowflux,\n                calc_kappa_diff = atmos_calc_kappa_diff,\n                source_theta = atmos_source_θ,\n                get_penalty_tau = atmos_get_penalty_tau,\n                coupling_lambda = coupling_lambda,\n                init_u = atmos_uⁱⁿⁱᵗ\n                )\n    # Setup atmos component model\n    mA = CplModel(;\n        grid = gridA,\n        equations = CplMainBL(\n            bl_propA,\n            (CoupledPrimaryBoundary(), ExteriorBoundary()),\n            param_set,\n        ),\n        boundary_z = boundary_mask,\n        nsteps = nstepsA,\n        dt = Δt_/ nstepsA,\n        timestepper = LSRK54CarpenterKennedy,\n        numerics...,\n    )","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"2. Ocean component","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"    # Prop ocean functions to override defaults\n    tropical_heating_1(λ, ϕ, r) = 30.0 + 10.0 * cos(ϕ) * sin(5λ)\n    tropical_heating_2(λ, ϕ, r) = 30.0 + 10.0 * cos(ϕ) + 1 * sin(5λ) * cos(ϕ)\n    tropical_heating(λ, ϕ, r) = tropical_heating_1(λ, ϕ, r)\n    ocean_θⁱⁿⁱᵗ(npt, el, x, y, z) = tropical_heating( lon(x,y,z), lat(x,y,z), rad(x,y,z) )                    # Set ocean initial state function\n    ocean_calc_kappa_diff(_...) = κᵒʰ, κᵒʰ, κᵒᶻ               # Set ocean diffusion coeffs\n    ocean_source_θ(θᵃ, npt, el, xc, yc, zc, θᵒ) = FT(0.0)     # Set ocean source!\n    ocean_get_penalty_tau(_...) = FT(0.15 * 0.0)               # Set penalty term tau (for debugging)\n    ocean_uⁱⁿⁱᵗ(xc, yc, zc, npt, el) = SVector(FT(0.0), FT(0.0), FT(0.0)) # Set ocean advective velocity\n\n    # Collect ocean props\n    bl_propO = prop_defaults()\n    bl_propO = (;bl_propO...,\n                init_theta = ocean_θⁱⁿⁱᵗ,\n                calc_kappa_diff = ocean_calc_kappa_diff,\n                source_theta = ocean_source_θ,\n                get_penalty_tau = ocean_get_penalty_tau,\n                coupling_lambda = coupling_lambda,\n                init_u = ocean_uⁱⁿⁱᵗ,\n                )\n    # Setup ocean component model\n    mO = CplModel(;\n        grid = gridO,\n        equations = CplMainBL(\n            bl_propO,\n            (ExteriorBoundary(), CoupledSecondaryBoundary()),\n            param_set,\n        ),\n        boundary_z = boundary_mask,\n        nsteps = nstepsO,\n        dt = Δt_ / nstepsO,\n        timestepper = LSRK54CarpenterKennedy,\n        numerics...,\n    )","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"Create the coupler object for holding import/export fields and performs mappings and instantiate the coupled timestepper:","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"    coupler = CplState()\n    coupler_register!(coupler, :Ocean_SST, deepcopy(mO.state.θ[mO.boundary]), mO.grid, DateTime(0), u\"°C\")\n    coupler_register!(coupler, :Atmos_MeanAirSeaθFlux, deepcopy(mA.state.F_accum[mA.boundary]), mA.grid, DateTime(0), u\"°C\")","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"Instantiate a coupled timestepper that steps forward the components and implements mapings between components export bondary states and other components imports.","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"    compA = (pre_step = preatmos, component_model = mA, post_step = postatmos)\n    compO = (pre_step = preocean, component_model = mO, post_step = postocean)\n    component_list = (atmosphere = compA, ocean = compO)\n    cpl_solver = CplSolver(\n        component_list = component_list,\n        coupler = coupler,\n        coupling_dt = Δt_,\n        t0 = 0.0,\n    )","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"Creat callbacks and bundle the simulation:","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"    # For now applying callbacks only to atmos.\n    callbacks = (\n        ExponentialFiltering(),\n        VTKOutput((\n            iteration = string(5Δt_)*\"ssecs\" ,\n            overdir =\"output\",\n            overwrite = true,\n            number_sample_points = 0\n            )...,),\n    )\n\n    simulation = (;\n        coupled_odesolver = cpl_solver,\n        odesolver = cpl_solver.component_list.atmosphere.component_model.stepper,\n        state = cpl_solver.component_list.atmosphere.component_model.state,\n        dgmodel =  cpl_solver.component_list.atmosphere.component_model.discretization,\n        callbacks = callbacks,\n        simtime = (t_time, end_time),\n        name = \"Coupler_UnitTest_ctrl\",\n        )\n\n    return simulation\nend\n\n\nfunction run(cpl_solver, numberofsteps, cbvector)\n    # Run the model\n    solve!(\n        nothing,\n        cpl_solver;\n        numberofsteps = numberofsteps,\n        callbacks = cbvector,\n    )\nend","category":"page"},{"location":"generated/run_script_v2/#Run-simulation","page":"Advection-diffusion on a Sphere","title":"Run simulation","text":"","category":"section"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"simulation = main(Float64);\nnsteps = Int(simulation.simtime[2] / simulation.coupled_odesolver.dt)\ncbvector = create_callbacks(simulation, simulation.odesolver)\nprintln(\"Initialized. Running...\")\n@time run(simulation.coupled_odesolver, nsteps, cbvector)","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"","category":"page"},{"location":"generated/run_script_v2/","page":"Advection-diffusion on a Sphere","title":"Advection-diffusion on a Sphere","text":"This page was generated using Literate.jl.","category":"page"},{"location":"couplerstate/#Coupler-State","page":"Coupler State","title":"Coupler State","text":"","category":"section"},{"location":"couplerstate/","page":"Coupler State","title":"Coupler State","text":"The coupler provides a space to store information being passed between coupled model components at their boundaries. During this exchange, the coupler manages ancillary operations such as regridding, unit conversions, filtering, etc.","category":"page"},{"location":"couplerstate/","page":"Coupler State","title":"Coupler State","text":"The CouplerMachine defines a type CplState for a container variable that holds information about the field boundary values that are being used to couple components. Components can use a coupler_put! operation to  export a set of field values to a CplState variable. A coupler_get operation is used to retrieve a set of field values from a CplState variable. During this exchange, the coupler manages ancillary operations such as  regridding, unit conversions, or filtering.","category":"page"},{"location":"couplerstate/#Coupler-Object-API","page":"Coupler State","title":"Coupler Object API","text":"","category":"section"},{"location":"couplerstate/","page":"Coupler State","title":"Coupler State","text":"    CouplerMachine.CplState\n    CouplerMachine.coupler_register!\n    CouplerMachine.coupler_put!\n    CouplerMachine.coupler_get","category":"page"},{"location":"couplerstate/#CouplerMachine.CplState","page":"Coupler State","title":"CouplerMachine.CplState","text":"CplState()\n\nType for holding coupler \"state\". This is the namespace through which coupled components communicate. Its role is to provide a level of indirection so that components remain modular and so that any data communication, interpolation, reindexing/unit conversions and filtering  etc... can be embeded in the intermdediate coupling layer.\n\nA field is exported by one component and imported by one or more other components.\n\n\n\n\n\n","category":"type"},{"location":"couplerstate/#CouplerMachine.coupler_register!","page":"Coupler State","title":"CouplerMachine.coupler_register!","text":"Coupling.coupler_register!(\n        coupler::CplState,\n        fieldname::Symbol,\n        fieldvalue,\n        grid,\n        datetime::DateTime,\n        units::Unitful.Units = Unitful.NoUnits, \n    )\n\nAdd a field to the coupler that is accessible with key fieldname. \n\nArguments\n\ncoupler: coupler object the field is registered to.\nfieldname: key to access the field in the coupler.\nfieldvalue: data array of field values.\ngrid: grid the field is stored on.\ndatetime: time associated with the field state.\nunits: units associated with the field values. Dimensionless by default.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#CouplerMachine.coupler_put!","page":"Coupler State","title":"CouplerMachine.coupler_put!","text":"coupler_put!(coupler::CplState, fieldname::Symbol, fieldvalue, gridinfo, datetime::DateTime, units::Unitful.Units)\n\nUpdates coupler field fieldname with fieldvalue, the field's value at time datetime.\n\ngridinfo and units inform the coupler of the format of the inputted data allowing conversion to match the grid and units of the coupler field.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#CouplerMachine.coupler_get","page":"Coupler State","title":"CouplerMachine.coupler_get","text":"coupler_get(coupler::CplState, fieldname::Symbol, gridinfo, datetime::DateTime, units::Unitful.Units)\n\nRetrieve data array corresponding to fieldname.\n\nReturns data on the grid specified by gridinfo and in the units of units. Checks that the coupler data field is the state at time datetime.\n\n\n\n\n\n","category":"function"},{"location":"#CouplerMachine.jl","page":"Home","title":"CouplerMachine.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Coupling CliMA Models","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CouplerMachine","category":"page"},{"location":"","page":"Home","title":"Home","text":"CouplerMachine.jl provides a means to couple climate model components from and within ClimateMachine.jl and Oceananigans.jl.  It is designed to provide a flexible way to map boundary fluxes of quantities, like moisture and heat, that leave one component  model (for example the atmosphere) to boundary fluxes of another component model (for example the ocean model). Functionality includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"coupled system time stepping control that integrates fluxes in time for sharing between components with differing time steps and/or time stepping schemes.\nsupport for mapping import and export boundary information between components so that fluxes of properties transferred between components are conserved.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The CouplerMachine supports coupling components that are all within the same process or coupling components (using MPI) that are running on different processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Coupler Scheme)\nCouplerMachine allows for independent development of interchangeable component models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"    CouplerMachine","category":"page"},{"location":"#CouplerMachine.CouplerMachine","page":"Home","title":"CouplerMachine.CouplerMachine","text":"CouplerMachine\n\nPrimitive coupling module sufficient for initial atmos-ocean-land coupled simulation.\n\n\n\n\n\n","category":"module"},{"location":"timestepping/#Coupled-Timestepping","page":"Coupled Timestepping","title":"Coupled Timestepping","text":"","category":"section"},{"location":"timestepping/","page":"Coupled Timestepping","title":"Coupled Timestepping","text":"CouplerMachine currently uses a sequential timestepping framework in which one component steps forward before passing its updated state to another. An outer \"coupled\" timestep determines when component models synchronize and coordinate with the coupler. Within this coupled timestep, components take an integer number of substeps, and evolve independently from each other.","category":"page"},{"location":"timestepping/","page":"Coupled Timestepping","title":"Coupled Timestepping","text":"CplSolver extends the ODE solver API of ClimateMachine.ODESolvers.","category":"page"},{"location":"timestepping/","page":"Coupled Timestepping","title":"Coupled Timestepping","text":"CouplerMachine.CplSolver","category":"page"},{"location":"timestepping/#CouplerMachine.CplSolver","page":"Coupled Timestepping","title":"CouplerMachine.CplSolver","text":"CplSolver(; component_list, coupler::CplState, coupling_dt, t0)\n\nA time stepping like object for advancing a coupled system made up of a pre-defined set of named components specified in component_list. Each component is a balance law, discretization and timestepper collection. The coupler will step them forward by a nsteps substeps to advance the coupled system by a simulated time coupling_dt.\n\nComponents interact with the coupler during pre_step() and post_step() functions. During a pre_step(), a component may get fields from the coupler name space. A component may put fields into the coupler name space during the post_step() for later use by other components. The CplSolver abstraction controls\n\nthe outer time stepping sequencing of components\nthe execution of actions mapping exports from one or more components to imports of other components through an intermediary coupler name space.\n\n\n\n\n\n","category":"type"},{"location":"coupledmodel/#Coupled-Model-Components","page":"Coupled Model Components","title":"Coupled Model Components","text":"","category":"section"},{"location":"coupledmodel/","page":"Coupled Model Components","title":"Coupled Model Components","text":"CouplerMachine provides a wrapper for model components so that they may connect to the coupler. The CplModel struct packages a component model with the information needed for the CplSolver to evolve it.","category":"page"},{"location":"coupledmodel/","page":"Coupled Model Components","title":"Coupled Model Components","text":"    CouplerMachine.CplModel","category":"page"},{"location":"coupledmodel/#CouplerMachine.CplModel","page":"Coupled Model Components","title":"CouplerMachine.CplModel","text":"CplModel(; \n    grid,\n    equations,\n    nsteps::Int,\n    boundary_z = 0.0,\n    dt = 1.0,\n    timestepper = LSRK54CarpenterKennedy,\n    NFfirstorder = RusanovNumericalFlux(),\n    NFsecondorder = CentralNumericalFluxSecondOrder(),\n    NFgradient = CentralNumericalFluxGradient(),\n    overint_params = nothing,\n    callbacks = (),\n)\n\nBuilds an instance of a coupler test model. This is currently a toy model used for testing and designing coupling machinery. In a full-blown coupled experiment this model would be replaced by a full component model that is wrapped to format it for coupler compatibility.\n\ngrid the spectral element grid used by this model. \nequations the Balance Law used by this model.\nnsteps number of component steps to run during each coupling step.\nboundary_z height above or below the air-sea interface of the coupled boundary.\ndt component timestep to use on each component step.\ntimestepper the ODE solver used to advance the system.\nNFfirstorder numerical flux to use for first order terms.\nNFsecondorder numerical flux to use for second order terms.\nNFgradient numerical flux to use for gradient terms.\noverint_params overintegration parameters.\ncallbacks component-specific callbacks executed at inner time steps.\n\nEach returned model instance is independent and has its own grid, balance law, time stepper and other attributes.  For now the code keeps some of these things the same for initial testing, including component timestepper and initial time (both of which need tweaking to use for real setups).\n\nA real model might have many more flags and/or may wrap the component creation very differently. Any component should allow itself to set a number of timesteps to execute with a certain timestep to synchronize with the coupling time scale.\n\n\n\n\n\n","category":"type"}]
}
