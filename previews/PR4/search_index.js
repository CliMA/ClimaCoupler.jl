var documenterSearchIndex = {"docs":
[{"location":"generated/simple_2testcomp/","page":"Simple Two Component Test","title":"Simple Two Component Test","text":"EditURL = \"https://github.com/CliMA/CouplerMachine/blob/master/experiments/DesignTests/simple_2testcomp.jl\"","category":"page"},{"location":"generated/simple_2testcomp/#Import-packages","page":"Simple Two Component Test","title":"Import packages","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Simple Two Component Test","title":"Simple Two Component Test","text":"using ClimateMachine\nusing MPI\nusing Statistics\n\n# To couple\nusing CouplerMachine\nusing Unitful, Dates\n\n# To create meshes & grids\nusing ClimateMachine.Ocean.Domains\nusing ClimateMachine.Grids\nimport ClimateMachine.DGMethods.NumericalFluxes: NumericalFluxSecondOrder\n\n# To setup some callbacks\nusing ClimateMachine.GenericCallbacks\n\n# To invoke timestepper\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.ODESolvers: solve!\nusing ClimateMachine.MPIStateArrays: weightedsum\n\nClimateMachine.init()\nconst FT = Float64;\n\nif !(:CplTestingBL in names(Main))\n    include(\"CplTestingBL.jl\") # allows re-run of script without restarting julia\nend\nusing .CplTestingBL","category":"page"},{"location":"generated/simple_2testcomp/#Set-simulation-parameters","page":"Simple Two Component Test","title":"Set simulation parameters","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Simple Two Component Test","title":"Simple Two Component Test","text":"couple_dt = 3600.0 # timestep at which coupled components sync\nnstepsA = 10 # atmos steps per coupled timestep\nnstepsO = 5 # ocean steps per coupled timestep\n\n#  Haney like relaxation time scale and a length scale (Haney, 1971).\n#  Air-sea exchange vigor is governed by length/time-scale.\nconst τ_airsea = FT(60 * 86400)\nconst L_airsea = FT(500)\nconst λ_airsea = FT(L_airsea / τ_airsea)\nfunction coupling_lambda()\n    return (λ_airsea)\nend;\n\n#  Background atmos and ocean diffusivities\nconst κᵃʰ = FT(1e4) * 0.0\nconst κᵃᶻ = FT(1e-1)\nconst κᵒʰ = FT(1e3) * 0.0\nconst κᵒᶻ = FT(1e-4)","category":"page"},{"location":"generated/simple_2testcomp/#Set-up-coupled-model","page":"Simple Two Component Test","title":"Set up coupled model","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Simple Two Component Test","title":"Simple Two Component Test","text":"function main(::Type{FT}) where {FT}\n    # Domain\n    Np = 4\n    ΩA = RectangularDomain(\n        Ne = (10, 10, 5),\n        Np = Np,\n        x = (0, 1e6),\n        y = (0, 1e6),\n        z = (0, 1e5),\n        periodicity = (true, true, false),\n    )\n    ΩO = RectangularDomain(\n        Ne = (10, 10, 4),\n        Np = Np,\n        x = (0, 1e6),\n        y = (0, 1e6),\n        z = (-4e3, 0),\n        periodicity = (true, true, false),\n    )\n\n    # Grid\n    btags = ((0,0),(0,0),(1,2))\n    gridA = DiscontinuousSpectralElementGrid(ΩA; boundary_tags = btags)\n    gridO = DiscontinuousSpectralElementGrid(ΩO; boundary_tags = btags)\n\n    # Numerics-specific options\n    numerics = (NFsecondorder = CplTestingBL.PenaltyNumFluxDiffusive(),)\n\n    # Callbacks (TODO)\n    callbacks = ()\n\n    # Collect spatial info, timestepping, balance law and DGmodel for the two components\n\n    # 1. Atmos component\n    mA = CplModel(;\n        grid = gridA,\n        equations = CplTestBL(\n            bl_propA,\n            (CoupledPrimaryBoundary(), ExteriorBoundary()),\n        ),\n        nsteps = nstepsA,\n        dt = couple_dt / nstepsA,\n        numerics...,\n    )\n\n    # 2. Ocean component\n    mO = CplModel(;\n        grid = gridO,\n        equations = CplTestBL(\n            bl_propO,\n            (ExteriorBoundary(), CoupledSecondaryBoundary()),\n        ),\n        nsteps = nstepsO,\n        dt = couple_dt / nstepsO,\n        numerics...,\n    )\n\n    # Create a Coupler State object for holding imort/export fields.\n    coupler = CplState()\n    register_cpl_field!(coupler, :Ocean_SST, deepcopy(mO.state.θ[mO.boundary]), mO.grid, DateTime(0), u\"°C\")\n    register_cpl_field!(coupler, :Atmos_MeanAirSeaθFlux, deepcopy(mA.state.F_accum[mA.boundary]), mA.grid, DateTime(0), u\"°C\")\n\n    # Instantiate a coupled timestepper that steps forward the components and\n    # implements mapings between components export bondary states and\n    # other components imports.\n\n    compA = (pre_step = preatmos, component_model = mA, post_step = postatmos)\n    compO = (pre_step = preocean, component_model = mO, post_step = postocean)\n    component_list = (atmosphere = compA, ocean = compO)\n    cpl_solver = CplSolver(\n        component_list = component_list,\n        coupler = coupler,\n        coupling_dt = couple_dt,\n        t0 = 0.0,\n    )\n\n    return cpl_solver, callbacks\nend\n\nfunction run(cpl_solver, numberofsteps, cbvector)\n    solve!(\n        nothing,\n        cpl_solver;\n        numberofsteps = numberofsteps,\n        callbacks = cbvector,\n    )\nend","category":"page"},{"location":"generated/simple_2testcomp/#Define-pre_step-and-post_step-functions","page":"Simple Two Component Test","title":"Define pre_step and post_step functions","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Simple Two Component Test","title":"Simple Two Component Test","text":"function get_components(csolver)\n    mA = csolver.component_list.atmosphere.component_model\n    mO = csolver.component_list.ocean.component_model\n    return mA, mO\nend\n\nfunction preatmos(csolver)\n    mA, mO = get_components(csolver)\n\n    # Set boundary SST used in atmos to SST of ocean surface at start of coupling cycle.\n    mA.discretization.state_auxiliary.θ_secondary[mA.boundary] .=\n        CouplerMachine.get(csolver.coupler, :Ocean_SST, mA.grid, DateTime(0), u\"°C\")\n    # Set atmos boundary flux accumulator to 0.\n    mA.state.F_accum .= 0\n\n    @info(\n        \"preatmos\",\n        time = csolver.t,\n        total_θ_atmos = weightedsum(mA.state, 1),\n        total_θ_ocean = weightedsum(mO.state, 1),\n        total_θ = weightedsum(mA.state, 1) + weightedsum(mO.state, 1),\n        atmos_θ_surface_max = maximum(mA.state.θ[mA.boundary]),\n        ocean_θ_surface_max = maximum(mO.state.θ[mO.boundary]),\n    )\nend\n\nfunction postatmos(csolver)\n    mA, mO = get_components(csolver)\n\n    # Pass atmos exports to \"coupler\" namespace\n    # 1. Save mean θ flux at the Atmos boundary during the coupling period\n    CouplerMachine.put!(csolver.coupler, :Atmos_MeanAirSeaθFlux, mA.state.F_accum[mA.boundary] ./ csolver.dt,\n        mA.grid, DateTime(0), u\"°C\")\n\n    @info(\n        \"postatmos\",\n        time = time = csolver.t + csolver.dt,\n        total_θ_atmos = weightedsum(mA.state, 1),\n        total_θ_ocean = weightedsum(mO.state, 1),\n        total_F_accum = mean(mA.state.F_accum[mA.boundary]) * 1e6 * 1e6,\n        total_θ =\n            weightedsum(mA.state, 1) +\n            weightedsum(mO.state, 1) +\n            mean(mA.state.F_accum[mA.boundary]) * 1e6 * 1e6,\n        F_accum_max = maximum(mA.state.F_accum[mA.boundary]),\n        F_avg_max = maximum(mA.state.F_accum[mA.boundary] ./ csolver.dt),\n        atmos_θ_surface_max = maximum(mA.state.θ[mA.boundary]),\n        ocean_θ_surface_max = maximum(mO.state.θ[mO.boundary]),\n    )\nend\n\nfunction preocean(csolver)\n    mA, mO = get_components(csolver)\n\n    # Set mean air-sea theta flux\n    mO.discretization.state_auxiliary.F_prescribed[mO.boundary] .=\n        CouplerMachine.get(csolver.coupler, :Atmos_MeanAirSeaθFlux, mO.grid, DateTime(0), u\"°C\")\n    # Set ocean boundary flux accumulator to 0. (this isn't used)\n    mO.state.F_accum .= 0\n\n    @info(\n        \"preocean\",\n        time = csolver.t,\n        F_prescribed_max =\n            maximum(mO.discretization.state_auxiliary.F_prescribed[mO.boundary]),\n        F_prescribed_min =\n            maximum(mO.discretization.state_auxiliary.F_prescribed[mO.boundary]),\n        ocean_θ_surface_max = maximum(mO.state.θ[mO.boundary]),\n        ocean_θ_surface_min = maximum(mO.state.θ[mO.boundary]),\n    )\nend\n\nfunction postocean(csolver)\n    mA, mO = get_components(csolver)\n    @info(\n        \"postocean\",\n        time = csolver.t + csolver.dt,\n        ocean_θ_surface_max = maximum(mO.state.θ[mO.boundary]),\n        ocean_θ_surface_min = maximum(mO.state.θ[mO.boundary]),\n    )\n\n    # Pass ocean exports to \"coupler\" namespace\n    #  1. Ocean SST (value of θ at z=0)\n    CouplerMachine.put!(csolver.coupler, :Ocean_SST, mO.state.θ[mO.boundary], mO.grid, DateTime(0), u\"°C\")\nend","category":"page"},{"location":"generated/simple_2testcomp/#Specify-balance-law","page":"Simple Two Component Test","title":"Specify balance law","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Simple Two Component Test","title":"Simple Two Component Test","text":"# Set atmosphere initial state function\nfunction atmos_init_theta(xc, yc, zc, npt, el)\n    return 30.0\nend\n# Set atmosphere shadow boundary flux function\nfunction atmos_theta_shadow_boundary_flux(θᵃ, θᵒ, npt, el, xc, yc, zc)\n    if zc == 0.0\n        tflux = (1.0 / τ_airsea) * (θᵃ - θᵒ)\n    else\n        tflux = 0.0\n    end\n    return tflux\nend\n# Set atmsophere diffusion coeffs\nfunction atmos_calc_kappa_diff(_...)\n    return κᵃʰ, κᵃʰ, κᵃᶻ\nend\n# Set atmos source!\nfunction atmos_source_theta(θᵃ, npt, el, xc, yc, zc, θᵒ)\n    tsource = 0.0\n    if zc == 0.0\n        # tsource = -(1. / τ_airsea)*( θᵃ-θᵒ )\n    end\n    return tsource\nend\n# Set penalty term tau (for debugging)\nfunction atmos_get_penalty_tau(_...)\n    return FT(3.0 * 0.0)\nend\n# Create atmos component\nbl_propA = CplTestingBL.prop_defaults()\n\nbl_propA = (;bl_propA..., init_theta = atmos_init_theta,\n            theta_shadow_boundary_flux = atmos_theta_shadow_boundary_flux)\nbl_propA = (bl_propA..., init_theta = atmos_init_theta)\nbl_propA =\n    (bl_propA..., theta_shadow_boundary_flux = atmos_theta_shadow_boundary_flux)\nbl_propA = (bl_propA..., calc_kappa_diff = atmos_calc_kappa_diff)\nbl_propA = (bl_propA..., source_theta = atmos_source_theta)\nbl_propA = (bl_propA..., get_penalty_tau = atmos_get_penalty_tau)\nbl_propA = (bl_propA..., coupling_lambda = coupling_lambda)\n\n# Set initial temperature profile\nfunction ocean_init_theta(xc, yc, zc, npt, el)\n    return 20.0\nend\n# Set boundary source imported from atmos\nfunction ocean_source_theta(θ, npt, el, xc, yc, zc, air_sea_flux_import)\n    sval = 0.0\n    if zc == 0.0\n        # sval=air_sea_flux_import\n    end\n    return sval\nend\n# Set ocean diffusion coeffs\nfunction ocean_calc_kappa_diff(_...)\n    # return κᵒʰ,κᵒʰ,κᵒᶻ*FT(100.)\n    return κᵒʰ, κᵒʰ, κᵒᶻ # m^2 s^-1\nend\n# Set penalty term tau (for debugging)\nfunction ocean_get_penalty_tau(_...)\n    return FT(0.15 * 0.0)\nend\n# Create ocean component\nbl_propO = CplTestingBL.prop_defaults()\nbl_propO = (bl_propO..., init_theta = ocean_init_theta)\nbl_propO = (bl_propO..., source_theta = ocean_source_theta)\nbl_propO = (bl_propO..., calc_kappa_diff = ocean_calc_kappa_diff)\nbl_propO = (bl_propO..., get_penalty_tau = ocean_get_penalty_tau)\nbl_propO = (bl_propO..., coupling_lambda = coupling_lambda)","category":"page"},{"location":"generated/simple_2testcomp/#Run-simulation","page":"Simple Two Component Test","title":"Run simulation","text":"","category":"section"},{"location":"generated/simple_2testcomp/","page":"Simple Two Component Test","title":"Simple Two Component Test","text":"simulation, cbvector = main(Float64);\nnsteps = 10\nprintln(\"Initialized. Running...\")\n@time run(simulation, nsteps, cbvector)","category":"page"},{"location":"generated/simple_2testcomp/","page":"Simple Two Component Test","title":"Simple Two Component Test","text":"","category":"page"},{"location":"generated/simple_2testcomp/","page":"Simple Two Component Test","title":"Simple Two Component Test","text":"This page was generated using Literate.jl.","category":"page"},{"location":"couplerstate/#Coupler-Object","page":"Coupler Object","title":"Coupler Object","text":"","category":"section"},{"location":"couplerstate/","page":"Coupler Object","title":"Coupler Object","text":"The CouplerMachine defines a type CplState for a container variable that holds information about the field  values that are being used to couple between components. Components can use a put! operation to  export a set of field values to a CplState variable. A get operation is used to retrieve a set field values from a CplState variable.","category":"page"},{"location":"couplerstate/#Coupler-Object-API","page":"Coupler Object","title":"Coupler Object API","text":"","category":"section"},{"location":"couplerstate/","page":"Coupler Object","title":"Coupler Object","text":"    CouplerMachine.CplState\n    CouplerMachine.register_cpl_field!\n    CouplerMachine.put!\n    CouplerMachine.get","category":"page"},{"location":"couplerstate/#CouplerMachine.CplState","page":"Coupler Object","title":"CouplerMachine.CplState","text":"CplState()\n\nType for holding coupler \"state\". This is the namespace through which coupled components communicate. Its role is to provide a level of indirection so that components remain modular and so that any data communication, interpolation, reindexing/unit conversions and filtering  etc... can be embeded in the intermdediate coupling layer.\n\nTo start with we can just use a dictionary key and value table that holds labelled pointers to various fields. A field is exported by one component and imported by one or more other components. Components can select which fields are needed by using the Dict symbols.\n\n\n\n\n\n","category":"type"},{"location":"couplerstate/#CouplerMachine.register_cpl_field!","page":"Coupler Object","title":"CouplerMachine.register_cpl_field!","text":"Coupling.register_cpl_field!(\n        coupler::CplState,\n        fieldname::Symbol,\n        fieldvalue,\n        grid,\n        datetime::DateTime,\n        units::Unitful.Units = Unitful.NoUnits, \n    )\n\nAdd a field to the coupler that is accessible with key fieldname. \n\nArguments\n\ncoupler: coupler object the field is registered to.\nfieldname: key to access the field in the coupler.\nfieldvalue: data array of field values.\ngrid: grid the field is stored on.\ndatetime: time associated with the field state.\nunits: units associated with the field values. Dimensionless by default.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#CouplerMachine.put!","page":"Coupler Object","title":"CouplerMachine.put!","text":"put!(coupler::CplState, fieldname::Symbol, fieldvalue, gridinfo, datetime::DateTime, units::Unitful.Units)\n\nUpdates coupler field fieldname with fieldvalue, the field's value at time datetime.\n\ngridinfo and units inform the coupler of the format of the inputted data allowing conversion to match the grid and units of the coupler field.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#CouplerMachine.get","page":"Coupler Object","title":"CouplerMachine.get","text":"get(coupler::CplState, fieldname::Symbol, gridinfo, datetime::DateTime, units::Unitful.Units)\n\nRetrieve data array corresponding to fieldname.\n\nReturns data on the grid specified by gridinfo and in the units of units. Checks that the coupler data field is the state at time datetime.\n\n\n\n\n\n","category":"function"},{"location":"#CouplerMachine.jl","page":"Home","title":"CouplerMachine.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) Coupling CliMA Models","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CouplerMachine","category":"page"},{"location":"","page":"Home","title":"Home","text":"CouplerMachine.jl provides a means to couple climate model components from and within ClimateMachine.jl and Oceananigans.jl.  It is designed to provide a flexible way to map boundary fluxes of quantities, like moisture and heat, that leave one component  model (for example the atmosphere) to boundary fluxes of another component model (for example the ocean model). Functionality includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"coupled system time stepping control that integrates fluxes in time for sharing between components with differing time steps and/or time stepping schemes.\nsupport for mapping import and export boundary information between components so that fluxes of properties transferred between components are conserved.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The CouplerMachine supports coupling components that are all within the same process or coupling components (using MPI) that are running on different processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"    CouplerMachine","category":"page"},{"location":"#CouplerMachine.CouplerMachine","page":"Home","title":"CouplerMachine.CouplerMachine","text":"CouplerMachine\n\nPrimitive coupling module sufficient for initial atmos-ocean-land coupled simulation.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"examples.md\",\n    \"timestepping.md\",\n    \"couplerstate.md\",\n]","category":"page"},{"location":"timestepping/#Coupled-Timestepping","page":"Coupled Timestepping","title":"Coupled Timestepping","text":"","category":"section"},{"location":"timestepping/","page":"Coupled Timestepping","title":"Coupled Timestepping","text":"CouplerMachine.CplSolver","category":"page"},{"location":"timestepping/#CouplerMachine.CplSolver","page":"Coupled Timestepping","title":"CouplerMachine.CplSolver","text":"CplSolver(; component_list, coupler::CplState, coupling_dt, t0)\n\nA time stepping like object for advancing a coupled system made up of a pre-defined set of named components specified in component_list. Each component is a balance law, discretization and timestepper collection. The coupler will step them forward by a nsteps substeps to advance the coupled system by a simulated time coupling_dt.\n\nComponents are registered with prestep() and poststep() functions. The prestep() functions get fields for use in the component from the coupler name space. The poststep() functions put fields for use by other components into te coupler name space.  The CplSolver abstraction controls\n\nthe outer time stepping sequencing of components\nthe excution of actions mapping exports from one or more components to imports of other components through an intermediary coupler name space.\n\nSome notes -\n\nFor now components need to include slightly wasteful \"shadow\" variables for accumulating boundary flux terms they compute across RK stages and across timesteps. These are defined within the component balance law. The shadown variable is a full 3d array because of the way the current  infrastructure works. This can be tidied up later once design is settled.\n\n\n\n\n\n","category":"type"}]
}
