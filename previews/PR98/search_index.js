var documenterSearchIndex = {"docs":
[{"location":"generated/sea_breeze/ocean_rhs/#Ocean-Model","page":"Ocean Model","title":"Ocean Model","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/#Slab-Ocean-ODE","page":"Ocean Model","title":"Slab Ocean ODE","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"For our ocean component, we solve a simple slab ocean ODE just as we did for the land:","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"rho_o c_o H_o partial_t T_ocn = - F_integ  Delta t_coupler","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"where rho_o = 1025 kg m ^-3, c_o=3850 J K ^-1 kg ^-1, H_o = 100 m are the density, specific heat and depth of the ocean,\nand F_integ is the integrated surface fluxes in time.","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Model-Code","page":"Ocean Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"function ocn_rhs!(du, u, (parameters, F_accumulated), t)\n    \"\"\"\n    Slab layer equation\n        d(T_sfc)/dt = - (F_accumulated) / (h_ocn * ρ_ocn * c_ocn)\n        where\n            F_accumulated = F_integrated / Δt_coupler\n    \"\"\"\n    @unpack ocn_h, ocn_ρ, ocn_c = parameters\n    @unpack T_sfc = du\n\n    @. T_sfc = (-F_accumulated) / (ocn_h * ocn_ρ * ocn_c)\nend\n\n# set up domain\nfunction hspace_1D(xlim = (-π, π), npoly = 0, helem = 10)\n    FT = Float64\n\n    domain = Domains.IntervalDomain(Geometry.XPoint{FT}(xlim[1]) .. Geometry.XPoint{FT}(xlim[2]), periodic = true)\n    mesh = Meshes.IntervalMesh(domain; nelems = helem)\n    topology = Topologies.IntervalTopology(mesh)\n\n    # Finite Volume Approximation: Gauss-Lobatto with 1pt per element\n    quad = Spaces.Quadratures.GL{npoly + 1}()\n    space = Spaces.SpectralElementSpace1D(topology, quad)\n\n    return space\nend\n\n# init simulation\nfunction ocn_init(; xmin = -1000, xmax = 1000, helem = 20, npoly = 0)\n\n    # construct domain spaces - get only surface layer (NB: z should be zero, not z = first central height)\n    space = hspace_1D((xmin, xmax), npoly, helem)\n    coords = Fields.coordinate_field(space)\n    domain = space\n\n    # initial condition\n    T_sfc = map(coords) do coord\n        T_sfc = 267.0\n    end\n\n    # prognostic variable\n    Y = Fields.FieldVector(T_sfc = T_sfc)\n\n    return Y, domain\nend","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Coupled-Ocean-Wrappers","page":"Ocean Model","title":"Coupled Ocean Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"# Ocean Simulation - Later to live in Oceananigans\nstruct OceanSimulation <: ClimaCoupler.AbstractOceanSimulation\n    integrator::Any\nend\n\nfunction OceanSimulation(Y_init, t_start, dt, t_end, timestepper, p, saveat, callbacks = CallbackSet())\n    ocn_prob = ODEProblem(ocn_rhs!, Y_init, (t_start, t_end), p)\n    ocn_integ = init(ocn_prob, timestepper, dt = dt, saveat = saveat, callback = callbacks)\n    return OceanSimulation(ocn_integ)\nend\n\nfunction ClimaCoupler.coupler_push!(coupler::ClimaCoupler.CouplerState, ocean::OceanSimulation)\n    coupler_put!(coupler, :T_sfc_ocean, ocean.integrator.u.T_sfc, ocean)\nend\n\nfunction ClimaCoupler.coupler_pull!(ocean::OceanSimulation, coupler::ClimaCoupler.CouplerState)\n    coupler_get!(ocean.integrator.p.F_sfc, coupler, :F_sfc, ocean)\n    ocean.integrator.p.F_sfc ./= coupler.Δt_coupled\nend","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/sea_breeze/run/#Coupled-Sea-Breeze","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"","category":"section"},{"location":"generated/sea_breeze/run/#Overview","page":"Coupled Sea Breeze","title":"Overview","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"This sea breeze simulation consists of an atmosphere above ocean and land thermal slabs. The difference in heating between the land and ocean components drives circulation: cool ocean air flows towards the land at the surface while warm air over land rises and flows over the ocean.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"In this tutorial we demonstrate the coupling of three component models (atmosphere, ocean, and land) to drive the sea breeze. The primary parts of the ClimaCoupler interface are used and discussed.","category":"page"},{"location":"generated/sea_breeze/run/#Model-Initialization","page":"Coupled Sea Breeze","title":"Model Initialization","text":"","category":"section"},{"location":"generated/sea_breeze/run/#Component-Models","page":"Coupled Sea Breeze","title":"Component Models","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Component models are the building blocks of coupled models. They are often developed independently from one another and can be executed by themselves as \"standalone\" simulations. The coupler is used to combine these components into coupled simulations. Importantly, coupled simulations can re-use tendency methods developed for standalone simulations, maximizing code reuse and minimizing the necessary code that must be specialized for a coupled run–only special boundary conditions must be written. This is achieved by multiple dispatch, where methods that deal with boundaries dispatch off of a coupled boundary type. Here, the atmosphere has special boundary conditions for coupling while the ocean and land tendencies are unaltered. See the atmospheric model page for more details.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"In a more mature CliMA ecosystem, the following include statements would be replaced by using statements for the relevant component packages.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"include(\"atmos_rhs.jl\")\ninclude(\"ocean_rhs.jl\")\ninclude(\"land_rhs.jl\")\n\n# model parameters\nconst atm_T_ini = FT(270.0)\nconst MSLP = FT(1e5)\nconst grav = FT(9.8)\nconst R_d = FT(287.058)\nconst γ = FT(1.4)\nconst C_p = FT(R_d * γ / (γ - 1))\nconst C_v = FT(R_d / (γ - 1))\nconst R_m = R_d\ncpl_parameters = (\n    # atmos parameters\n    atm_μ = FT(0.0001), # diffusion coefficient\n    atm_T_top = FT(280.0), # fixed temperature at the top of the domain_atm\n    atm_T_ini = atm_T_ini, # initial condition of at temperature (isothermal) [K]\n    MSLP = MSLP, # mean sea level pressure\n    grav = grav, # gravitational constant\n    R_d = R_d, # R dry (gas constant / mol mass dry air)\n    γ = γ, # heat capacity ratio\n    C_p = C_p, # heat capacity at constant pressure\n    C_v = C_v, # heat capacity at constant volume\n    R_m = R_m, # moist R, assumed to be dry\n    # land slab parameters\n    lnd_h = FT(0.5), # depth of slab layer [m]\n    lnd_ρ = FT(1500), # density [kg m^-3]\n    lnd_c = FT(800), # specific heat [J K^-1 kg^-1]\n    lnd_T_ini = FT(260.0), # initial condition of at temperature (isothermal) [K]\n    # ocean slab parameters\n    ocn_h = FT(0.5), # depth of slab layer [m]\n    ocn_ρ = FT(1025), # density [kg m^-3]\n    ocn_c = FT(3850), # specific heat [J K^-1 kg^-1]\n    ocn_T_ini = FT(260.0), # initial condition of at temperature (isothermal) [K]\n    # coupling parameters\n    C_H = FT(0.0015),\n)\n\n# DSS callback\nfunction make_dss_func()\n    function _dss!(x::Fields.Field)\n        Spaces.weighted_dss!(x)\n    end\n    function _dss!(::Any)\n        nothing\n    end\n    dss_func(Y, t, integrator) = foreach(_dss!, Fields._values(Y))\n    return dss_func\nend\ndss_func = make_dss_func()\ndss_callback = FunctionCallingCallback(dss_func, func_start = true)","category":"page"},{"location":"generated/sea_breeze/run/#Initialization","page":"Coupled Sea Breeze","title":"Initialization","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"The coupled simulation synchronizes the component models at a coupling time step, Δt_cpl. Within that step, components may substep - each component specifies a number of substeps to take within Δt_cpl: atm_nsteps, ocn_nsteps, lnd_nsteps.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Component model states are initialized via the initialization methods each component would use in standalone mode. These states will be modified to reflect the full coupled system before executing the simulation.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"@info \"Init Models and Maps\"\n\nt_start, t_end = (0.0, 1.0)\nΔt_coupled = 0.1\nsaveat = 1e2\natm_nsteps, ocn_nsteps, lnd_nsteps = (5, 1, 1)\n\n# Initialize Models\natm_Y_default, atm_bc, atm_domain = atm_init(\n    xmin = -500,\n    xmax = 500,\n    zmin = 0,\n    zmax = 1000,\n    npoly = 4,\n    helem = 20,\n    velem = 20,\n    bc = (ρθ = (bottom = CoupledFlux(), top = ZeroFlux()),),\n)\n\nocn_Y_default, ocn_domain = ocn_init(xmin = -500, xmax = 0, helem = 10, npoly = 0)\n\nlnd_Y_default, lnd_domain = lnd_init(xmin = 0, xmax = 500, helem = 10, npoly = 0)","category":"page"},{"location":"generated/sea_breeze/run/#Remapping","page":"Coupled Sea Breeze","title":"Remapping","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Because models may live on different grids, remapping is necessary at the boundaries. Maps between coupled components must be constructed for each interacting pair. Remapping utilities are imported from ClimaCore.Operators.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"atm_boundary = Spaces.level(atm_domain.hv_face_space, PlusHalf(0))\n\nmaps = (\n    atmos_to_ocean = Operators.LinearRemap(ocn_domain, atm_boundary),\n    atmos_to_land = Operators.LinearRemap(lnd_domain, atm_boundary),\n    ocean_to_atmos = Operators.LinearRemap(atm_boundary, ocn_domain),\n    land_to_atmos = Operators.LinearRemap(atm_boundary, lnd_domain),\n)\n\n# initialize coupling fields\natm_T_sfc =\n    Operators.remap(maps.ocean_to_atmos, ocn_Y_default.T_sfc) .+\n    Operators.remap(maps.land_to_atmos, lnd_Y_default.T_sfc) # masked arrays; regrid to atm grid\natm_F_sfc = Fields.zeros(atm_boundary)\nocn_F_sfc = Fields.zeros(ocn_domain)\nlnd_F_sfc = Fields.zeros(lnd_domain)","category":"page"},{"location":"generated/sea_breeze/run/#Simulations","page":"Coupled Sea Breeze","title":"Simulations","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Each component is wrapped as a Simulation, which contains both the model (tendency) and the time-stepping information (solver, step size, etc). Simulations are the standard structures that the coupler works with, enabling dispatch of coupler methods. Here, we create three simulations: AtmosSimulation, OceanSimulation, and LandSimulation.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"atm_Y = Fields.FieldVector(Yc = atm_Y_default.Yc, ρw = atm_Y_default.ρw, F_sfc = atm_F_sfc)\natm_p = (cpl_p = cpl_parameters, T_sfc = atm_T_sfc, bc = atm_bc)\natmos = AtmosSimulation(atm_Y, t_start, Δt_coupled / atm_nsteps, t_end, SSPRK33(), atm_p, saveat, dss_callback)\n\nocn_Y = Fields.FieldVector(T_sfc = ocn_Y_default.T_sfc)\nocn_p = (cpl_parameters, F_sfc = ocn_F_sfc)\nocean = OceanSimulation(ocn_Y, t_start, Δt_coupled / ocn_nsteps, t_end, SSPRK33(), ocn_p, saveat)\n\nlnd_Y = Fields.FieldVector(T_sfc = lnd_Y_default.T_sfc)\nlnd_p = (cpl_parameters, F_sfc = lnd_F_sfc)\nland = LandSimulation(lnd_Y, t_start, Δt_coupled / lnd_nsteps, t_end, SSPRK33(), lnd_p, saveat)","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Additionally, we create a coupled simulation that contains the component simulations and the coupled time-stepping information.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"struct AOLCoupledSimulation{\n    A <: AtmosSimulation,\n    O <: OceanSimulation,\n    L <: LandSimulation,\n    C <: ClimaCoupler.CouplerState,\n} <: ClimaCoupler.AbstractCoupledSimulation\n    # Atmosphere Simulation\n    atmos::A\n    # Ocean Simulation\n    ocean::O\n    # Land Simulation\n    land::L\n    # Coupler storage\n    coupler::C\nend","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"step! is a key method within the Simulations interface. It advances a simulation to the specified t_stop, with that simulation advancing by its own internal step size to reach the specified time. Each simulation type should specify its own step method, allowing components to have different time integration backends. Here, all components are using OrdinaryDiffEq integrators and can share the same step! method.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"function step!(sim::ClimaCoupler.AbstractSimulation, t_stop)\n    Δt = t_stop - sim.integrator.t\n    step!(sim.integrator, Δt, true)\nend","category":"page"},{"location":"generated/sea_breeze/run/#The-Coupler","page":"Coupled Sea Breeze","title":"The Coupler","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"The CouplerState is a coupling struct used to store pointers or copies of the shared boundary information. All components are coupled by updating or accessing data in this CouplerState; component models do not directly interface with one another, only through the coupler.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"After creating the CouplerState object, coupled fields can be registered index the coupler via the coupler_add_field! method. This field is then accessible by coupler_get methods and can be updated via the coupler_put! methods.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Similarly, the coupler_add_map! method registers remapping operators in the coupler. To provide automatic remapping, there is a strict name convention for remap operators: a map from SimulationA to SimulationB (where ClimaCoupler.name returns :simA and :simB, respectively) must be named simA_to_simB so that the correct operator can be used.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Here, the models are coupled through heat transfer at the surface. This heat flux is computed by a bulk formula:","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"F_sfc = c_p rho_1 C_H u_1 (theta_sfc - theta_atm1)","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"where theta_sfc is the potential temperature at the land or ocean surface, theta_atm1 is the potential temperature at the lowest atmospheric level, c_p is the specific heat, C_H = 00015 is the bulk transfer coefficient for sensible heat, and u_1 is the near-surface atmospheric wind speed. We assume that the potential temperature is defined with respect to the surface pressure, so that theta_sfc = T_sfc.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"coupler = CouplerState(Δt_coupled)\ncoupler_add_field!(coupler, :T_sfc_ocean, ocean.integrator.u.T_sfc; write_sim = ocean)\ncoupler_add_field!(coupler, :T_sfc_land, land.integrator.u.T_sfc; write_sim = land)\ncoupler_add_field!(coupler, :F_sfc, atmos.integrator.u.F_sfc; write_sim = atmos)\nfor (name, map) in pairs(maps)\n    coupler_add_map!(coupler, name, map)\nend\n\nsim = AOLCoupledSimulation(atmos, ocean, land, coupler)","category":"page"},{"location":"generated/sea_breeze/run/#Coupled-Time-Integration","page":"Coupled Sea Breeze","title":"Coupled Time Integration","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Finally, the execution sequence of the component models must be specified. This is currently done explicitly with a combination of step!, coupler_pull!, and coupler_push! methods. The coupler_pull! and coupler_push! methods receive and send coupled field info from the coupler, respectively. They must be written for each component simulation, and are simply collections of coupler_get and coupler_put! methods for each component.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Here, the atmosphere steps forward first and then sends updated fields to the coupler. The ocean and land (which are not coupled to each other) then retreive the updated coupled information, advance and send their own updates to the coupler.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Because the models exchange fluxes only at the coupled timestep, the surface flux is accumulated over the coupled time-step coupling time step, Δt_cpl","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"F_integ = int_Delta t_coupler F_sfc  dt","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"where  F_integ has units of J m^-2.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"function cpl_run(simulation::AOLCoupledSimulation)\n    @info \"Run model\"\n    @unpack atmos, ocean, land, coupler = simulation\n    Δt_coupled = coupler.Δt_coupled\n    # coupler stepping\n    for t in ((t_start + Δt_coupled):Δt_coupled:t_end)\n        # Atmos\n        coupler_pull!(atmos, coupler)\n        step!(atmos, t)\n        coupler_push!(coupler, atmos)\n\n        # Ocean\n        coupler_pull!(ocean, coupler)\n        step!(ocean, t)\n        coupler_push!(coupler, ocean)\n\n        # Land\n        coupler_pull!(land, coupler)\n        step!(land, t)\n        coupler_push!(coupler, land)\n    end\n    @info \"Simulation Complete\"\nend\n\n# Run simulation\ncpl_run(sim)","category":"page"},{"location":"generated/sea_breeze/run/#References","page":"Coupled Sea Breeze","title":"References","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Antonelli & Rotunno 2007","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Atmospheric-Model","page":"Atmospheric Model","title":"Atmospheric Model","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/#Atmosphere-Conservation-Equations","page":"Atmospheric Model","title":"Atmosphere Conservation Equations","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Density:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rhopartial t + nabla cdot (rho vecu)= S(chi )","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Momentum (flux form):","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho vecupartial t + nabla cdot (rho vecu otimes vecu + pI)= nabla cdot (rho tau) - rho g + F_B()","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Potential temperature:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho thetapartial t + nabla cdot (rho theta vecu) = nabla cdot (kappa rho nabla theta)","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Total Energy (possibly replace potential temperature equation with total energy conservation):","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho e_totpartial t + nabla cdot ((rho e_tot + p )vecu) = nabla cdot (kappa rho nabla h_tot)","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"where h_tot is the total specific enthalpy given by internal and potential energy contributions.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Tracer transport:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho chipartial t + nabla cdot (rho chi vecu) = nabla cdot (kappa rho nabla chi) + S(chi )","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Diffusion (Constant Viscosity): The simplest model to represent diffusive processes is a constant-viscosity model, with prescribed kinematic viscosity nu such that the stress tensor can be modelled by","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"rhotau = -2rhonunabla u","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Smagorinsky Closure: The Smagorinsky closure is an eddy-viscosity model that captures the effect of energy transfer to the smallest scales of motion in the flow.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\nrhotau = -2rhonuvecS \nvecS = frac12((nabla u) + (nabla u)^T) \nnu = (C_sDelta_xyz)^2sqrt2S_ijS_ij\nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"with Delta_xyz the grid lengthscale (sometimes approximated as a geometric average Delta = (Delta_xDelta_yDelta_z)^13), nu is a spatially varying kinematic viscosity that depends on the local shear, vecS the symmetric rate-of-strain tensor, tau the diffusive momentum flux tensor. In stratified flows, we can apply a correction to the eddy viscosity to account for buoyancy effects. Thermal diffusivities are related to the modelled eddy-viscosity through the turbulent Prandtl number which takes a typical value of Pr_t= 13 such that kappa_2 = nuPr_t.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Tendencies for fourth-order hyperdiffusion are included in the rhs! construction, but the coefficient kappa_4 is 0 in this demonstrative case. Hyperdiffusive tendencies are typically included as a scale-selective diffusion mechanism for high-frequency noise (e.g. stabilization in GCMs).","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Consider components of the viscous stress tensor in three dimensions:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\ntau_xx = 2nu fracpartial upartial x \n\ntau_yy = 2nu fracpartial vpartial y \n\ntau_zz = 2nu fracpartial wpartial z \n\ntau_xy = nu Big(fracpartial upartial y +  fracpartial vpartial xBig) \n\ntau_xz = nu Big(fracpartial upartial z +  fracpartial wpartial xBig) \n\ntau_yz = nu Big(fracpartial vpartial z +  fracpartial wpartial yBig)\nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Assume terms in the y-direction are neglected (2-dimensional simplicfication). The contributions to the momentum equation are then given by:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\n(rho u)  partial_x (rho tau_xx) + partial_z(rhotau_xz)  = partial_x  Big(2nu fracpartial upartial xBig) + partial_zBig(nu fracpartial upartial zBig) + partial_zBig(nu fracpartial wpartial xBig) \n(rho w) partial_x (rho tau_zx)+ partial_z(rhotau_zz)  = partial_xBig(nu fracpartial upartial zBig) +  partial_xBig(nu fracpartial wpartial xBig) + partial_zBig(2nufracpartial wpartial z Big) \nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Which can be interpreted as, for horizontal-momentum:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Horizontal divergence of vertical gradients of cell-centered variables u\nVertical divergence of vertical gradients of cell-centered variables u\nVertical divergence of horizontal gradients of cell-face variables w","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"and for vertical-momentum, as:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Horizontal divergence of vertical gradients of cell-centered variables u\nHorizontal divergence of horizontal gradients of cell-face variables w\nVertical divergence of vertical gradients of cell-face variables w.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Model-Code","page":"Atmospheric Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"push!(LOAD_PATH, joinpath(@__DIR__, \"..\", \"..\", \"..\"))\n\nusing Test\nusing StaticArrays, IntervalSets, LinearAlgebra, UnPack\n\nimport ClimaCore: ClimaCore, slab, Spaces, Domains, Meshes, Geometry, Topologies, Spaces, Fields, Operators\nusing ClimaCore.Geometry\nusing ClimaCore.Utilities: PlusHalf\n\nusing Logging: global_logger\nusing TerminalLoggers: TerminalLogger\nglobal_logger(TerminalLogger())\n\nusing ClimaCoupler\n\n# set up function space\nfunction hvspace_2D(xlim = (-π, π), zlim = (0, 4π), helem = 20, velem = 20, npoly = 1)\n    FT = Float64\n    vertdomain = Domains.IntervalDomain(\n        Geometry.ZPoint{FT}(zlim[1]),\n        Geometry.ZPoint{FT}(zlim[2]);\n        boundary_tags = (:bottom, :top),\n    )\n    vertmesh = Meshes.IntervalMesh(vertdomain, nelems = velem)\n    vert_center_space = Spaces.CenterFiniteDifferenceSpace(vertmesh)\n\n    horzdomain = Domains.IntervalDomain(Geometry.XPoint{FT}(xlim[1]) .. Geometry.XPoint{FT}(xlim[2]), periodic = true)\n    horzmesh = Meshes.IntervalMesh(horzdomain; nelems = helem)\n    horztopology = Topologies.IntervalTopology(horzmesh)\n\n    quad = Spaces.Quadratures.GLL{npoly + 1}()\n    horzspace = Spaces.SpectralElementSpace1D(horztopology, quad)\n\n    hv_center_space = Spaces.ExtrudedFiniteDifferenceSpace(horzspace, vert_center_space)\n    hv_face_space = Spaces.FaceExtrudedFiniteDifferenceSpace(hv_center_space)\n    return (hv_center_space, hv_face_space)\nend\n\nfunction pressure(ρθ)\n    if ρθ >= 0\n        return MSLP * (R_d * ρθ / MSLP)^γ\n    else\n        return NaN\n    end\nend\n\nΦ(z) = grav * z\n\nabstract type BCtag end\nstruct ZeroFlux <: BCtag end\n\nbc_divF2C_bottom!(::ZeroFlux, dY, Y, p, t) = Operators.SetValue(Geometry.WVector(0.0))\nbc_divF2C_top!(::ZeroFlux, dY, Y, p, t) = Operators.SetValue(Geometry.WVector(0.0))\n\nfunction init_sea_breeze_2d(x, z)\n    θ₀ = atm_T_ini\n    cp_d = C_p\n    cv_d = C_v\n    p₀ = MSLP\n    g = grav\n    γ = cp_d / cv_d\n    z_c = 100.0\n    θ_b = atm_T_ini\n    θ_p = z < z_c ? rand() - 0.5 : 0.0 # potential temperature perturbation\n    θ = θ_b + θ_p # potential temperature\n    π_exn = 1.0 - g * z / cp_d / θ # exner function\n    T = π_exn * θ # temperature\n    p = p₀ * π_exn^(cp_d / R_d) # pressure\n    ρ = p / R_d / T # density\n    ρθ = ρ * θ # potential temperature density\n    return (ρ = ρ, ρθ = ρθ, ρuₕ = ρ * Geometry.UVector(0.0))\nend\n\nfunction atm_rhs!(dY, Y, params, t)\n    ρw = Y.ρw\n    Yc = Y.Yc\n    dYc = dY.Yc\n    dρw = dY.ρw\n\n    center_coords = Fields.coordinate_field(axes(Yc))\n\n    # spectral horizontal operators\n    hdiv = Operators.Divergence()\n    hgrad = Operators.Gradient()\n    hwdiv = Operators.WeakDivergence()\n    hwgrad = Operators.WeakGradient()\n\n    # vertical FD operators with BC's\n    vdivf2c = Operators.DivergenceF2C(\n        bottom = Operators.SetValue(Geometry.WVector(0.0)),\n        top = Operators.SetValue(Geometry.WVector(0.0)),\n    )\n    vvdivc2f = Operators.DivergenceC2F(\n        bottom = Operators.SetDivergence(Geometry.WVector(0.0)),\n        top = Operators.SetDivergence(Geometry.WVector(0.0)),\n    )\n    uvdivf2c = Operators.DivergenceF2C(\n        bottom = Operators.SetValue(Geometry.WVector(0.0) ⊗ Geometry.UVector(0.0)),\n        top = Operators.SetValue(Geometry.WVector(0.0) ⊗ Geometry.UVector(0.0)),\n    )\n    If = Operators.InterpolateC2F(bottom = Operators.Extrapolate(), top = Operators.Extrapolate())\n    Ic = Operators.InterpolateF2C()\n    ∂ = Operators.DivergenceF2C(\n        bottom = Operators.SetValue(Geometry.WVector(0.0)),\n        top = Operators.SetValue(Geometry.WVector(0.0)),\n    )\n    ∂f = Operators.GradientC2F()\n    ∂c = Operators.GradientF2C()\n    B = Operators.SetBoundaryOperator(\n        bottom = Operators.SetValue(Geometry.WVector(0.0)),\n        top = Operators.SetValue(Geometry.WVector(0.0)),\n    )\n\n    ∇_z_ρθ = Operators.DivergenceF2C(\n        bottom = bc_divF2C_bottom!(params.bc.ρθ.bottom, dY, Y, params, t),\n        top = bc_divF2C_top!(params.bc.ρθ.top, dY, Y, params, t),\n    )\n\n    uₕ = @. Yc.ρuₕ / Yc.ρ\n    w = @. ρw / If(Yc.ρ)\n    wc = @. Ic(ρw) / Yc.ρ\n    p = @. pressure(Yc.ρθ)\n    θ = @. Yc.ρθ / Yc.ρ\n    Yfρ = @. If(Yc.ρ)\n\n    ### HYPERVISCOSITY\n    # 1) compute hyperviscosity coefficients\n    @. dYc.ρθ = hwdiv(hgrad(θ))\n    @. dYc.ρuₕ = hwdiv(hgrad(uₕ))\n    @. dρw = hwdiv(hgrad(w))\n    Spaces.weighted_dss!(dYc)\n    Spaces.weighted_dss!(dρw)\n\n    κ₄ = 0.0 # m^4/s\n    @. dYc.ρθ = -κ₄ * hwdiv(Yc.ρ * hgrad(dYc.ρθ))\n    @. dYc.ρuₕ = -κ₄ * hwdiv(Yc.ρ * hgrad(dYc.ρuₕ))\n    @. dρw = -κ₄ * hwdiv(Yfρ * hgrad(dρw))\n\n    # density\n    @. dYc.ρ = -∂(ρw)\n    @. dYc.ρ -= hdiv(Yc.ρuₕ)\n\n    # potential temperature\n    @. dYc.ρθ += -(∇_z_ρθ(ρw * If(Yc.ρθ / Yc.ρ)))\n    @. dYc.ρθ -= hdiv(uₕ * Yc.ρθ)\n\n    # horizontal momentum\n    Ih = Ref(Geometry.Axis2Tensor((Geometry.UAxis(), Geometry.UAxis()), @SMatrix [1.0]))\n    @. dYc.ρuₕ += -uvdivf2c(ρw ⊗ If(uₕ))\n    @. dYc.ρuₕ -= hdiv(Yc.ρuₕ ⊗ uₕ + p * Ih)\n\n    # vertical momentum\n    @. dρw +=\n        B(Geometry.transform(Geometry.WAxis(), -(∂f(p)) - If(Yc.ρ) * ∂f(Φ(center_coords.z))) - vvdivc2f(Ic(ρw ⊗ w)))\n    uₕf = @. If(Yc.ρuₕ / Yc.ρ) # requires boundary conditions\n    @. dρw -= hdiv(uₕf ⊗ ρw)\n\n    # DIFFUSION\n    κ₂ = 5.0 # m^2/s\n    #  1a) horizontal div of horizontal grad of horiz momentun\n    @. dYc.ρuₕ += hwdiv(κ₂ * (Yc.ρ * hgrad(Yc.ρuₕ / Yc.ρ)))\n    #  1b) vertical div of vertical grad of horiz momentun\n    @. dYc.ρuₕ += uvdivf2c(κ₂ * (Yfρ * ∂f(Yc.ρuₕ / Yc.ρ)))\n\n    #  1c) horizontal div of horizontal grad of vert momentum\n    @. dρw += hwdiv(κ₂ * (Yfρ * hgrad(ρw / Yfρ)))\n    #  1d) vertical div of vertical grad of vert momentun\n    @. dρw += vvdivc2f(κ₂ * (Yc.ρ * ∂c(ρw / Yfρ)))\n\n    #  2a) horizontal div of horizontal grad of potential temperature\n    @. dYc.ρθ += hwdiv(κ₂ * (Yc.ρ * hgrad(Yc.ρθ / Yc.ρ)))\n    #  2b) vertical div of vertial grad of potential temperature\n    @. dYc.ρθ += ∇_z_ρθ(κ₂ * (Yfρ * ∂f(Yc.ρθ / Yc.ρ)))\n\n    Spaces.weighted_dss!(dYc)\n    Spaces.weighted_dss!(dρw)\n    return dY\nend\n\n# init simulation\nfunction atm_init(; xmin = -500, xmax = 500, zmin = 0, zmax = 1000, npoly = 3, helem = 20, velem = 20, bc = nothing)\n\n    # construct domain spaces\n    hv_center_space, hv_face_space = hvspace_2D((xmin, xmax), (zmin, zmax), helem, velem, npoly) # [m]\n    center_coords = Fields.coordinate_field(hv_center_space)\n    face_coords = Fields.coordinate_field(hv_face_space)\n    domain = (hv_center_space = hv_center_space, hv_face_space = hv_face_space)\n\n    # initialize prognostic variables\n    Yc = map(center_coords) do coord\n        sea_breeze = init_sea_breeze_2d(coord.x, coord.z)\n        sea_breeze\n    end\n\n    ρw = map(face_coords) do coord\n        Geometry.WVector(0.0)\n    end\n\n    Y = Fields.FieldVector(Yc = Yc, ρw = ρw)\n\n    # select boundary conditions\n    if bc === nothing\n        bc = (\n            ρθ = (bottom = CoupledFlux(), top = ZeroFlux()),\n            ρu = nothing, # for now BCs are hard coded, except for ρθ\n        )\n    end\n\n    return Y, bc, domain\nend\n\nusing OrdinaryDiffEq\nfunction atm_run!(Y, bc, domain)\n    dYdt = similar(Y)\n    params = (aux_params = 0.0, T_sfc = 1.0, bc = bc, domain = domain)\n    atm_rhs!(dYdt, Y, params, 0.0)\n    prob = ODEProblem(atm_rhs!, Y, (0.0, 250.0), params)\n    Δt = 0.025\n    sol = solve(prob, SSPRK33(), dt = Δt, saveat = 1.0, progress = true, progress_message = (dt, u, params, t) -> t)\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Coupled-Atmos-Wrappers","page":"Atmospheric Model","title":"Coupled Atmos Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"# Atmos Simulation - later to live in ClimaAtmos\nstruct AtmosSimulation <: ClimaCoupler.AbstractAtmosSimulation\n    integrator::Any\nend\n\nfunction AtmosSimulation(Y_init, t_start, dt, t_end, timestepper, p, saveat, callbacks = CallbackSet())\n    atm_prob = ODEProblem(atm_rhs!, Y_init, (t_start, t_end), p)\n\n    atm_integ = init(\n        atm_prob,\n        timestepper,\n        dt = dt,\n        saveat = saveat,\n        progress = true,\n        progress_message = (dt, u, params, t) -> t,\n        callback = callbacks,\n    )\n\n    return AtmosSimulation(atm_integ)\nend\n\nfunction ClimaCoupler.coupler_push!(coupler::ClimaCoupler.CouplerState, atmos::AtmosSimulation)\n    coupler_put!(coupler, :F_sfc, atmos.integrator.u.F_sfc, atmos)\nend\n\nfunction ClimaCoupler.coupler_pull!(atmos::AtmosSimulation, coupler::ClimaCoupler.CouplerState)\n    # reset flux accumulator\n    atmos.integrator.u.F_sfc .= 0.0 # reset surface flux to be accumulated\n\n    T_sfc_ocean = coupler_get(coupler, :T_sfc_ocean, atmos)\n    T_sfc_land = coupler_get(coupler, :T_sfc_land, atmos)\n    atmos.integrator.p.T_sfc .= T_sfc_land .+ T_sfc_ocean\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Coupled-Boundary-Conditions","page":"Atmospheric Model","title":"Coupled Boundary Conditions","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"The standalone atmosphere model uses two boundary condition methods in its tendency: bc_divF2C_bottom! and bc_divF2C_top!. Since the bottom boundary is coupled, bc_divF2C_bottom! must be altered when running in coupled mode to properly calculate and accumulate the boundary flux from the ocean and land components.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"To solve this, a CoupledFlux boundary tag is set for the bottom boundary during initialization. Then, a new method of bc_divF2C_bottom! is written to dispatch on the CoupledFlux boundary tag. This method can then compute the flux appropriately.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"struct CoupledFlux <: BCtag end\nfunction bc_divF2C_bottom!(::CoupledFlux, dY, Y, p, t)\n    # flux calculation\n    Yc = Y.Yc\n    uₕ = Yc.ρuₕ ./ Yc.ρ\n    ρw = Y.ρw\n    If2c = Operators.InterpolateF2C()\n    Ic2f = Operators.InterpolateC2F(bottom = Operators.Extrapolate(), top = Operators.Extrapolate())\n    w = If2c.(ρw) ./ Yc.ρ\n    cuv = @. Geometry.UWVector(uₕ)\n    windspeed = @. norm(cuv)\n    windspeed_boundary = Fields.level(windspeed, 1)\n    θ_boundary = Fields.level(Yc.ρθ ./ Yc.ρ, 1)\n    ρ_boundary = Fields.level(Yc.ρ, 1)\n\n    # build atmos face fields on surface boundary space to enable broadcasting\n    windspeed_boundary = Fields.Field(Fields.field_values(windspeed_boundary), axes(p.T_sfc))\n    θ_boundary = Fields.Field(Fields.field_values(θ_boundary), axes(p.T_sfc))\n    ρ_boundary = Fields.Field(Fields.field_values(ρ_boundary), axes(p.T_sfc))\n\n    λ = @. p.cpl_p.C_p * p.cpl_p.C_H * ρ_boundary * windspeed_boundary\n    dθ = @. θ_boundary - p.T_sfc\n    heat_flux = @. -λ * dθ\n    @. dY.F_sfc += heat_flux # accumulation\n\n    return Operators.SetValue(Geometry.WVector.(heat_flux))\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"couplerstate/#Coupler-State","page":"Coupler State","title":"Coupler State","text":"","category":"section"},{"location":"couplerstate/","page":"Coupler State","title":"Coupler State","text":"The coupler provides a space to store information being passed between coupled model components at their boundaries. During this exchange, the coupler manages ancillary operations such as regridding, unit conversions, filtering, etc.","category":"page"},{"location":"couplerstate/","page":"Coupler State","title":"Coupler State","text":"The ClimaCoupler defines a type CouplerState for a container variable that holds information about the field boundary values that are being used to couple components. Components can use a coupler_put! operation to  export a set of field values to a CouplerState variable. A coupler_get operation is used to retrieve a set of field values from a CplState variable. During this exchange, the coupler manages ancillary operations such as  regridding, unit conversions, or filtering.","category":"page"},{"location":"couplerstate/#Coupler-Object-API","page":"Coupler State","title":"Coupler Object API","text":"","category":"section"},{"location":"couplerstate/","page":"Coupler State","title":"Coupler State","text":"    ClimaCoupler.CouplerState\n    ClimaCoupler.coupler_add_field!\n    ClimaCoupler.coupler_add_map!\n    ClimaCoupler.coupler_push!\n    ClimaCoupler.coupler_pull!\n    ClimaCoupler.coupler_put!\n    ClimaCoupler.coupler_get\n    ClimaCoupler.coupler_get!","category":"page"},{"location":"couplerstate/#ClimaCoupler.CouplerState","page":"Coupler State","title":"ClimaCoupler.CouplerState","text":"mutable struct CouplerState{FT, CF, RO}\n\nType for holding coupled fields. \n\nThis is the namespace through which coupled components communicate. Its role is to provide a level of indirection so that components remain modular and so that any data communication, interpolation, reindexing/unit conversions and filtering  etc... can be embeded in the intermdediate coupling layer.\n\nA field is exported by one component and imported by one or more other components.\n\nFields:\n\ncoupled_fields\nA dictionary of fields added to the coupler\nremap_operators\nA dictionary of remap operators between components\nΔt_coupled\nThe coupled timestep size\n\nContructors:\n\nCouplerState(coupled_fields, remap_operators, Δt_coupled)\n\ndefined at /home/runner/work/ClimaCoupler.jl/ClimaCoupler.jl/src/CouplerState/coupler_state.jl:29.\n\nCouplerState(Δt_coupled)\n\ndefined at /home/runner/work/ClimaCoupler.jl/ClimaCoupler.jl/src/CouplerState/coupler_state.jl:42.\n\n\n\n\n\n","category":"type"},{"location":"couplerstate/#ClimaCoupler.coupler_add_field!","page":"Coupler State","title":"ClimaCoupler.coupler_add_field!","text":"coupler_add_field!(\n    coupler,\n    fieldname,\n    fieldvalue;\n    write_sim,\n    metadata\n)\n\n\nAdd a field to the coupler that is accessible with key fieldname. \n\nArguments\n\ncoupler: coupler object the field is added to.\nfieldname: key to access the field in the coupler.\nfieldvalue: data array of field values.\nwrite_sim: the simulation can write to this field in the coupler.\nmetadata: a catch-all storage for any metadata associated with the field.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#ClimaCoupler.coupler_add_map!","page":"Coupler State","title":"ClimaCoupler.coupler_add_map!","text":"coupler_add_map!(coupler, map_name, map)\n\n\nAdd a map to the coupler that is accessible with key mapname. \n\nArguments\n\ncoupler: coupler object the field is added to.\nmapname: key to access the map in the coupler's map list.\nmap: a remap operator.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#ClimaCoupler.coupler_push!","page":"Coupler State","title":"ClimaCoupler.coupler_push!","text":"coupler_push!(coupler, sim)\n\n\nUpdate coupler with fields retrieved from the coupler.\n\ncoupler_push! is an adapter function to be implemented for each model component using the coupler. It should send coupling fields via coupler_put! calls and perform any operations on these fields to prepare them for the coupler.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#ClimaCoupler.coupler_pull!","page":"Coupler State","title":"ClimaCoupler.coupler_pull!","text":"coupler_pull!(sim, coupler)\n\n\nUpdate model with fields retrieved from the coupler.\n\ncoupler_pull! is an adapter function to be implemented for each model component using the coupler. It should get coupling fields via coupler_get calls and perform any operations on these fields to prepare them for use in the component model.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#ClimaCoupler.coupler_put!","page":"Coupler State","title":"ClimaCoupler.coupler_put!","text":"coupler_put!(coupler, fieldname, fieldvalue, source_sim)\n\n\nSets coupler field fieldname to fieldvalue.\n\nArguments\n\ncoupler: coupler object the field is added to.\nfieldname:  key to access the field in the coupler.\nfieldvalue: the field being stored.\nsource_sim: the simulation that fieldvalue belongs to.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#ClimaCoupler.coupler_get","page":"Coupler State","title":"ClimaCoupler.coupler_get","text":"coupler_get(coupler, fieldname)\n\n\nRetrieve coupler field fieldname without remapping.\n\nArguments\n\ncoupler: coupler object being accessed.\nfieldname:  key to access the field in the coupler.\n\n\n\n\n\ncoupler_get(coupler, fieldname, target_sim)\n\n\nRetrieve coupler field fieldname and remap to target_sim's boundary space.\n\nArguments\n\ncoupler: coupler object being accessed.\nfieldname:  key to access the field in the coupler.\ntarget_sim: the simulation that target_field belongs to.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#ClimaCoupler.coupler_get!","page":"Coupler State","title":"ClimaCoupler.coupler_get!","text":"coupler_get!(target_field, coupler, fieldname, target_sim)\n\n\nRetrieve coupler field fieldname, remap and store in target_field.\n\nArguments\n\ntarget_field: the field to be updated by the coupler.\ncoupler: coupler object being accessed.\nfieldname:  key to access the field in the coupler.\ntarget_sim: the simulation that target_field belongs to.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaCoupler.jl","page":"Home","title":"ClimaCoupler.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Coupling CliMA Models","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ClimaCoupler","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaCoupler.jl provides a means to couple CliMA  model components. It is designed to provide a flexible way to map boundary fluxes of quantities, like moisture and heat, that leave one component model (for example the atmosphere) to boundary fluxes of another component model (for example the ocean model). Functionality includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"coupled system time stepping control that integrates fluxes in time for sharing between components with differing time steps and/or time stepping schemes.\nsupport for mapping import and export boundary information between components so that fluxes of properties transferred between components are conserved.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ClimaCoupler supports coupling components that are all within the same process or coupling components (using MPI) that are running on different processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Coupler Scheme)\nClimaCoupler.jl allows for independent development of interchangeable component models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"    ClimaCoupler","category":"page"},{"location":"#ClimaCoupler.ClimaCoupler","page":"Home","title":"ClimaCoupler.ClimaCoupler","text":"ClimaCoupler\n\nCoupling module sufficient for initial atmos-ocean-land coupled simulation.\n\n\n\n\n\n","category":"module"},{"location":"timestepping/#Simulations-and-Timestepping","page":"Simulations & Timestepping","title":"Simulations & Timestepping","text":"","category":"section"},{"location":"timestepping/#Simulations-Interface","page":"Simulations & Timestepping","title":"Simulations Interface","text":"","category":"section"},{"location":"timestepping/","page":"Simulations & Timestepping","title":"Simulations & Timestepping","text":"ClimaCoupler.jl organizes coupled models and their execution through the use of Simulations. A Simulation wraps a physical model and its time integrator; it contains all necessary information to execute a  model run. Component models subtype ClimaCoupler.AbstractSimulation so that coupling methods can be implmented and dispatch by model type. Component Simulations are collected in a CoupledSimulation along with the coupler itself. This is the full coupled modeling system. ","category":"page"},{"location":"timestepping/","page":"Simulations & Timestepping","title":"Simulations & Timestepping","text":"When coupling, component models must implement three methods:","category":"page"},{"location":"timestepping/","page":"Simulations & Timestepping","title":"Simulations & Timestepping","text":"step!: advances the component model by a specified step size\ncoupler_push!: prepares and puts coupled fields from the model   into the coupler via coupler_put! calls\ncoupler_pull!: gets coupled fields from the coupler   via coupler_get! calls and prepares them to be ingested by the model.","category":"page"},{"location":"timestepping/","page":"Simulations & Timestepping","title":"Simulations & Timestepping","text":"These methods hide each components backend implementations (for timestepping or  field access) from the coupler, allowing heterogeneity in model backends and the standardization of some coupled timestepping schemes. However, like any other simulation, a CoupledSimulation may also implement a ClimaCoupler.step! method, which in this context specifies the coupling scheme details (e.g. explicit, leap-frog, concurrent, etc...).","category":"page"},{"location":"timestepping/","page":"Simulations & Timestepping","title":"Simulations & Timestepping","text":"ClimaCoupler.AbstractSimulation\nClimaCoupler.CoupledSimulation\nClimaCoupler.run!\nClimaCoupler.step!","category":"page"},{"location":"timestepping/#ClimaCoupler.AbstractSimulation","page":"Simulations & Timestepping","title":"ClimaCoupler.AbstractSimulation","text":"abstract type AbstractSimulation\n\nAbstractSimulation\n\nAn abstract type representing a model simulation.\n\nFields:\n\nContructors:\n\n\n\n\n\n","category":"type"},{"location":"timestepping/#ClimaCoupler.CoupledSimulation","page":"Simulations & Timestepping","title":"ClimaCoupler.CoupledSimulation","text":"struct CoupledSimulation{CS, S, CPL, L, C} <: ClimaCoupler.AbstractCoupledSimulation\n\nA collection of coupled component simulations.\n\nFields:\n\ncoupler_solver\nThe coupled time-stepping scheme\nsimulations\nThe component simulations\ncoupler\nThe coupler\nlogger\nDiagnostic logger\nclock\nClock\n\nContructors:\n\nCoupledSimulation(\n    coupler_solver,\n    simulations,\n    coupler,\n    logger,\n    clock\n)\n\ndefined at /home/runner/work/ClimaCoupler.jl/ClimaCoupler.jl/src/CoupledSimulations/coupled_simulation.jl:26.\n\n\n\n\n\n","category":"type"},{"location":"timestepping/#ClimaCoupler.run!","page":"Simulations & Timestepping","title":"ClimaCoupler.run!","text":"run!(sim)\n\n\nrun!(::CoupledSimulation)\n\nA simple outer timestepping loop for coupled system runs.\n\nThis will be formalized when the run! functionality for component models is implemented so to have a consistent interface.\n\n\n\n\n\n","category":"function"},{"location":"timestepping/#ClimaCoupler.step!","page":"Simulations & Timestepping","title":"ClimaCoupler.step!","text":"step!(sim, dt)\n\n\nstep!(sim, dt)\n\nAdvances a simulation by dt.\n\nNote that dt is not necessarily the simulation's timestep length; a simuation could take several shorter steps that total to dt.\n\n\n\n\n\n","category":"function"},{"location":"generated/sea_breeze/land_rhs/#Land-Model","page":"Land Model","title":"Land Model","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/#Slab-Land-ODE","page":"Land Model","title":"Slab Land ODE","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"For our land component, we solve a simple slab land ODE:","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"rho_l c_l H_l partial_t T_lnd = - F_integ  Delta t_coupler","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"where rho_l = 1500 kg m ^-3, c_l=800 J K ^-1 kg ^-1, H_l=1 m are the density, specific heat and depth of the land slab,\nand F_integ is the integrated surface fluxes in time.","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Model-Code","page":"Land Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"function lnd_rhs!(du, u, (parameters, F_accumulated), t)\n    \"\"\"\n    Slab layer equation\n        d(T_lnd)/dt = - (F_accumulated + G) / (h_lnd * ρ_lnd * c_lnd)\n        where\n            F_accumulated = F_integrated / Δt_coupler\n    \"\"\"\n    @unpack lnd_h, lnd_ρ, lnd_c = parameters\n    @unpack T_sfc = du\n\n    @. T_sfc = (-F_accumulated) / (lnd_h * lnd_ρ * lnd_c)\nend\n\n# set up domain\nfunction hspace_1D(xlim = (-π, π), npoly = 0, helem = 10)\n    FT = Float64\n\n    domain = Domains.IntervalDomain(Geometry.XPoint{FT}(xlim[1]) .. Geometry.XPoint{FT}(xlim[2]), periodic = true)\n    mesh = Meshes.IntervalMesh(domain; nelems = helem)\n    topology = Topologies.IntervalTopology(mesh)\n\n    # Finite Volume Approximation: Gauss-Lobatto with 1pt per element\n    quad = Spaces.Quadratures.GL{npoly + 1}()\n    space = Spaces.SpectralElementSpace1D(topology, quad)\n\n    return space\nend\n\n# init simulation\nfunction lnd_init(; xmin = -1000, xmax = 1000, helem = 20, npoly = 0)\n\n    # construct domain spaces - get only surface layer (NB: z should be zero, not z = first central height)\n    space = hspace_1D((xmin, xmax), npoly, helem)\n    coords = Fields.coordinate_field(space)\n    domain = space\n\n    # initial condition\n    T_sfc = map(coords) do coord\n        T_sfc = 273.0\n    end\n\n    # prognostic variable\n    Y = Fields.FieldVector(T_sfc = T_sfc)\n\n    return Y, domain\nend","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Coupled-Land-Wrappers","page":"Land Model","title":"Coupled Land Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"# Land Simulation - later to live in ClimaLSM\nstruct LandSimulation <: ClimaCoupler.AbstractLandSimulation\n    integrator::Any\nend\n\nfunction LandSimulation(Y_init, t_start, dt, t_end, timestepper, p, saveat, callbacks = CallbackSet())\n    lnd_prob = ODEProblem(lnd_rhs!, Y_init, (t_start, t_end), p)\n    lnd_integ = init(lnd_prob, timestepper, dt = dt, saveat = saveat, callback = callbacks)\n    return LandSimulation(lnd_integ)\nend\n\nfunction ClimaCoupler.coupler_push!(coupler::ClimaCoupler.CouplerState, land::LandSimulation)\n    coupler_put!(coupler, :T_sfc_land, land.integrator.u.T_sfc, land)\nend\n\nfunction ClimaCoupler.coupler_pull!(land::LandSimulation, coupler::ClimaCoupler.CouplerState)\n    coupler_get!(land.integrator.p.F_sfc, coupler, :F_sfc, land)\n    land.integrator.p.F_sfc ./= coupler.Δt_coupled\nend","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"This page was generated using Literate.jl.","category":"page"}]
}
