var documenterSearchIndex = {"docs":
[{"location":"checkpointer/#Checkpointer","page":"Checkpointer","title":"Checkpointer","text":"","category":"section"},{"location":"checkpointer/#How-to-save-and-restart-from-checkpoints","page":"Checkpointer","title":"How to save and restart from checkpoints","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"ClimaCoupler supports saving and reading simulation checkpoints. This is useful to split a long simulation into smaller, more manageable chunks.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Checkpoints are a mix of HDF5 and JLD2 files and are typically saved in a checkpoints folder in the simulation output. See Utilities.setup_output_dirs for more information.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"warning: Known limitations\nThe number of MPI processes has to remain the same across checkpoints\nRestart files are generally not portable across machines, julia versions, and package versions\nAdding/changing new component models will probably require adding/changing code","category":"page"},{"location":"checkpointer/#Saving-checkpoints","page":"Checkpointer","title":"Saving checkpoints","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"If you are running a model (such as AMIP), chances are that you can enable checkpointing just by setting a command-line argument; The checkpoint_dt option controls how frequently a checkpoint should be produced.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"If your model does not come with this option already, you can checkpoint the simulation by adding a callback that calls the Checkpointer.checkpoint_sims function.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"For example, to add a callback to checkpoint every hour of simulated time, assuming you have a start_date","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"import Dates\n\nimport ClimaCoupler: Checkpointer, TimeManager\nimport ClimaDiagnostics.Schedules: EveryCalendarDtSchedule\n\nschedule = EveryCalendarDtSchedule(Dates.Hour(1); start_date)\ncheckpoint_callback = TimeManager.Callback(schedule_checkpoint, Checkpointer.checkpoint_sims)\n\n# In the coupling loop:\nTimeManager.maybe_trigger_callback(checkpoint_callback, coupled_simulation, time)","category":"page"},{"location":"checkpointer/#Reading-checkpoints","page":"Checkpointer","title":"Reading checkpoints","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"There are two ways to restart a simulation from checkpoints. By default, ClimaCoupler tries finding suitable checkpoints and automatically use them. Alternatively, you can specify a directory restart_dir and a simulation time restart_t and restart from files saved in the given directory at the given time. If the model you are running supports writing checkpoints via command-line argument, it will probably also support reading them. In this case, the arguments restart_dir and restart_t identify the path of the top level directory containing all the checkpoint files and the simulated times in second.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"If the model does not support directly reading a checkpoint, the Checkpointer module provides a straightforward way to add this feature. Checkpointer.restart! takes a coupled simulation, a restart_dir, and a restart_t and overwrites the content of the coupled simulation with what is in the checkpoint.","category":"page"},{"location":"checkpointer/#Developer-notes","page":"Checkpointer","title":"Developer notes","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"In theory, the state of the component models should fully determine the state of the coupled simulation and one should be able to restart a coupled simulation just by using the states of the component models. Unfortunately, this is currently not the case in ClimaCoupler. The main reason for this is the complex interdependencies between component models and within ClimaAtmos which make the initialization step inconsistent. For example, in a coupled simulation, the surface albedo should be determined by the surface models and used by the atmospheric model for radiation transfer, but ClimaAtmos also tries to set the surface albedo (since it has to do so when run in standalone mode). In addition to this, ClimaAtmos has a large cache that has internal interdependencies that are hard to disentangle, and changing a field might require changing some other field in a different part of the cache. As a result, it is not easy for ClimaCoupler to consistently do initialization from a cold state. To conclude, restarting a simulation exclusively using the states of the component models is currently impossible.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Given that restarting a simulation from the state is impossible, ClimaCoupler needs to save the states and the caches. Let us review how we use ClimaCore.InputOutput and JLD2 package to accomplish this.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"ClimaCore.InputOutput provides a loss-less way to save the content of certain ClimaCore objects to HDF5 files. Objects saved in this way are not tied to a particular computing device or configuration. When running with MPI, ClimaCore.InputOutput are also efficiently written in parallel.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Unfortunately, ClimaCore.InputOutput only supports certain objects, such as Fields and Spaces, but the cache in component models is more complex than this and contains complex objects with highly stateful quantities (e.g., C pointers). Because of this, model states are saved to HDF5 but caches must be saved to JLD2 files.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"JLD2 allows us to save more complex objects without writing specific serialization methods for every struct. JLD2 allows us to take a big step forward, but there are still several challenges that need to be solved:","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"JLD2 does not support CUDA natively. To go around this, we have to move everything onto the CPU first. Then, when the data is read back, we have to move it back to the GPU.\nJLD2 does not support MPI natively. To go around this, each process writes its jld2 checkpoint and reads it back. This introduces the constraint that the number of MPI processes cannot change across restarts.\nSome quantities are best not saved and read (for example, anything with pointers). For this, we write a recursive function that traverses the cache and only restores quantities of a certain type (typically, ClimaCore objects)","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Point 3. adds significant amount of code and requires component models to specify how their cache has to be restored.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"If you are adding a component model, you have to extend the methods.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Checkpointer.get_model_prog_state\nCheckpointer.get_model_cache\nCheckpointer.restore_cache!","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"ClimaCoupler moves objects to the CPU with Adapt(Array, x). Adapt traverses the object recursively, and proper Adapt methods have to be defined for every object involved in the chain. The easiest way to do this is using the Adapt.@adapt_structure macro, which defines a recursive Adapt for the given object.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Types to watch for:","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"MPI related objects (e.g., MPICommsContext)\nTimeVaryingInputs (because they contain NCDatasets, which contain pointers to files)","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"warning: Adapt and references\nFor objects that contain multiple fields referencing the same object, using the Adapt.@adapt_structure macro leads to unnecessary copies of the same object. This happens because Adapt.@adapt_structure defines a recursive Adapt that does not account for the possibility that multiple fields could be referencing the same object. As a result, this means that the same object is recreated over and over again when calling Adapt on the cache. This can easily make the file size of the saved cache much bigger than it needs to be. Because of this, we've implemented a CacheIterator object - please see the section below for details.","category":"page"},{"location":"checkpointer/#CacheIterator","page":"Checkpointer","title":"CacheIterator","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Instead of defining a proper Adapt method for the cache, an alternative approach is to recursively iterate over the cache fields and selectively save only the parts that need to be saved. This recursive iteration is performed by the CacheIterator. To initialize a CacheIterator for a component model, you must implement get_cache_ignore.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Using the CacheIterator allows adapt to be called on each individual field instead of on the entire cache. Furthermore, the file size can be reduced by avoiding duplicate saves of fields that reference the same memory. This is accomplished by tracking object IDs and storing references to objects instead of creating copies when the same object is encountered multiple times.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"This approach allows for a signficant reducation in the file size of the cache.","category":"page"},{"location":"checkpointer/#Checkpointer-API","page":"Checkpointer","title":"Checkpointer API","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"    Checkpointer.get_model_prog_state\n    Checkpointer.get_model_cache\n    Checkpointer.get_model_cache_to_checkpoint\n    Checkpointer.restart!\n    Checkpointer.checkpoint_sims\n    Checkpointer.t_start_from_checkpoint\n    Checkpointer.restore!","category":"page"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.get_model_prog_state","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.get_model_prog_state","text":"Checkpointer.get_model_prog_state(sim::ClimaAtmosSimulation)\n\nExtension of Checkpointer.getmodelprog_state to get the model state.\n\n\n\n\n\nCheckpointer.get_model_prog_state(sim::BucketSimulation)\n\nExtension of Checkpointer.getmodelprog_state to get the model state.\n\n\n\n\n\nget_model_prog_state(sim::Interfacer.AbstractComponentSimulation)\n\nReturns the model state of a simulation as a ClimaCore.FieldVector. This is a template function that should be implemented for each component model.\n\n\n\n\n\nget_model_prog_state(sim::OceananigansSimulation)\n\nReturns the model state of a simulation as a ClimaCore.FieldVector. It's okay to leave this unimplemented for now, but we won't be able to use the restart system.\n\nTODO extend this for non-ClimaCore states.\n\n\n\n\n\nget_model_prog_state(sim::ClimaSeaIceSimulation)\n\nReturns the model state of a simulation as a ClimaCore.FieldVector. It's okay to leave this unimplemented for now, but we won't be able to use the restart system.\n\nTODO extend this for non-ClimaCore states.\n\n\n\n\n\nCheckpointer.get_model_prog_state(sim::SlabOceanSimulation)\n\nExtension of Checkpointer.getmodelprog_state to get the model state.\n\n\n\n\n\nCheckpointer.get_model_prog_state(sim::PrescribedIceSimulation)\n\nExtension of Checkpointer.getmodelprog_state to get the model state.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.get_model_cache","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.get_model_cache","text":"get_model_cache(sim::Interfacer.AbstractComponentSimulation)\n\nReturns the model cache of a simulation. This is a template function that should be implemented for each component model.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.get_model_cache_to_checkpoint","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.get_model_cache_to_checkpoint","text":"get_model_cache_to_checkpoint(sim::Interfacer.AbstractComponentSimulation)\n\nPrepare the cache for checkpointing by moving the entire cache to CPU.\n\n\n\n\n\nget_model_cache_to_checkpoint(sim::Interfacer.AbstractAtmosSimulation)\n\nPrepare the atmos cache for checkpoint by selectively moving parts of the atmos cache to CPU instead of moving the entire atmos cache to CPU, resulting in a much smaller saved file.\n\nImplementation Details\n\nWhen moving the cache from GPU to CPU, calling adapt on the entire cache creates unnecessary duplicate objects because adapt is not properly defined for the entire cache structure. This function addresses three key issues:\n\nIndividual adaptation: On GPU, adapt is called on each object separately rather than on the entire cache at once.\nDeduplication: Objects sharing the same object ID are not duplicated. Instead, references to already-processed objects are reused.\nSelective saving: Only the parts of the cache needed for restoration are saved.\nRecreated views: Views are preserved by recreating the views with the parent arrays on CPU. Otherwise, the arrays are unnecessarily duplicated when adapt is called since checks using objectid fail for views, resulting in a larger saved cache on GPU.\n\nReturns\n\nA vector of objects from the cache. Elements may reference the same underlying data if they share object IDs. The order of the objects in the vector is determined by CacheIterator.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.restart!","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.restart!","text":"restart!(cs::CoupledSimulation, checkpoint_dir, checkpoint_t, restart_cache)\n\nOverwrite the content of cs with checkpoints in checkpoint_dir at time checkpoint_t.\n\nIf restart_cache is true, the cache will be read from the restart file using restore_cache!. Otherwise, the cache will be left unchanged.\n\nReturn a true if the simulation was restarted.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.checkpoint_sims","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.checkpoint_sims","text":"checkpoint_sims(cs::CoupledSimulation)\n\nThis is a callback function that checkpoints all simulations defined in the current coupled simulation.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.t_start_from_checkpoint","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.t_start_from_checkpoint","text":"t_start_from_checkpoint(checkpoint_dir)\n\nLook for restart files in checkpoint_dir, if found, return the time of the latest. If not found, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.restore!","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.restore!","text":"restore!(v1, v2, comms_ctx; name = \"\", ignore = Set())\n\nRecursively traverse v1 and v2, setting each field of v1 with the corresponding field in v2. In this, ignore all the properties that have name within the ignore iterable.\n\nThis is intended to be used when restarting a simulation's cache object from a checkpoint.\n\nignore is useful when there are stateful properties, such as live pointers.\n\n\n\n\n\nrestore!(\n    v1::Union{\n        AbstractTimeVaryingInput,\n        ClimaComms.AbstractCommsContext,\n        ClimaComms.AbstractDevice,\n        UnionAll,\n        DataType,\n    },\n    v2::Union{\n        AbstractTimeVaryingInput,\n        ClimaComms.AbstractCommsContext,\n        ClimaComms.AbstractDevice,\n        UnionAll,\n        DataType,\n    },\n    _comms_ctx;\n    name = \"\",\n    ignore = Set(),\n)\n\nIgnore certain types that don't need to be restored. UnionAll and DataType are infinitely recursive, so we also ignore those.\n\n\n\n\n\nrestore!(\n    v1::Union{CC.DataLayouts.AbstractData, AbstractArray},\n    v2::Union{CC.DataLayouts.AbstractData, AbstractArray},\n    comms_ctx;\n    name = \"\",\n    ignore = Set(),\n)\n\nFor array-like objects, we move the original data (v2) to the device of the new data (v1). Then we copy the original data to the new object.\n\n\n\n\n\nrestore!(v1::LinearIndices, v2::AbstractArray, comms_ctx; name = \"\", ignore = Set())\n\nSpecial case to compare LinearIndices to AbstractArray, which is needed for ClimaAtmos v0.32.\n\n\n\n\n\nrestore!(\n    v1::Union{StaticArrays.StaticArray, Number, UnitRange, LinRange, Symbol},\n    v2::Union{StaticArrays.StaticArray, Number, UnitRange, LinRange, Symbol},\n    comms_ctx;\n    name = \"\",\n    ignore = Set(),\n)\n\nEnsure that immutable objects have been initialized correctly, as they cannot be restored from a checkpoint.\n\n\n\n\n\nrestore!(v1::Dict, v2::Dict, comms_ctx; name = \"\", ignore = Set())\n\nRRTMGP has some internal dictionaries, which we check for consistency.\n\n\n\n\n\nrestore!(\n    v1::T1,\n    v2::T2,\n    comms_ctx;\n    name = \"\",\n    ignore = Set(),\n) where {\n    T1 <: Union{Dates.DateTime, Dates.UTInstant, Dates.Millisecond},\n    T2 <: Union{Dates.DateTime, Dates.UTInstant, Dates.Millisecond},\n}\n\nSpecial case to compare time-related types to allow different timestamps during restore.\n\n\n\n\n\n","category":"function"},{"location":"simcoordinator/#SimCoordinator","page":"SimCoordinator","title":"SimCoordinator","text":"","category":"section"},{"location":"simcoordinator/","page":"SimCoordinator","title":"SimCoordinator","text":"This module contains functions for coordinating the execution of coupled simulations, including stepping through time and running full simulations. The SimCoordinator module provides the main control flow for advancing coupled simulations forward in time.","category":"page"},{"location":"simcoordinator/#Overview","page":"SimCoordinator","title":"Overview","text":"","category":"section"},{"location":"simcoordinator/","page":"SimCoordinator","title":"SimCoordinator","text":"The SimCoordinator module provides two key functions for running coupled simulations:","category":"page"},{"location":"simcoordinator/","page":"SimCoordinator","title":"SimCoordinator","text":"step!: Advances the simulation by one coupling timestep, coordinating all component models and field exchanges.\nrun!: Executes the full simulation from start to finish, handling precompilation, timing, and cleanup.","category":"page"},{"location":"simcoordinator/","page":"SimCoordinator","title":"SimCoordinator","text":"These functions orchestrate the interaction between component models (atmosphere, land, ocean, sea ice) through the coupler, ensuring proper field exchanges, flux calculations, and conservation checks at each timestep.","category":"page"},{"location":"simcoordinator/#SimCoordinator-API","page":"SimCoordinator","title":"SimCoordinator API","text":"","category":"section"},{"location":"simcoordinator/","page":"SimCoordinator","title":"SimCoordinator","text":"SimCoordinator.run!\nSimCoordinator.step!","category":"page"},{"location":"simcoordinator/#ClimaCoupler.SimCoordinator.run!","page":"SimCoordinator","title":"ClimaCoupler.SimCoordinator.run!","text":"run!(cs::CoupledSimulation)\n\nEvolve the given simulation, producing plots and other diagnostic information.\n\nKeyword arguments\n\nprecompile: If true, run the coupled simulations for two steps, so that most functions               are precompiled and subsequent timing will be more accurate.\n\n\n\n\n\n","category":"function"},{"location":"simcoordinator/#ClimaCoupler.SimCoordinator.step!","page":"SimCoordinator","title":"ClimaCoupler.SimCoordinator.step!","text":"step!(cs::CoupledSimulation)\n\nTake one coupling step forward in time.\n\nThis function runs the component models sequentially, and exchanges combined fields and calculates fluxes using the selected turbulent fluxes option. Note, one coupling step might require multiple steps in some of the component models.\n\n\n\n\n\n","category":"function"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Thank you for contributing to ClimaCoupler! We encourage Pull Requests (PRs). Please do not hesitate to ask questions, or to open issues if something seems amiss or you'd like a new feature.","category":"page"},{"location":"contributing/#Some-useful-tips","page":"Contributing","title":"Some useful tips","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"When developing code it's best to work on a branch off of the most recent main.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This can be done by running the following commands, where \"initials\" corresponds to the first and last initial of the person starting the branch.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"git checkout main\ngit pull\ngit checkout -b initials/branch_name","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Make sure you add tests for your code in test/, appropriate documentation in docs/, and descriptive inline comments throughout the code. All exported functions and structs must have docstrings.\nWhen your PR is ready for review, clean up your commit history by squashing to 1 commit per PR and make sure your code is current with the main branch by rebasing.","category":"page"},{"location":"contributing/#Continuous-integration","page":"Contributing","title":"Continuous integration","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"After rebasing your branch, you can ask for review. Fill out the template and provide a clear summary of what your PR does. When a PR is created or updated, a set of automated tests are run on the PR in our continuous integration (CI) system.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"ClimaCoupler.jl's continuous integration contains both unit tests and integration tests (coupled simulations).","category":"page"},{"location":"contributing/#Formatting-check","page":"Contributing","title":"Formatting check","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The JuliaFormatter test checks if the PR is correctly formatted according to the project's style guidelines. The previous .dev/climaformat.jl script has been discontinued in favor of using the JuliaFormatter package directly.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To format your code, first add JuliaFormatter to your base environment:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"julia -e 'using Pkg; Pkg.add(PackageSpec(\"JuliaFormatter\", v\"1.0.62\"))'","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Then, in a Julia REPL, run:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using JuliaFormatter; format(\".\")","category":"page"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The Documentation test rebuilds the documentation for the PR and checks if the docs are consistent and generate valid output.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To add internal references, for example to another documentation page or API, see the relevant Documenter.jl @ref documentation page, example syntax: [see contributor guide](@ref \"Contributing\") for a page or [CoupledSimulation object and constructors](@ref ClimaCoupler.Interfacer.CoupledSimulation) for an API.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To add external references, for example to another package documentation page or API, see the documentation of DocumenterInterLinks. Example syntax: [how to us @ref](@extref Documenter Named-@refs).","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To add a reference from the literature, see the documentation of DocumenterCitations.jl, in short, add your reference to docs/src/refs.bib and then refer to it with this syntax [authors1999](@citet).","category":"page"},{"location":"fieldexchanger/#FieldExchanger","page":"FieldExchanger","title":"FieldExchanger","text":"","category":"section"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"This module contains general functions for the exchange of fields between the atmospheric and surface component models.","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"The main function of the FieldExchanger is exchange!, which does the following:","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"imports atmospheric fields into the coupler fields, via import_atmos_fields!\nimports area fraction-weighted surface fields into the coupler fields, via import_combined_surface_fields!\nupdates all component models with the newly-updated coupler fields, via update_model_sims!","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"The specific fields that are exchanged depend on the requirements of the component models:","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"The fields imported from the atmosphere to the coupler are specified by extending FieldExchanger.import_atmos_fields! The default import_atmos_fields! imports radiative fluxes, liquid precipitation, and snow precipitation.","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"The fields of a component model that get updated by the coupler are specified by extending FieldExchanger.update_sim!. The default update_sim! for an atmosphere model updates the direct and diffuse surface albedos, the surface temperature, and the turbulent fluxes. The default update_sim! for a surface model updates the air density, radiative fluxes, liquid precipitation, and snow precipitation. These updates are done via the update_field! function, which must be extended for the particular variable and component model. If an update_field! function is not defined for a particular component model, it will be ignored.","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"Note that turbulent fluxes are not updated in update_sim!, but rather via FluxCalculator.update_turbulent_fluxes!, where fluxes are computed between the atmosphere and each surface model.","category":"page"},{"location":"fieldexchanger/#FieldExchanger-API","page":"FieldExchanger","title":"FieldExchanger API","text":"","category":"section"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"    FieldExchanger.exchange!\n    FieldExchanger.update_sim!\n    FieldExchanger.step_model_sims!\n    FieldExchanger.update_surface_fractions!\n    FieldExchanger.set_caches!","category":"page"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.exchange!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.exchange!","text":"exchange!(cs::Interfacer.CoupledSimulation)\n\nExchange fields between the surface and atmosphere models. This is done in 2 steps:\n\nImport the atmosphere fields and surface fields into the coupler.\nUpdate the component model simulations with the coupler fields.\n\nThe order of these steps is important, as importing the surface fields requires the atmosphere fields to be updated so that surface humidity can be computed.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.update_sim!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.update_sim!","text":"update_sim!(sim::BucketSimulation, csf)\n\nUpdates the surface component model cache with the current coupler fields besides turbulent fluxes.\n\nArguments\n\nsim: [Interfacer.AbstractSurfaceSimulation] containing a surface model simulation object.\ncsf: [NamedTuple] containing coupler fields.\n\n\n\n\n\nFieldExchanger.update_sim!(sim::OceananigansSimulation, csf)\n\nUpdate the ocean simulation with the provided fields, which have been filled in by the coupler.\n\nUpdate the portion of the surfacefluxes for T and S that is due to radiation and precipitation. The rest will be updated in `updateturbulent_fluxes!`.\n\nThis function sets the surface fluxes directly, overwriting any previous values. Additional contributions will be made in update_turbulent_fluxes! and ocean_seaice_fluxes!.\n\nA note on sign conventions: ClimaAtmos and Oceananigans both use the convention that a positive flux is an upward flux. No sign change is needed during the exchange, except for precipitation/salinity fluxes. ClimaAtmos provides precipitation as a negative flux at the surface, and Oceananigans represents precipitation as a positive salinity flux, so a sign change is needed when we convert from precipitation to salinity flux.\n\n\n\n\n\nFieldExchanger.update_sim!(sim::ClimaSeaIceSimulation, csf)\n\nUpdate the sea ice simulation with the provided fields, which have been filled in by the coupler.\n\nUpdate the portion of the surfacefluxes for T and S that is due to radiation and precipitation. The rest will be updated in `updateturbulent_fluxes!`.\n\nNote that currently precipitation has no effect on the sea ice model, which has constant salinity.\n\nA note on sign conventions: ClimaAtmos and ClimaSeaIce both use the convention that a positive flux is an upward flux. No sign change is needed during the exchange, except for precipitation/salinity fluxes. ClimaAtmos provides precipitation as a negative flux at the surface, and ClimaSeaIce represents precipitation as a positive salinity flux, so a sign change is needed when we convert from precipitation to salinity flux.\n\n\n\n\n\nupdate_sim!(atmos_sim::Interfacer.AbstractAtmosSimulation, csf)\n\nUpdates the atmosphere's fields for surface direct and diffuse albedos, emissivity,and temperature.\n\nArguments\n\natmos_sim: [Interfacer.AbstractAtmosSimulation] containing an atmospheric model simulation object.\ncsf: [NamedTuple] containing coupler fields.\n\n\n\n\n\nupdate_sim!(sim::AbstractSurfaceSimulation, csf)\n\nUpdates the surface component model cache with the current coupler fields besides turbulent fluxes, which are updated in update_turbulent_fluxes.\n\nNote that upwelling longwave and shortwave radiation are not computed here, and are expected to be computed internally by the surface model. Some component models extend this function and compute the upwelling longwave and shortwave radiation in their methods of update_sim!.\n\nArguments\n\nsim: [Interfacer.AbstractSurfaceSimulation] containing a surface model simulation object.\ncsf: [NamedTuple] containing coupler fields.\n\n\n\n\n\nFieldExchanger.update_sim!(::PrescribedOceanSimulation, csf)\n\nUpdate the wind velocity (needed for the turbulent flux calculation) and the direct and diffuse albedos of the ocean.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.step_model_sims!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.step_model_sims!","text":"step_model_sims!(model_sims, t, coupler_fields, thermo_params)\nstep_model_sims!(cs::CoupledSimulation)\n\nIterates step! over all component model simulations saved in cs.model_sims.\n\nArguments\n\nmodel_sims: [NamedTuple] containing AbstractComponentSimulations.\nt: [AbstractFloat or ITime] denoting the simulation time.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.update_surface_fractions!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.update_surface_fractions!","text":"update_surface_fractions!(cs::Interfacer.CoupledSimulation)\n\nUpdates dynamically changing area fractions. Maintains the invariant that the sum of area fractions is 1 at all points. Area fractions are expected to be defined on the boundary space of the coupled simulation, since they are used by the coupler.\n\nIf a surface model is not present, the area fraction is set to 0.\n\nArguments\n\ncs: [Interfacer.CoupledSimulation] containing area fraction information.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.set_caches!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.set_caches!","text":"set_caches!(cs::Interfacer.CoupledSimulation)\n\nPerform any initialization of the component model caches that cannot be done before the initial exchange. This is useful in handling cache interdependencies between component models.\n\nFor example, the radiation callback in the atmosphere model needs to be initialized with the surface temperatures, which are only available after the initial exchange. The integrated land, in turn, requires its drivers in the cache to be filled with the initial radiation fluxes, so that it can propagate these to the rest of its cache (e.g. in canopy radative transfer).\n\nThis function can also be used to set exchanged fields that are static over the simulation, since it is only called at initialization.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#FieldExchanger-Internal-Functions","page":"FieldExchanger","title":"FieldExchanger Internal Functions","text":"","category":"section"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"    FieldExchanger.combine_surfaces!\n    FieldExchanger.resolve_area_fractions!\n    FieldExchanger.import_atmos_fields!","category":"page"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.combine_surfaces!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.combine_surfaces!","text":"combine_surfaces!(csf, sims, field_name_val::Val{field_name}) where {field_name}\n\nSums the surface fields specified by field_name_val, weighted by the respective area fractions of all surface simulations. The result is saved in the coupler field specified by field_name_val.\n\nFor surface temperature, upward longwave radiation is computed from the temperatures of each surface, weighted by their area fractions, and then the combined temperature is computed from the combined upward longwave radiation.\n\nArguments\n\ncsf: [NamedTuple] containing coupler fields.   Note: For the surface temperature, all coupler fields are passed in a NamedTuple.\nsims: [NamedTuple] containing simulations.\nfield_name_val: [Val] containing the name Symbol of the field to be extracted by the Interfacer.get_field functions.\n\nExample\n\ncombine_surfaces!(temp_field, cs.model_sims, Val(:emissivity))\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.resolve_area_fractions!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.resolve_area_fractions!","text":"FieldExchanger.resolve_area_fractions!(ocean_sim, ice_sim, land_fraction)\n\nEnsure the ocean and ice area fractions are consistent with each other. This matters in the case of a LatitudeLongitudeGrid, which is only defined between -80 and 80 degrees latitude. In this case, we set the ice and ocean area fractions to 0 and the land fraction to 1 on [78°S, 90°S] and on [78°N, 90°N]. Note the overlap between 78° and 80° to avoid any gaps introduced by the cubed sphere not aligning with latitude lines.\n\nThis function also updates the ice concentration field in the ocean simulation so that it can be used for weighting flux updates.\n\n\n\n\n\nresolve_area_fractions!(ocean_sim, ice_sim, land_fraction)\n\nEnsure that the ocean and ice fractions are consistent with each other. For most ocean and ice models, this does nothing since the ocean fraction is defined as 1 - ice_fraction - land_fraction. However, some models may have additional constraints on the ice and ocean fractions that need to be enforced. This function can be extended for such models.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.import_atmos_fields!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.import_atmos_fields!","text":"FieldExchanger.importatmosfields!(csf, sim::BucketSimulation, atmos_sim)\n\nImport non-default coupler fields from the atmosphere simulation into the coupler fields. These include the diffuse fraction of light, shortwave and longwave downwelling radiation, air pressure, and CO2 concentration.\n\nThe default coupler fields will be imported by the default method implemented in FieldExchanger.jl.\n\n\n\n\n\nFieldExchanger.importatmosfields!(csf, sim::ClimaLandSimulation, atmos_sim)\n\nImport non-default coupler fields from the atmosphere simulation into the coupler fields. These include the diffuse fraction of light, shortwave and longwave downwelling radiation, air pressure, and CO2 concentration.\n\nThe default coupler fields will be imported by the default method implemented in FieldExchanger.jl.\n\n\n\n\n\nimport_atmos_fields!(csf, model_sims)\n\nUpdate the coupler with quantities from the  atmosphere model. By default, this updates the coupler fields for quantities required for turbulent flux calculations, radiative fluxes, and precipitation. This function should be extended for any model that requires additional fields from the atmosphere.\n\nArguments\n\ncsf: [NamedTuple] containing coupler fields.\nmodel_sims: [NamedTuple] containing AbstractComponentSimulations.\n\n\n\n\n\nimport_atmos_fields!(csf, ::Interfacer.AbstractComponentSimulation, atmos_sim)\n\nUpdates the coupler simulation fields with atmospheric fluxes from the atmosphere simulation. This function should be extended for any surface model that requires additional fields from the atmosphere. Any fields added in a method of this function should also be added in the corresponding method of Interfacer.add_coupler_fields!. The combination of these two functions defines any extra atmosphere fields provided to the surface.\n\n\n\n\n\nFieldExchanger.import_atmos_fields!(csf, sim::PrescribedOceanSimulation, atmos_sim)\n\nImport wind from atmos.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"This module contains functions, objects, and constants used by various modules in the coupler.","category":"page"},{"location":"utilities/#Utilities-API","page":"Utilities","title":"Utilities API","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Utilities.get_comms_context\nUtilities.get_device\nUtilities.show_memory_usage\nUtilities.setup_output_dirs\nUtilities.time_to_seconds","category":"page"},{"location":"utilities/#ClimaCoupler.Utilities.get_comms_context","page":"Utilities","title":"ClimaCoupler.Utilities.get_comms_context","text":"get_comms_context(config_dict)\n\nSets up the appropriate ClimaComms context for the device the model is to be run on, choosing from the following options:     - CPU single threaded     - CPU with MPI     - GPU\n\nIf no device is passed to ClimaComms.context() then ClimaComms automatically selects the device from which this code is called.\n\nArguments\n\nconfig_dict: dictionary containing a \"device\" flag which decides which device context is needed\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ClimaCoupler.Utilities.get_device","page":"Utilities","title":"ClimaCoupler.Utilities.get_device","text":"get_device(config_dict)\n\nReturns the device on which the model is being run\n\nArguments\n\nconfig_dict: dictionary containing a \"device\" flag which decides which device to run on\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ClimaCoupler.Utilities.show_memory_usage","page":"Utilities","title":"ClimaCoupler.Utilities.show_memory_usage","text":"show_memory_usage()\n\nDisplay and return the maximum resident set size (RSS) memory footprint on the CPU of this process since it began.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ClimaCoupler.Utilities.setup_output_dirs","page":"Utilities","title":"ClimaCoupler.Utilities.setup_output_dirs","text":"setup_output_dirs(output_dir_root = pwd(),\n    artifacts_dir = joinpath(output_dir, \"artifacts\"),\n    checkpoints_dir = joinpath(output_dir, \"checkpoints\"),\n    regrid_dir = nothing,\n    comms_ctx,\n)\n\nCreate output directories for the experiment. If comms_ctx is provided, only the root process will create the directories. By default, the artifacts and checkpoints directories are created inside the root output directory with the names artifacts/ and checkpoints/. The regrid directory is by default created as a temporary directory inside the root output directory and is automatically deleted when the process exits.\n\nClimaUtilities.OutputPathGenerator is used so that simulations can be re-run and re-started. The output path looks like:\n\ncoupler_output_dir_amip/\n├── checkpoints\n│       └── checkpoints for the various models\n├── artifacts\n│       └── plots produced by the postporcessing step\n├── regrid_tmp_<random_tempdir>/\n│       └── temporary files used for regridding\n├── output_0000/\n│   ├── atmos/\n│   │   └── output of the atmos model\n│   └── ocean/\n│       └── output of the ocean model\n├── output_0001/\n│   └── ... component model outputs in their folders ...\n├── output_0002/\n│   └── ... component model outputs in their folders ...\n└── output_active -> output_0002/\n\nArguments\n\noutput_dir::String: The directory where the output files will be stored.       Default is the current directory.\nartifacts_dir::String: The directory where plots (from postprocessing and conservation checks) will be stored.       Default is output_dir/artifacts/.\ncheckpoint_dir::String: The directory where the checkpoint files will be stored.       Default is output_dir/checkpoints/.\nregrid_dir::String: The directory where the regridded files will be stored.       Default is output_dir/regrid_tmp_<random_tempdir>/.\ncomms_ctx::Union{Nothing, ClimaComms.AbstractCommsContext}: The communicator context.       If provided, only the root process will create the directories.\n\nReturns\n\nA NamedTuple with the paths to output directories for each component and the coupler,\n\nas well as paths toartifacts, regrid, and checkpoints directories.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ClimaCoupler.Utilities.time_to_seconds","page":"Utilities","title":"ClimaCoupler.Utilities.time_to_seconds","text":"time_to_seconds(s::String)\n\nConvert a string to seconds. The string should be in the format numberunit, where unit is one of secs, mins, hours, or days.\n\nArguments\n\ns::String: The string to convert to seconds.\n\nReturns\n\nThe number of seconds represented by the string.\n\n\n\n\n\n","category":"function"},{"location":"generated/sea_breeze/land_rhs/#Land-Model","page":"Land Model","title":"Land Model","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"import DiffEqCallbacks\nimport SciMLBase\nimport ClimaCore as CC\nimport ClimaTimeSteppers as CTS","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"Load coupled simulation code","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"include(\"../CoupledSims/coupled_sim.jl\")","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Slab-Land-ODE","page":"Land Model","title":"Slab Land ODE","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"For our land component, we solve a simple slab land ODE:","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"rho_l c_l H_l partial_t T_lnd = - F_integ  Delta t_coupler","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"where rho_l = 1500 kg m ^-3, c_l=800 J K ^-1 kg ^-1, H_l=1 m are the density, specific heat and depth of the land slab,\nand F_integ is the integrated surface fluxes in time.","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Model-Code","page":"Land Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"function lnd_rhs!(du, u, (parameters, F_accumulated), t)\n    \"\"\"\n    Slab layer equation\n        d(T_lnd)/dt = - (F_accumulated + G) / (h_lnd * ρ_lnd * c_lnd)\n        where\n            F_accumulated = F_integrated / Δt_coupler\n    \"\"\"\n    (; lnd_h, lnd_ρ, lnd_c) = parameters\n    (; T_sfc) = du\n\n    @. T_sfc = (-F_accumulated) / (lnd_h * lnd_ρ * lnd_c)\nend\n\n# set up domain\nfunction hspace_1D(xlim = (-π, π), npoly = 0, helem = 10)\n    FT = Float64\n\n    domain = CC.Domains.IntervalDomain(\n        CC.Geometry.XPoint{FT}(xlim[1]),\n        CC.Geometry.XPoint{FT}(xlim[2]),\n        periodic = true,\n    )\n    mesh = CC.Meshes.IntervalMesh(domain; nelems = helem)\n    topology = CC.Topologies.IntervalTopology(mesh)\n\n    # Finite Volume Approximation: Gauss-Lobatto with 1pt per element\n    quad = CC.Spaces.Quadratures.GL{npoly + 1}()\n    space = CC.Spaces.SpectralElementSpace1D(topology, quad)\n\n    return space\nend\n\n# init simulation\nfunction lnd_init(; xmin = -1000, xmax = 1000, helem = 20, npoly = 0)\n\n    # construct domain spaces - get only surface layer (NB: z should be zero, not z = first central height)\n    space = hspace_1D((xmin, xmax), npoly, helem)\n    coords = CC.Fields.coordinate_field(space)\n    domain = space\n\n    # initial condition\n    T_sfc = map(coords) do coord\n        T_sfc = 283.0\n    end\n\n    # prognostic variable\n    Y = CC.Fields.FieldVector(T_sfc = T_sfc)\n\n    return Y, domain\nend","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Coupled-Land-Wrappers","page":"Land Model","title":"Coupled Land Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"# Land Simulation - later to live in ClimaLand\nstruct LandSim <: AbstractLandSim\n    integrator::Any\nend\n\nfunction LandSim(\n    Y_init,\n    t_start,\n    dt,\n    t_end,\n    timestepper,\n    p,\n    saveat,\n    callbacks = DiffEqCallbacks.CallbackSet(),\n)\n    ode_algo = CTS.ExplicitAlgorithm(timestepper)\n    ode_function = CTS.ClimaODEFunction(T_exp! = lnd_rhs!)\n\n    problem = SciMLBase.ODEProblem(ode_function, Y_init, (t_start, t_end), p)\n    lnd_integ = SciMLBase.init(\n        problem,\n        ode_algo,\n        dt = dt,\n        saveat = saveat,\n        adaptive = false,\n        callback = callbacks,\n    )\n\n    return LandSim(lnd_integ)\nend\n\nfunction coupler_push!(coupler::CouplerState, land::LandSim)\n    coupler_put!(coupler, :T_sfc_land, land.integrator.u.T_sfc, land)\nend\n\nfunction coupler_pull!(land::LandSim, coupler::CouplerState)\n    coupler_get!(land.integrator.p.F_sfc, coupler, :F_sfc, land)\n    land.integrator.p.F_sfc ./= coupler.Δt_coupled\nend","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"input/#Input","page":"Input","title":"Input","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"The Input module provides functions for parsing command-line arguments and loading configuration files for ClimaCoupler simulations.","category":"page"},{"location":"input/#Providing-Configuration-Options","page":"Input","title":"Providing Configuration Options","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"ClimaCoupler simulations have a variety of configuration options, which are described in the section Available Configuration Options below.","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"Users can configure a coupled simulation through 2 main entry points: command-line arguments and configuration files. Each method, and the priority between them, is explained here.","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"Note that all of these configuration are optional; a default AMIP simulation can be set up with the 0-argument constructor CoupledSimulation().","category":"page"},{"location":"input/#Configuration-Files","page":"Input","title":"Configuration Files","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Configuration files are YAML files that specify simulation parameters. They can be used to specify a valid setting for any configuration option.","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"Note that since the atmosphere model has many configuration options on its own, we also support providing an atmosphere-specific configuration file. As a result, multiple configuration files can be used together:","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"Coupler config file (--config_file): Main configuration file for the coupled simulation\nAtmos config file (--atmos_config_file): Optional ClimaAtmos-specific configuration\nTOML parameter files (--coupler_toml): One or more TOML files containing model parameters","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"When multiple config files are specified, values in the coupler config file will take precedence over those in the atmosphere config file. This is explained in more detail in the Precendence of Config Files and CLI Arguments section below.","category":"page"},{"location":"input/#Parameter-TOML-Files","page":"Input","title":"Parameter TOML Files","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Analogous to configuration files, which specify simulation options such as component models or parameterizations to use, ClimaCoupler also accepts optional TOML files of parameter values.","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"If a TOML file is provided, the default parameter values will be overwritten by the values specified in the TOML. If no TOML file is provided, default parameter values will be used.","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"Since ClimaCoupler accepts coupler config files and atmosphere config files, we may encounter a case where a TOML file is specified in both config files. In this case, the coupler TOML file takes highest priority; only if there is no coupler TOML will the atmosphere-specific TOML be used.","category":"page"},{"location":"input/#Command-Line-Input-(CLI)-Arguments","page":"Input","title":"Command-Line Input (CLI) Arguments","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Command-line arguments can be provided when running a simulation:","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"julia run_amip.jl --config_file=\"path/to/config.yml\" --job_id=\"amip_default\"","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"Typically, we rely mostly on configuration files, and provide only the config_file and job_id via CLI arguments, though if desired any input can be specified in the command line. All available options and their defaults can be viewed by running with --help.","category":"page"},{"location":"input/#Precendence-of-Config-Files-and-CLI-Arguments","page":"Input","title":"Precendence of Config Files and CLI Arguments","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Users have the ability to specify arguments via both CLI arguments and configuration files for any given simulation. If this is done, the options are merged with the following precedence (from lowest to highest priority):","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"ClimaAtmos defaults - Default values from the ClimaAtmos package\nClimaCoupler defaults - Default values defined in argparse_settings()\nCommand-line arguments - Arguments passed via the command line\nClimaAtmos configuration file - YAML file specified via --atmos_config_file or in the coupler config file\nClimaCoupler configuration file - YAML file specified via --config_file (default: config/ci_configs/amip_default.yml)","category":"page"},{"location":"input/#Available-Configuration-Options","page":"Input","title":"Available Configuration Options","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"The following table lists all available command-line arguments organized by category:","category":"page"},{"location":"input/#Simulation-identifying-information","page":"Input","title":"Simulation-identifying information","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--config_file String config/ci_configs/amip_default.yml Any valid file path YAML file used to set the configuration of the coupled model\n--job_id String nothing Any string A unique identifier for this run, defaults to the config file name\n--print_config_dict Bool true true, false Whether to print the final configuration dictionary\n--mode_name String \"amip\" cmip, amip, subseasonal, slabplanet, slabplanet_aqua, slabplanet_terra Mode of coupled simulation\n--coupler_toml Vector{String} [] Any list of valid TOML file paths Optional list of paths to TOML files used to overwrite default model parameters","category":"page"},{"location":"input/#Computational-simulation-setup","page":"Input","title":"Computational simulation setup","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--unique_seed Bool false true, false Whether to set the random number seed to a unique value\n--FLOAT_TYPE String \"Float64\" Float64, Float32 Floating point precision\n--device String \"auto\" auto, CPUSingleThreaded, CPUMultiThreaded, CUDADevice Device type to control running on CPU or GPU","category":"page"},{"location":"input/#Time-information","page":"Input","title":"Time information","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--use_itime Bool true true, false Whether to use ClimaUtilities ITime (integer time) or Float64\n--t_end String \"800secs\" \"Nsecs\", \"Nmins\", \"Nhours\", \"Ndays\", \"Inf\" End time of the simulation, relative to the start date\n--t_start String \"0secs\" \"Nsecs\", \"Nmins\", \"Nhours\", \"Ndays\", \"Inf\" Start time of the simulation, relative to the start date\n--start_date String \"20000101\" \"YYYYMMDD\" format Start date of the simulation\n--dt_cpl String \"400secs\" \"Nsecs\", \"Nmins\", \"Nhours\", \"Ndays\", \"Inf\" Coupling time step\n--dt String \"400secs\" \"Nsecs\", \"Nmins\", \"Nhours\", \"Ndays\", \"Inf\" Component model time step (used if individual component dt's not specified)\n--dt_atmos String nothing \"Nsecs\", \"Nmins\", \"Nhours\", \"Ndays\", \"Inf\" Atmos simulation time step (alternative to dt)\n--dt_land String nothing \"Nsecs\", \"Nmins\", \"Nhours\", \"Ndays\", \"Inf\" Land simulation time step (alternative to dt)\n--dt_ocean String nothing \"Nsecs\", \"Nmins\", \"Nhours\", \"Ndays\", \"Inf\" Ocean simulation time step (alternative to dt)\n--dt_seaice String nothing \"Nsecs\", \"Nmins\", \"Nhours\", \"Ndays\", \"Inf\" Sea ice simulation time step (alternative to dt)\n--checkpoint_dt String \"90days\" \"Nsecs\", \"Nmins\", \"Nhours\", \"Ndays\", \"Inf\" Time interval for checkpointing","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"Note: If any component model-specific timestep is specified, all component-model specific timesteps should be specified, rather than only dt.","category":"page"},{"location":"input/#Space-information","page":"Input","title":"Space information","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--h_elem Int 16 Any positive integer Number of horizontal elements to use for the boundary space\n--share_surface_space Bool true true, false Whether to share the surface space between surface models, atmosphere, and boundary","category":"page"},{"location":"input/#Restart-information","page":"Input","title":"Restart information","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--detect_restart_files Bool false true, false Whether to automatically use restart files if available\n--restart_dir String nothing Any valid directory path Directory containing restart files\n--restart_t Int nothing Any integer (seconds) Time in seconds rounded to nearest index to use at t_start for restarted simulation\n--restart_cache Bool true true, false Whether to read the cache from the restart file if available\n--save_cache Bool true true, false Whether to save the state and cache or only the state when checkpointing","category":"page"},{"location":"input/#Diagnostics-and-output","page":"Input","title":"Diagnostics and output","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--use_coupler_diagnostics Bool true true, false Whether to compute and output coupler diagnostics\n--coupler_output_dir String \"experiments/ClimaEarth/output\" Any valid directory path Directory to save output files","category":"page"},{"location":"input/#Conservation-and-RMSE-checks","page":"Input","title":"Conservation and RMSE checks","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--energy_check Bool false true, false Whether to check energy conservation\n--conservation_softfail Bool false true, false Whether to soft fail on conservation errors\n--rmse_check Bool false true, false Whether to check RMSE of some physical fields","category":"page"},{"location":"input/#ClimaAtmos-specific","page":"Input","title":"ClimaAtmos specific","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--surface_setup String \"PrescribedSurface\" PrescribedSurface, DefaultMoninObukhov Triggers ClimaAtmos into coupled mode\n--atmos_config_file String nothing Any valid file path Optional YAML file used to overwrite default model parameters\n--atmos_log_progress Bool false true, false Use ClimaAtmos walltime logging callback instead of default ClimaCoupler one\n--albedo_model String \"CouplerAlbedo\" ConstantAlbedo, RegressionFunctionAlbedo, CouplerAlbedo Type of albedo model\n--extra_atmos_diagnostics Vector{Dict{Any, Any}} [] List of dictionaries List of dictionaries containing information about additional atmosphere diagnostics to output","category":"page"},{"location":"input/#ClimaLand-specific","page":"Input","title":"ClimaLand specific","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--land_model String \"bucket\" bucket, integrated Land model to use\n--land_temperature_anomaly String \"aquaplanet\" amip, aquaplanet, nothing Type of temperature anomaly for land model\n--use_land_diagnostics Bool true true, false Whether to compute and output land model diagnostics\n--land_spun_up_ic Bool true true, false Whether to use integrated land initial conditions from spun up state\n--lai_source String \"modis_monthly\" modis_monthly, modis_monthly_climatology Source for leaf area index data. modis_monthly uses full MODIS monthly data, modis_monthly_climatology uses MODIS monthly climatology with periodic calendar\n--bucket_albedo_type String \"map_static\" map_static, function, map_temporal, era5 Access bucket surface albedo information from data file. Use era5 for ERA5-derived processed albedo files (requires era5_initial_condition_dir)\n--bucket_initial_condition String \"\" Any valid file path File path for a NetCDF file (read documentation about requirements). In subseasonal mode, automatically inferred from era5_initial_condition_dir if not specified\n--era5_initial_condition_dir String nothing Any valid directory path Directory containing ERA5 initial condition files (subseasonal mode). Filenames inferred from start_date. Generated with https://github.com/CliMA/WeatherQuest\n--land_fraction_source String \"etopo\" etopo, era5 Source for land fraction data. etopo uses ETOPO-derived landsea_mask artifact (binary), era5 uses ERA5/IFS land fraction artifact (0.0 - 1.0), which includes large inland seas and lakes.\n--binary_area_fraction Bool true true, false Whether to use binary (thresholded) area fractions for land and ice. When true, land fraction > eps becomes 1, and ice fraction > 0.5 becomes 1","category":"page"},{"location":"input/#Ice-model-specific","page":"Input","title":"Ice model specific","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--ice_model String \"prescribed\" prescribed, clima_seaice Sea ice model to use","category":"page"},{"location":"input/#Ocean-model-specific","page":"Input","title":"Ocean model specific","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Argument Type Default Valid Options Description\n--evolving_ocean Bool true true, false Whether to use a dynamic slab ocean model, as opposed to constant surface temperatures","category":"page"},{"location":"input/#Input-API","page":"Input","title":"Input API","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"Input.argparse_settings\nInput.parse_commandline\nInput.get_coupler_config_dict\nInput.get_coupler_args\nInput.get_land_fraction","category":"page"},{"location":"input/#ClimaCoupler.Input.argparse_settings","page":"Input","title":"ClimaCoupler.Input.argparse_settings","text":"argparse_settings()\n\nCreate and return an ArgParseSettings object with all command-line arguments for ClimaCoupler simulations. Each option should include an argument type, a default value, and a brief help string including the valid values for this option.\n\n\n\n\n\n","category":"function"},{"location":"input/#ClimaCoupler.Input.parse_commandline","page":"Input","title":"ClimaCoupler.Input.parse_commandline","text":"parse_commandline(settings)\n\nParse command-line arguments using the provided ArgParseSettings object.\n\nArguments\n\nsettings: An ArgParse.ArgParseSettings object containing the command-line arguments to parse\n\nReturns\n\nA dictionary of parsed command-line arguments\n\n\n\n\n\n","category":"function"},{"location":"input/#ClimaCoupler.Input.get_coupler_config_dict","page":"Input","title":"ClimaCoupler.Input.get_coupler_config_dict","text":"get_coupler_config_dict(config_file)\n\nRead in the configuration file and job ID from the command line. A dictionary is constructed from the input configuration file and returned.\n\nSince the atmosphere model also uses a configuration file, we read in the atmosphere configuration file specified in the coupler configuration file (if any), and overwrite it with the coupler configuration.\n\nThe order of priority for overwriting configuration options from lowest to highest is:     1. ClimaAtmos defaults     2. ClimaCoupler defaults (defined in Input.argparse_settings())     3. Command line arguments provided to ClimaCoupler     4. ClimaAtmos configuration file (if specified in coupler config file)     5. ClimaCoupler configuration file\n\nReturns\n\nconfig_dict: A dictionary mapping configuration keys to the specified settings\n\n\n\n\n\n","category":"function"},{"location":"input/#ClimaCoupler.Input.get_coupler_args","page":"Input","title":"ClimaCoupler.Input.get_coupler_args","text":"get_coupler_args(config_dict)\n\nExtract the necessary arguments from the coupled configuration dictionary.\n\nArguments\n\nconfig_dict: A dictionary mapping configuration keys to the specified settings\n\nReturns\n\nA NamedTuple of all arguments needed for the coupled simulation\n\n\n\n\n\n","category":"function"},{"location":"input/#ClimaCoupler.Input.get_land_fraction","page":"Input","title":"ClimaCoupler.Input.get_land_fraction","text":"get_land_fraction(boundary_space, comms_ctx; land_fraction_source = \"etopo\", binary_area_fraction = true)\n\nRead and remap the land-sea fraction field onto the coupler boundary grid.\n\nArguments\n\nboundary_space: The boundary space onto which to remap the land fraction.\ncomms_ctx: The communications context.\nland_fraction_source: Source of land fraction data. Either \"etopo\" (default) or \"era5\".\nbinary_area_fraction: If true (default), threshold land fraction to binary (0 or 1).\nmode_name: The name of the simulation mode.\n\nReturns\n\nA field containing land fraction values (0 to 1) on the boundary space. In the terraplanet mode, the land fraction is 1 over the entire surface.\n\nNote: Land-sea Fraction     This is a static field that contains the area fraction of land and sea, ranging from 0 to 1.     If applicable, sea ice is included in the sea fraction at this stage.     Note that land-sea area fraction is different to the land-sea mask, which is a binary field     (masks are used internally by the coupler to indicate passive cells that are not populated by a given component model).\n\nTwo sources are supported via the `land_fraction_source` config option:\n- \"etopo\": ETOPO-derived binary land-sea mask (landsea_mask_60arcseconds artifact)\n- \"era5\": ERA5 land fraction field (era5_land_fraction artifact)\n\n\n\n\n\n","category":"function"},{"location":"performance/#Performance-Analysis-Tools","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"","category":"section"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"Until commit 7a7e98, ClimaCoupler provided included performance jobs. You can find them by following the link above.","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"Below is a short description.","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"ClimaCoupler.jl provides basic tools for analyzing performance:","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"Flame graphs: the perf/flame.jl script is run by Buildkite to produce flame graphs using ProfileCanvas.jl in the perf/output/ directory.\nJob walltime and allocation history: use Buildkite to trigger the build_history script to output an interactive plot with the history of memory usage and time elapsed for each tracked job (default: current build and past builds of the staging branch over the past year). Use key to select which jobs to track. More documentation can be found in the SLURM-Buildkite Wiki.","category":"page"},{"location":"performance/#Flame-Graph-Interpretation","page":"Performance Analysis Tools","title":"Flame Graph Interpretation","text":"","category":"section"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"use for single-process (un)threaded performance CPU profiling of individual stack traces. It provides a tree representation of a set of backtraces, showing the dependence and CPU cost of each function.\nhere is an example of a flame graph of ClimaCoupler's AMIP run, produced by Buildkite running the perf/flame.jl script:","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"(Image: canvas)","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"each row along the y-axis represents a level of backtraces. In this case the lowermost level is at the top, and the top level represents what is directly being run on the CPU. The stacks in each level are sorted alphabetically (not chronologically, like flame charts). The column width is proportional to the presence in samples (related to allocations). The colors are grouped into runtime-dispatch, gc, compilation and default. The intensity is random.\nwe also have a local beta version of flame graphs (in perf/ProfileCanvasDiff.jl and perf/ProfileViewerDiff.js), triggered by the perf/flame_diff.jl script, which plots the same flame graphs as above but with the color corresponding to whether the stack allocation has been reduced (blue) or increased (red) compared to the last staged runs. The color intensity is proportional to the fractional change, and black signifies untracked traces. The default is to show the cumulative allocation (current function + all its children functions). By setting self_count to true, we can also count only the allocations of the current function itself, allowing us to isolate allocation changes within our software from changes in the upstream packages.","category":"page"},{"location":"performance/#References","page":"Performance Analysis Tools","title":"References","text":"","category":"section"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"Description of flame graphs and their interpretation\nClimaCore tips for writing performant code\nGeneral Julia-specific performance tips\nLogging performance history using Buildkite and SLURM\nNSight Systems for MPI profiling using Buildkite and SLURM","category":"page"},{"location":"diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"ClimaCoupler.jl utilizes other packages in the CliMA ecosystem to generate and visualize diagnostics, namely ClimaDiagnostics.jl and ClimaAnalysis.jl.","category":"page"},{"location":"diagnostics/#Default-AMIP-diagnostics","page":"Diagnostics","title":"Default AMIP diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"We output a set of default diagnostics for all AMIP runs. These currently include the following fields:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Atmospheric quantiies:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"air temperature at the bottom of the atmosphere (3D)\neastward near-surface wind (3D)\nspecific humidity (3D)\nmass fraction of cloud liquid water (3D)\nnet top-of-atmosphere fluxes (3D)\nprecipitation (2D)\nsurface temperature (2D)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Coupler quantities","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"turbulent energy fluxes (2D)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"These diagnostics are all averaged over a period of time that depends on the length of the overall simulation according to the following rule:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"simulation length >= 90 days: 30-day mean\nsimulation length >= 30 days and < 90 days: 10-day mean\nsimulation length >= 1 day and < 30 days: 1-day mean\nsimulation length < 1 day: 1-hour mean","category":"page"},{"location":"diagnostics/#How-to-add-a-new-diagnostic-variable","page":"Diagnostics","title":"How to add a new diagnostic variable","text":"","category":"section"},{"location":"diagnostics/#Adding-a-diagnostic-for-a-ClimaCoupler-quantity","page":"Diagnostics","title":"Adding a diagnostic for a ClimaCoupler quantity","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For diagnostics that come from coupler fields or that are computed using input from multiple component models, we set up the diagnostics by directly creating ClimaDiagnostics.jl objects.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Specifically, we first create a DiagnosticVariable object containing the variable's name, units, any comments, and the function to compute it. This is then used to create a ScheduledDiagnostic variable, which includes saving and output time information. Once we have created a ScheduledDiagnostic for each variable we're interested in, we collect them in a vector and pass this to our DiagnosticsHandler object.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"An example of this process for the combined turbulent energy flux, F_turb_energy, can be found in src/SimOutput/diagnostics.jl in the SimOutput.diagnostics_setup function.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For more information about this process, please see the ClimaDiagnostics.jl documentation.","category":"page"},{"location":"diagnostics/#Adding-a-diagnostic-for-a-CliMA-component-model-quantity","page":"Diagnostics","title":"Adding a diagnostic for a CliMA component model quantity","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Many of our current diagnostics are values that we access directly from a component model. To add a new diagnostic of this kind, you can add a new method add_diagnostic_variable! extending this function from the component model package's Diagnostics module.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For more information about this function and the form it takes, please see the ClimaDiagnostics.jl documentation.","category":"page"},{"location":"diagnostics/#ClimaAtmos.jl","page":"Diagnostics","title":"ClimaAtmos.jl","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"To add a new diagnostic for the ClimaAtmos.jl atmosphere model, you can add this new method for ClimaAtmos.Diagnostics.add_diagnostic_variable! in components/atmosphere/climaatmos_extra_diags.jl. The existing diagnostics in that file can be used as templates.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For more information about ClimaAtmos diagnostics, and to see the default atmospheric diagnostics, please see that package's documentation.","category":"page"},{"location":"diagnostics/#ClimaLand.jl","page":"Diagnostics","title":"ClimaLand.jl","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"To add a new diagnostic for the ClimaLand.jl bucket model, you can add this new method for ClimaLand.Diagnostics.add_diagnostic_variable! in components/land/climaland_bucket_extra_diags.jl (which doesn't exist at the time of writing).","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For more information about ClimaLand diagnostics, and to see the default land diagnostics, please see that package's documentation.","category":"page"},{"location":"diagnostics/#Visualizing-diagnostics","page":"Diagnostics","title":"Visualizing diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"ClimaCoupler.jl uses ClimaAnalysis.jl to parse and visualize the outputs saved using ClimaDiagnostics.jl.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For more information about ClimaAnalysis.jl, please see that package's documentation.","category":"page"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"ClimaCoupler.jl implements a few simple surface models for use in coupled simulations. These models are provided in the Models module and provide basic ocean and sea ice representations that can be used when more sophisticated component models are not needed or available.","category":"page"},{"location":"models/#Slab-Ocean-Model","page":"Models","title":"Slab Ocean Model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The slab ocean model (SlabOceanSimulation) is a simple energy balance model for the ocean surface layer. It solves the following energy equation:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"(h cdot rho cdot c) fracdTdt = -F_textturb_energy + (1 - alpha) cdot SW_d + LW_d - LW_u","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"h is the depth of the ocean slab [m]\nrho is the density of the ocean [kg/m³]\nc is the specific heat capacity of the ocean [J/(kg·K)]\nT is the ocean surface temperature [K]\nF_textturb_energy is the turbulent energy flux (latent + sensible heat) [W/m²]\nalpha is the ocean albedo\nSW_d is the downwelling shortwave radiation [W/m²]\nLW_d is the downwelling longwave radiation [W/m²]\nLW_u is the upwelling longwave radiation [W/m²] (calculated as epsilon sigma T^4)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The model assumes a well-mixed surface layer of fixed depth and computes the temperature evolution based on the net energy flux into the ocean. The ocean surface temperature is used to compute upwelling longwave radiation and surface fluxes.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Usage: The slab ocean model is used in:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"SlabplanetMode simulations\nSlabplanetAquaMode simulations","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The slab ocean model should not be used with a sea ice model, as it does not account for ice-ocean interactions.","category":"page"},{"location":"models/#Prescribed-Ocean-Model","page":"Models","title":"Prescribed Ocean Model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The prescribed ocean model (PrescribedOceanSimulation) uses observed sea surface temperature (SST) data that is read from a file at each timestep. The SST is prescribed and does not evolve based on energy fluxes, making this a \"data-driven\" ocean representation.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The model includes:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Prescribed SST from observational data (e.g., HadISST)\nOcean roughness parameterization following NOAA-GFDL ice_param\nWind-dependent albedo calculation using ClimaAtmos regression functions\nSurface properties (roughness lengths, albedo) that can be updated based on atmospheric conditions","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Since the SST is prescribed, this model does not solve any prognostic equations. It serves as a boundary condition for the atmosphere, providing realistic ocean surface temperatures for atmospheric simulations.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Usage: The prescribed ocean model is used in:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"AMIPMode simulations\nSubseasonalMode simulations","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"These simulation types are designed for atmospheric model evaluation and prediction, where realistic SSTs are needed but ocean dynamics are not the focus.","category":"page"},{"location":"models/#Prescribed-Sea-Ice-Model","page":"Models","title":"Prescribed Sea Ice Model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The prescribed sea ice model (PrescribedIceSimulation) uses observed sea ice concentration (SIC) data while solving an energy balance equation for the ice surface temperature. The model solves:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"(h cdot rho cdot c) fracdT_textbulkdt = -F_textturb_energy + (1 - alpha) cdot SW_d + epsilon cdot (LW_d - LW_u) + F_textconductive","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"with the conductive flux:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"F_textconductive = frack_texticeh (T_textbase - T_textsfc)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"T_textbulk is the bulk ice temperature [K] (prognostic variable)\nT_textsfc is the ice surface temperature [K] (diagnostic, extrapolated from T_textbulk and T_textbase)\nT_textbase is the prescribed temperature at the ice base (sea water temperature) [K]\nk_textice is the thermal conductivity of sea ice [W/(m·K)]\nh is the ice thickness [m]\nOther variables are as defined for the slab ocean model","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The sea ice concentration is read from observational data (e.g., HadISST) and updated at each timestep. The ice temperature is constrained to remain at or below the freezing point of seawater. The model assumes a linear temperature profile through the ice layer, allowing the surface temperature to be computed from the bulk temperature and base temperature.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"This formulation follows the approach of Holloway and Manabe (1971), where sea ice concentration and thickness are prescribed, and the model solves for the ice temperature.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Usage: The prescribed sea ice model is used in:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"AMIPMode simulations\nSubseasonalMode simulations","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"These simulation types use prescribed sea ice concentration along with prescribed ocean SSTs to provide realistic surface boundary conditions for atmospheric models.","category":"page"},{"location":"models/#Model-Selection","page":"Models","title":"Model Selection","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The choice of which models to use is typically determined by the simulation mode:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"AMIP/Subseasonal modes: Use prescribed ocean and prescribed sea ice\nCMIP mode: Uses more sophisticated models (oceananigans ocean, clima_seaice sea ice)\nSlabplanet modes: Use slab ocean and no sea ice (or nothing for both ocean and ice in terra mode)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The models are selected via configuration files or command-line arguments when setting up a CoupledSimulation. For more information about how to select these component models, please see the Input module documentation.","category":"page"},{"location":"interfacer/#Interfacer","page":"Interfacer","title":"Interfacer","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"This module contains functions that define the interface for coupling component models, as well as stub objects that contain prescribed fields. Here we explain each type of component model, and the functions that must be implemented to use a component model with ClimaCoupler.jl","category":"page"},{"location":"interfacer/#Coupled-simulation","page":"Interfacer","title":"Coupled simulation","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A CoupledSimulation stores info for ESM run and contains each of the component model simulations. We currently require that each CoupledSimulation contains one atmos_sim, and at least one surface simulation (land_sim, ocean_sim, and/or ice_sim). If a simulation surface type is not needed for a given run, it may be omitted.","category":"page"},{"location":"interfacer/#Component-simulations","page":"Interfacer","title":"Component simulations","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Individual component model simulations fall under AbstractComponentSimulation, which together combine to make the CoupledSimulation. We have two types of AbstractComponentSimulations: AbstractAtmosSimulation and AbstractSurfaceSimulation. The two have different requirements, which are detailed below. AbstractSurfaceSimulation is further divided into AbstractSeaIceSimulation, AbstractLandSimulation, and AbstractOceanSimulation, representing the 3 currently-supported options for surface models.","category":"page"},{"location":"interfacer/#AbstractComponentSimulation-required-functions","page":"Interfacer","title":"AbstractComponentSimulation - required functions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A component model simulation should be implemented as a struct that is a concrete subtype of a AbstractComponentSimulation. This struct should contain all of the information needed to run that simulation.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Each AbstractComponentSimulation must extend the following functions to be able to use our coupler. For some existing models, these are defined within ClimaCoupler.jl in that model’s file in experiments/ClimaEarth/components/, but it is preferable for these to be defined in a model’s own repository. Note that the dispatch ::AbstractComponentSimulation in the function definitions given below should be replaced with the particular component model extending these functions.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"constructor: construct and return an instance of the AbstractComponentSimulation,","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"and perform all initialization. This function should return a simulation that is ready to be stepped in the coupled simulation. The interface for this function varies across component models.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"step!(::AbstractComponentSimulation, t): A function to update the","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"simulation in-place with values calculate for time t. For the models we currently have implemented, this is a simple wrapper around the step! function implemented in SciMLBase.jl.","category":"page"},{"location":"interfacer/#AbstractComponentSimulation-optional-functions","page":"Interfacer","title":"AbstractComponentSimulation - optional functions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Checkpointer.get_model_prog_state(::AbstractComponentSimulation):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A function that returns the state vector of the simulation at its current state. This is used for checkpointing the simulation.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Checkpointer.get_model_cache(::AbstractComponentSimulation):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A function that returns the cache of the simulation at its current state. This is used for checkpointing the simulation.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Checkpointer.restore_cache(::AbstractComponentSimulation, new_cache):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A function that updates the cache of the simulation with the provided new_cache. This is used for restarting the simulation.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(::AbstractComponentSimulation, ::Val{property}):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Default get_field functions are provided for energy and water fields, described in the table below. These quantities are used to track conservation, and the defaults return nothing. To check conservation throughout a simulation, these functions must be extended for all models being run.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units Default value\nenergy vertically integrated energy per surface area J m⁻² nothing\nwater vertically integrated water per surface area kg m⁻² nothing","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"add_coupler_fields!(coupler_field_names, ::AbstractComponentSimulation):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A set of default coupler exchange fields is initialized for each coupled simulation, but depending on the component models being run, additional coupler fields may be required. For example, the integrated land model requires the concentration of atmospheric CO2 for photosynthesis calculations, but the slab ocean does not. add_coupler_fields! is extended for any component model simulation that requires coupler fields in addition to the defaults, allowing us to allocate space for and exchange the extra fields only when necessary. All coupler fields are defined on the boundary space.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Any additional fields specified here will likely also require an update_field!","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"method defined for this component model, so the coupler can update the component. They may also require a new method of import_atmos_fields! or combine_surfaces! to update the coupler fields from the component model that computes the field.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"The default coupler exchange fields are the following, defined in default_coupler_fields() in the Interfacer module:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\nT_atmos atmosphere temperature at the bottom layer K\nq_tot_atmos atmosphere total humidity at the bottom layer kg kg⁻¹\nq_liq_atmos atmosphere liquid humidity at the bottom layer kg kg⁻¹\nq_ice_atmos atmosphere ice humidity at the bottom layer kg kg⁻¹\nρ_atmos atmosphere air density at the bottom layer kg m⁻³\nheight_int height at the bottom cell center of the atmosphere space m\nheight_sfc height at the bottom face of the atmosphere space m\nF_lh latent heat flux W m⁻²\nF_sh sensible heat flux W m⁻²\nF_turb_moisture turbulent moisture flux kg m⁻² s⁻¹\nF_turb_ρτxz turbulent momentum flux in the zonal direction kg m⁻¹ s⁻²\nF_turb_ρτyz turbulent momentum flux in the meridional direction kg m⁻¹ s⁻²\nSW_d downward SW flux at the surface W m⁻²\nLW_d downward LW flux at the surface W m⁻²\nemissivity surface emissivity -\nT_sfc surface temperature, averaged across components K\nP_liq liquid precipitation kg m⁻² s⁻¹\nP_snow snow precipitation kg m⁻² s⁻¹\nscalar_temp1 a surface scalar field used for intermediate calculations -\nscalar_temp2 a surface scalar field used for intermediate calculations -\nscalar_temp3 a surface scalar field used for intermediate calculations -\nscalar_temp4 a surface scalar field used for intermediate calculations -","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"note: What should be stored in the coupler exchange fields?\nIn general, the coupler fields should contain exchange fields for fluxes, including turbulent fluxes, radiative fluxes, and precipitation. They also hold any quantities that a component model requires from another component. For example, the atmosphere needs surface temperature and emissivity from the surface models to compute radiation, so the coupler allocates space to exchange them. The coupler exchange fields may also hold quantities from components that are used to compute turbulent fluxes. As a general rule, we tend to store such quantities that come from the atmosphere model, but access them when needed for surface models. This is because we compute fluxes indvidually for the interface between each surface and the atmosphere model. As a result, the atmosphere quantities are used for each of these calculations, so storing them in the coupler fields allows us to avoid regridding them to the coupler space multiple times per coupling timestep.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"update_sim!(::AbstractComponentSimulation, csf): A","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"function to update each of the fields of the component model simulation that are updated by the coupler. ClimaCoupler.jl provides defaults of this function for both AbstractAtmosSimulation and AbstractSurfaceSimulation that update each of the fields expected by the coupler. This function will need to be extended for any model that requires additional fields (specified via add_coupler_fields!).","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"set_cache!(sim::AbstractComponentSimulation): A function to perform any","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"initialization of the component model caches that isn't done during the model simulation initialization, and that must be done after the initial exchange. This is necessary, for example, when component models have cache interdependencies that must be handled in a specific order. Cache variables that are computed as part of the tendencies do not need to be set here.","category":"page"},{"location":"interfacer/#AbstractAtmosSimulation-required-functions","page":"Interfacer","title":"AbstractAtmosSimulation - required functions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"In addition to the functions required for a general AbstractComponentSimulation, an AbstractAtmosSimulation requires the following functions to retrieve and update its fields.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(::AbstractAtmosSimulation. ::Val{property}): This getter","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"function returns the value of the field property for the simulation in its current state. For an AbstractAtmosSimulation, it must be extended for the following properties:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\nair_density air density at the bottom cell centers of the atmosphere kg m⁻³\nair_pressure air pressure at the bottom cell centers of the atmosphere Pa\nair_temperature air temperature at the bottom cell centers of the atmosphere K\nheight_int height at the bottom cell center of the atmosphere space m\nheight_sfc height at the bottom face of the atmosphere space m\nliquid_precipitation liquid precipitation at the surface kg m⁻² s⁻¹\nSW_d downwelling shortwave radiation at the surface W m⁻²\nLW_d downwelling longwave radiation at the surface W m⁻²\nradiative_energy_flux_toa net radiative flux at the top of the atmosphere W m⁻²\nsnow_precipitation snow precipitation at the surface kg m⁻² s⁻¹\nspecific_humidity specific humidity at the bottom cell centers of the atmosphere kg kg⁻¹\nturbulent_energy_flux aerodynamic turbulent surface fluxes of energy (sensible and latent heat) W m⁻²\nturbulent_moisture_flux aerodynamic turbulent surface fluxes of energy (evaporation) kg m⁻² s⁻¹\nu_int zonal wind velocity vector at the first internal model level m s⁻¹\nv_int meridional wind velocity vector at the first internal model level m s⁻¹","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"update_field!(::AbstractAtmosSimulation. ::Val{property}, field):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A function to update the value of property in the component model simulation, using the values in field. This update should be done in place. If this function isn't extended for a property, that property will remain constant throughout the simulation and a warning will be raised. This function is expected to be extended for the following properties, and may also be extended for any additional properties needed by a component model.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\nemissivity surface emissivity \nsurface_direct_albedo bulk direct surface albedo over the whole surface space \nsurface_diffuse_albedo bulk diffuse surface albedo over the whole surface space \nsurface_temperature temperature over the combined surface space K\nturbulent_fluxes turbulent fluxes W m⁻²","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"ClimaAtmos should also add the following coupler fields for Monin-Obukhov similarity theory: | Coupler name    | Description       | Units  | |––––––––-|–––––––––-|––––| | ustar         | friction velocity | m s⁻¹  | | L_MO          | Obukhov length    | m      | | buoyancy_flux | flux of buoyancy  | m⁻²s⁻³ |","category":"page"},{"location":"interfacer/#AbstractAtmosSimulation-required-functions-to-run-with-the-ClimaLandSimulation","page":"Interfacer","title":"AbstractAtmosSimulation - required functions to run with the ClimaLandSimulation","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupling with the integrated ClimaLandSimulation requires the following functions, in addition to the functions required for coupling with a general AbstractSurfaceSimulation.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(::AbstractAtmosSimulation. ::Val{property}):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"This getter function must be extended for the following properties:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\nco2 global mean co2 ppm\ndiffuse_fraction fraction of downwards shortwave flux that is direct \nLW_d downwards longwave flux W m⁻²\nSW_d downwards shortwave flux W m⁻²","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"note: Note\nco2, diffuse_fraction, LW_d and SW_d will not be present in a ClimaAtmosSimulation if the model is setup with no radiation. Because of this, a ClimaAtmosSimulation must have radiation enabled if running with the full ClimaLand model.","category":"page"},{"location":"interfacer/#AbstractSurfaceSimulation-required-functions","page":"Interfacer","title":"AbstractSurfaceSimulation - required functions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Analogously to the AbstractAtmosSimulation, an AbstractSurfaceSimulation requires additional functions to those required for a general AbstractComponentSimulation.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(::AbstractSurfaceSimulation, ::Val{property}): This getter","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"function returns the value of the field property for the simulation at the current time. For an AbstractSurfaceSimulation, it must be extended for the following properties:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\narea_fraction fraction of the simulation grid surface area this model covers \nroughness_buoyancy aerodynamic roughness length for buoyancy m\nroughness_momentum aerodynamic roughness length for momentum m\nsurface_direct albedo bulk direct surface albedo \nsurface_diffuse albedo bulk diffuse surface albedo \nsurface_temperature surface temperature K\nice_concentration sea ice concentration (sea ice models only) ","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"note: Note\narea_fraction is expected to be defined on the boundary space of the simulation, while all other fields will likely be on the simulation's own space.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"note: Sea ice concentration vs. area fraction\nSea ice models are expected to provide both area_fraction and ice_concentration. This may seem redundant, but there are subtle differences between the two. ice_concentration is internal to the ice model and may be determined via a prognostic variable, prescribed data, etc. area_fraction is defined at the coupler level and may follow some constraints that don't apply to ice_concentration. For example, we require that surface model area fractions sum to 1 at all points; this constraint is enforced for area_fraction, but not for ice_concentration. Additionally, since area_fraction is a coupler-defined concept, it is defined on the coupler boundary space, whereas ice_concentration exists on the model's space. Generally, ice_concentration and area_fraction should largely agree, with differences only arising from area_fraction corrections and the fields existing on different spaces.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"update_field!(::AbstractSurfaceSimulation, ::Val{property}, field):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A function to update the value of property in the component model simulation, using the values in field passed from the coupler This update should be done in place. If this function isn't extended for a property, that property will remain constant throughout the simulation and a warning will be raised. This function is expected to be extended for the following properties, and may also be extended for any additional properties needed by a component model.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\narea_fraction fraction of the simulation grid surface area this model covers \nliquid_precipitation liquid precipitation at the surface kg m⁻² s⁻¹\nSW_d downwelling shortwave radiation at the surface W m⁻²\nLW_d downwelling longwave radiation at the surface W m⁻²\nsnow_precipitation snow precipitation at the surface kg m⁻² s⁻¹\nturbulent_energy_flux aerodynamic turbulent surface fluxes of energy (sensible and latent heat) W m⁻²\nturbulent_moisture_flux aerodynamic turbulent surface fluxes of energy (evaporation) kg m⁻² s⁻¹","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"note: Note\nupdate_field!(::AbstractSurfaceSimulation, ::Val{:area_fraction}, field) is not required to be extended for land models, since they're assumed to have a constant area fraction.","category":"page"},{"location":"interfacer/#AbstractSurfaceSimulation-optional-functions","page":"Interfacer","title":"AbstractSurfaceSimulation - optional functions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(::AbstractSurfaceSimulation, ::Val{property}):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"For some quantities, default get_field functions are provided, which may be overwritten or used as-is. These currently include the following:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units Default value\nemissivity measure of how much energy a surface radiates  1\nheight_disp displacement height relative to the surface m 0\nroughness_model roughness parameterization for surface flux calculations  :constant\ncoare3_roughness_params COARE3 roughness params Field on exchange grid (when roughness_model is :coare3)  -","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"note: Roughness model option\nDefault is :constant. Use :coare3 for dynamic ocean roughness; then provide coare3_roughness_params via get_field.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"update_turbulent_fluxes!(::AbstractComponentSimulation, fields::NamedTuple):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"This function updates the turbulent fluxes of the component model simulation at this point in horizontal space. The values are updated using the energy and moisture turbulent fluxes stored in fields which are calculated by the coupler.","category":"page"},{"location":"interfacer/#Prescribed-surface-conditions-SurfaceStub","page":"Interfacer","title":"Prescribed surface conditions - SurfaceStub","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"SurfaceStub is an AbstractSurfaceSimulation, but it only contains required data in <surface_stub>.cache, e.g., for the calculation of surface fluxes through a prescribed surface state. This model is intended to be used for testing or as a simple stand-in model. The above adapter functions are already predefined for AbstractSurfaceStub, which is extended by SurfaceStub in the surface_stub.jl file, with the cache variables specified as:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(sim::AbstractSurfaceStub, ::Val{:area_fraction}) = sim.cache.area_fraction\nget_field(sim::AbstractSurfaceStub, ::Val{:roughness_buoyancy}) = sim.cache.z0b\nget_field(sim::AbstractSurfaceStub, ::Val{:roughness_momentum}) = sim.cache.z0m\nget_field(sim::AbstractSurfaceStub, ::Val{:surface_direct_albedo}) = sim.cache.α_direct\nget_field(sim::AbstractSurfaceStub, ::Val{:surface_diffuse_albedo}) = sim.cache.α_diffuse\nget_field(sim::AbstractSurfaceStub, ::Val{:surface_temperature}) = sim.cache.T_sfc","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"and with the corresponding update_field! functions","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"function update_field!(sim::AbstractSurfaceStub, ::Val{:area_fraction}, field::ClimaCore.Fields.Field)\n    sim.cache.area_fraction .= field # `area_fraction` is on the boundary space, so it doesn't need remapping\nend\nfunction update_field!(sim::AbstractSurfaceStub, ::Val{:surface_temperature}, field::ClimaCore.Fields.Field)\n    Interfacer.remap!(sim.cache.T_sfc, field)\nend\nfunction update_field!(sim::AbstractSurfaceStub, ::Val{:surface_direct_albedo}, field::CC.Fields.Field)\n    Interfacer.remap!(sim.cache.α_direct, field)\nend\nfunction update_field!(sim::AbstractSurfaceStub, ::Val{:surface_diffuse_albedo}, field::CC.Fields.Field)\n    Interfacer.remap!(sim.cache.α_diffuse, field)\nend","category":"page"},{"location":"interfacer/#Interfacer-API","page":"Interfacer","title":"Interfacer API","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"    Interfacer.CoupledSimulation\n    Interfacer.AbstractAtmosSimulation\n    Interfacer.AbstractSurfaceSimulation\n    Interfacer.AbstractComponentSimulation\n    Interfacer.AbstractSurfaceStub\n    Interfacer.SurfaceStub\n    Interfacer.get_field\n    Interfacer.update_field!\n    Interfacer.AbstractSlabplanetSimulationMode\n    Interfacer.AMIPMode\n    Interfacer.SubseasonalMode\n    Interfacer.SlabplanetMode\n    Interfacer.SlabplanetAquaMode\n    Interfacer.SlabplanetTerraMode\n    Interfacer.set_cache!\n    Interfacer.remap\n    Interfacer.remap!\n    Interfacer.boundary_space\n    Interfacer.get_atmos_height_delta","category":"page"},{"location":"interfacer/#ClimaCoupler.Interfacer.CoupledSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.CoupledSimulation","text":"CoupledSimulation\n\nStores information needed to run a simulation with the coupler.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractAtmosSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractAtmosSimulation","text":"AbstractAtmosSimulation\n\nAn abstract type for an atmospheric model simulation.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractSurfaceSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractSurfaceSimulation","text":"AbstractSurfaceSimulation\n\nAn abstract type for surface model simulations.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractComponentSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractComponentSimulation","text":"AbstractComponentSimulation\n\nAn abstract type encompassing all component model (and model stub) simulations.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractSurfaceStub","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractSurfaceStub","text":"AbstractSurfaceStub\n\nAn abstract type representing a simple stand-in surface model. Any concrete type extending this abstract type should have a cache field that contains the necessary fields for the simulation, at minimum the following:     - T_sfc (surface temperature [K])     - z0m (roughness length for momentum [m])     - z0b (roughness length for tracers [m])     - α_direct (direct albedo)     - α_diffuse (diffuse albedo)     - area_fraction (fraction of the grid cell covered by the ocean)     - phase (phase of the water used to calculate surface humidity)     - thermo_params (thermodynamic parameters)\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SurfaceStub","page":"Interfacer","title":"ClimaCoupler.Interfacer.SurfaceStub","text":"SurfaceStub\n\nOn object containing simulation-like info, used as a stub or for prescribed data.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.get_field","page":"Interfacer","title":"ClimaCoupler.Interfacer.get_field","text":"Interfacer.getfield(sim::ClimaAtmosSimulation, ::Val{:radiativeenergyfluxtoa})\n\nExtension of Interfacer.get_field to get the net TOA radiation, which is a sum of the upward and downward longwave and shortwave radiation.\n\n\n\n\n\nInterfacer.get_field(sim::BucketSimulation, ::Val{:energy})\n\nExtension of Interfacer.get_field that provides the total energy contained in the bucket, computed from the temperature of the bucket and also including the latent heat of fusion of frozen water in the snow.\n\nThis method is required by the ConservationChecker to check energy conservation.\n\n\n\n\n\nInterfacer.get_field(sim::BucketSimulation, ::Val{:water})\n\nExtension of Interfacer.get_field that provides the total water contained in the bucket. The total water contained in the bucket is the sum of the subsurface water storage W, the snow water equivalent σS, and surface water content Ws.\n\nThis method is required by the ConservationChecker to check water conservation.\n\n\n\n\n\nget_field(sim::AbstractAtmosSimulation, val::Val)\n\nA getter function that should not allocate. Here we implement a default that will raise an error if get_field isn't defined for all required fields of an atmosphere component model.\n\n\n\n\n\nget_field(sim::AbstractSurfaceSimulation, val::Val)\n\nA getter function that should not allocate. Here we implement a default that will raise an error if get_field isn't defined for all required fields of a surface component model.\n\n\n\n\n\nget_field(sim::AbstractComponentSimulation, val::Val)\n\nGeneric fallback for get_field that raises an error.\n\n\n\n\n\nget_field(sim::AbstractSurfaceSimulation, ::Val{:roughness_model})\n\nReturn the roughness model to be used for surface flux calculations. Returns :constant by default. Ocean models should override this to return :coare3 to use COARE3 roughness parameterization, which accounts for the dynamic response of ocean surface roughness to wind speed and wave state. The :constant roughness model uses fixed roughness lengths for momentum and buoyancy specified by the component model.\n\nThis ensures COARE3 is applied over ocean surfaces where the area_fraction > 0, while land and sea ice surfaces use constant roughness parameterization.\n\n\n\n\n\nget_field(target_space, sim, quantity)\n\nReturn quantity in sim remapped onto the target_space\n\nThis is equivalent to calling get_field, and then remap.\n\n\n\n\n\nget_field(::AbstractSurfaceStub, ::Val)\n\nA getter function, that should not allocate. If undefined, it returns a descriptive error.\n\n\n\n\n\nget_field(::AbstractSurfaceStub, ::Val{:coare3_roughness_params})\n\nReturn cached COARE3 roughness params when present in the stub's cache (e.g. PrescribedOceanSimulation).\n\n\n\n\n\nInterfacer.get_field(sim::SlabOceanSimulation, ::Val{:energy})\n\nExtension of Interfacer.get_field to get the energy of the ocean. It multiplies the the slab temperature by the heat capacity, density, and depth.\n\n\n\n\n\nInterfacer.get_field(sim::PrescribedIceSimulation, ::Val{:energy})\n\nExtension of Interfacer.get_field to get the energy of the ocean. It multiplies the the slab temperature by the heat capacity, density, and depth.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.update_field!","page":"Interfacer","title":"ClimaCoupler.Interfacer.update_field!","text":"update_field!(::AbstractAtmosSimulation, ::Val, _...)\n\nDefault functions for updating fields at each timestep in an atmosphere component model simulation. This should be extended by component models. If it isn't extended, the field won't be updated and a warning will be raised.\n\n\n\n\n\nupdate_field!(::AbstractSurfaceSimulation, ::Val, _...)\n\nDefault functions for updating fields at each timestep in an atmosphere component model simulation. This should be extended by component models. If it isn't extended, the field won't be updated and a warning will be raised.\n\n\n\n\n\nupdate_field!(sim::AbstractSurfaceStub, ::Val{:area_fraction}, field::CC.Fields.Field)\n\nUpdates the specified value in the cache of SurfaceStub.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractSlabplanetSimulationMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractSlabplanetSimulationMode","text":"AbstractSlabplanetSimulationMode\n\nAn abstract type representing a simulation mode for slabplanet models. Slabplanet simulations are more idealized than the AMIP configuration, but provide valuable insight about conservation and individual model behavior.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AMIPMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.AMIPMode","text":"AMIPMode\n\nAn abstract type representing the AMIP simulation mode. It runs a ClimaAtmos.jl atmosphere model, ClimaLand.jl bucket land model, a prescribed ocean model, and a simple thermal sea ice model.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SubseasonalMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.SubseasonalMode","text":"SubseasonalMode\n\nAn abstract type representing the subseasonal simulation mode. This mode is similar to AMIP but uses different data sources and initialization pathways tailored for subseasonal runs.\n\nInputs are ERA5-derived netcdfs with initial conditions produced by https://github.com/CliMA/WeatherQuest. Given start_date (YYYYMMDD) and directory era5_initial_condition_dir, filenames containing the initial conditions are inferred as:\n\nsst_processed_YYYYMMDD_0000.nc (variable SST)\nsic_processed_YYYYMMDD_0000.nc (variable SEAICE)\nLand IC (integrated land): era5_land_processed_YYYYMMDD_0000.nc, with fields\nskt (K), tsn (K),swe (m), swvl (m^3/m^3), si (m^3/m^3), sie (J/m^3), stl (K)\nLand IC (bucket land): era5_bucket_processed_YYYYMMDD_0000.nc, with fields\nW (m), Ws (m), S (m), T (K), tsn (K), skt (K); dims (lat, lon)\nAlbedo (optional, when bucket_albedo_type: \"era5\"): albedo_processed_YYYYMMDD_0000.nc, with fields\nsw_alb_clr (clear-sky surface albedo, fraction 0-1); dims (time, lat, lon)\n\nand are used to initialize the coupler components.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SlabplanetMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.SlabplanetMode","text":"SlabplanetMode\n\nAn abstract type representing the slabplanet simulation mode with a ClimaAtmos.jl atmosphere model, a ClimaLand.jl bucket land model, a thermal slab ocean model, and no sea ice model. Instead of using a sea ice model, the ocean is evaluated in areas that would be covered in ice.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SlabplanetAquaMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.SlabplanetAquaMode","text":"SlabplanetAquaMode\n\nAn abstract type representing the slabplanet simulation mode with a ClimaAtmos.jl atmosphere model, and only once surface model, a thermal slab ocean model, which is evaluated over the entire surface. There are no land or sea ice models.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SlabplanetTerraMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.SlabplanetTerraMode","text":"SlabplanetTerraMode\n\nAn abstract type representing the slabplanet simulation mode with a ClimaAtmos.jl atmosphere model, and only once surface model, a ClimaLand.jl bucket land model, which is evaluated over the entire surface. There are no ocean or sea ice models.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.set_cache!","page":"Interfacer","title":"ClimaCoupler.Interfacer.set_cache!","text":"Interfacer.set_cache!(sim::ClimaAtmosSimulation, csf)\n\nSet cache variables that cannot be initialized before the initial exchange. Radiation must be called here because it requires the surface model initial temperatures, which are set in the atmosphere during the initial exchange. Any other callbacks which modify the cache should be called here as well.\n\nThis function does not set all the cache variables, because many are computed as part of the tendendencies.\n\n\n\n\n\nInterfacer.set_cache!(sim::BucketSimulation, csf)\n\nSet cache variables that cannot be initialized before the initial exchange. This must be called after radiation, so that p.drivers is filled with the initial radiation fluxes, and these can be propagated to the rest of the cache (e.g. in canopy radative transfer).\n\nThis function does not set all the cache variables, because many are computed as part of the tendendencies.\n\n\n\n\n\nInterfacer.set_cache!(sim::ClimaLandSimulation, csf)\n\nSet cache variables that cannot be initialized before the initial exchange. This must be called after radiation, so that p.drivers is filled with the initial radiation fluxes, and these can be propagated to the rest of the cache (e.g. in canopy radative transfer).\n\nThis function does not set all the cache variables, because many are computed as part of the tendendencies.\n\n\n\n\n\nset_cache!(sim::AbstractComponentSimulation, csf)\n\nPerform any initialization of the component model cache that must be done after the initial exchange. This is not required to be extended, but may be necessary for some models.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.remap","page":"Interfacer","title":"ClimaCoupler.Interfacer.remap","text":"remap(target_space, source_field)\n\nRemap the given source_field onto the target_space. Note that if the field is already on the target space or a compatible one (e.g. another instance of the same space), it is returned unchanged. Users should use caution in modifying the returned field in this case.\n\nThis is a convenience wrapper around remap! that allocates the output field.\n\nNon-ClimaCore fields should provide a method to this function.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.remap!","page":"Interfacer","title":"ClimaCoupler.Interfacer.remap!","text":"remap!(target_field, source_field)\n\nRemap the given source_field onto the target_field. This is the core non-allocating implementation.\n\nNon-ClimaCore fields should provide a method to this function.\n\nNote that this method has a lot of allocations and is not efficient.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.boundary_space","page":"Interfacer","title":"ClimaCoupler.Interfacer.boundary_space","text":"boundary_space(sim::CoupledSimulation)\n\nReturn the ClimaCore.Field over which the exchange fields are defined.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.get_atmos_height_delta","page":"Interfacer","title":"ClimaCoupler.Interfacer.get_atmos_height_delta","text":"get_atmos_height_delta(height_int, height_sfc)\n\nReturn a Field of the height delta between the atmosphere bottom cell center and bottom face, defined on the boundary space. This is used to compute turbulent fluxes.\n\nSince the atmospheric height is defined on centers, we need to copy the values onto the boundary space to be able to subtract the surface elevation. This pattern is not reliable and should not be reused.\n\nNote this function allocates a new field, and the atmosphere heights won't change during a simulation, so it should only be called at initialization.\n\nArguments\n\ncsf: [NamedTuple] containing coupler fields.\n\nReturns\n\n[CC.Fields.Field] defined on the boundary space containing the height delta.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#Interfacer-Internal-Functions-and-Types","page":"Interfacer","title":"Interfacer Internal Functions and Types","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"    Interfacer.AbstractSimulation\n    Interfacer.AbstractSimulationMode","category":"page"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractSimulation","text":"AbstractSimulation\n\nAn abstract super-type representing a simulation.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractSimulationMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractSimulationMode","text":"AbstractSimulationMode\n\nAn abstract type representing a simulation mode.\n\n\n\n\n\n","category":"type"},{"location":"generated/sea_breeze/run/#Coupled-Sea-Breeze","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"","category":"section"},{"location":"generated/sea_breeze/run/#Overview","page":"Coupled Sea Breeze","title":"Overview","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"This sea breeze simulation consists of an atmosphere above ocean and land thermal slabs. The difference in heating between the land and ocean components drives circulation: cool ocean air flows towards the land at the surface while warm air over land rises and flows over the ocean.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"In this tutorial we demonstrate the coupling of three component models (atmosphere, ocean, and land) to drive the sea breeze. The primary parts of the ClimaCoupler interface are used and discussed.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Load utilities for running coupled simulation","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"include(\"../CoupledSims/coupled_sim.jl\")\n\n\n\n","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Set random seed for reproducibility, rand is called in initseabreeze2d in atmosrhs","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Random.seed!(1234)","category":"page"},{"location":"generated/sea_breeze/run/#Model-Initialization","page":"Coupled Sea Breeze","title":"Model Initialization","text":"","category":"section"},{"location":"generated/sea_breeze/run/#Component-Models","page":"Coupled Sea Breeze","title":"Component Models","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Component models are the building blocks of coupled models. They are often developed independently from one another and can be executed by themselves as \"standalone\" simulations. The coupler is used to combine these components into coupled simulations. Importantly, coupled simulations can re-use tendency methods developed for standalone simulations, maximizing code reuse and minimizing the necessary code that must be specialized for a coupled run–only special boundary conditions must be written. This is achieved by multiple dispatch, where methods that deal with boundaries dispatch off of a coupled boundary type. Here, the atmosphere has special boundary conditions for coupling while the ocean and land tendencies are unaltered. See the atmospheric model page for more details.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"In a more mature CliMA ecosystem, the following include statements would be replaced by using statements for the relevant component packages.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"include(\"atmos_rhs.jl\")\ninclude(\"ocean_rhs.jl\")\ninclude(\"land_rhs.jl\")\n\n# model parameters\nconst atm_T_ini = FT(270.0)\nconst MSLP = FT(1e5)\nconst grav = FT(9.8)\nconst R_d = FT(287.058)\nconst γ = FT(1.4)\nconst C_p = FT(R_d * γ / (γ - 1))\nconst C_v = FT(R_d / (γ - 1))\nconst R_m = R_d\ncpl_parameters = (\n    # atmos parameters\n    atm_μ = FT(0.0001), # diffusion coefficient\n    atm_T_top = FT(280.0), # fixed temperature at the top of the domain_atm\n    atm_T_ini = atm_T_ini, # initial condition of at temperature (isothermal) [K]\n    MSLP = MSLP, # mean sea level pressure\n    grav = grav, # gravitational constant\n    R_d = R_d, # R dry (gas constant / mol mass dry air)\n    γ = γ, # heat capacity ratio\n    C_p = C_p, # heat capacity at constant pressure\n    C_v = C_v, # heat capacity at constant volume\n    R_m = R_m, # moist R, assumed to be dry\n    # land slab parameters\n    lnd_h = FT(0.5), # depth of slab layer [m]\n    lnd_ρ = FT(1500), # density [kg m^-3]\n    lnd_c = FT(800), # specific heat [J K^-1 kg^-1]\n    lnd_T_ini = FT(260.0), # initial condition of at temperature (isothermal) [K]\n    # ocean slab parameters\n    ocn_h = FT(0.5), # depth of slab layer [m]\n    ocn_ρ = FT(1025), # density [kg m^-3]\n    ocn_c = FT(3850), # specific heat [J K^-1 kg^-1]\n    ocn_T_ini = FT(260.0), # initial condition of at temperature (isothermal) [K]\n    # coupling parameters\n    C_H = FT(0.0015),\n)\n\n# DSS callback\nfunction make_dss_func()\n    function _dss!(x::CC.Fields.Field)\n        CC.Spaces.weighted_dss!(x)\n    end\n    function _dss!(::Any)\n        nothing\n    end\n    dss_func(Y, t, integrator) = foreach(_dss!, CC.Fields._values(Y))\n    return dss_func\nend\ndss_func = make_dss_func()\ndss_callback = DiffEqCallbacks.FunctionCallingCallback(dss_func, func_start = true)","category":"page"},{"location":"generated/sea_breeze/run/#Initialization","page":"Coupled Sea Breeze","title":"Initialization","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"The coupled simulation synchronizes the component models at a coupling time step, Δt_cpl. Within that step, components may substep - each component specifies a number of substeps to take within Δt_cpl: atm_nsteps, ocn_nsteps, lnd_nsteps.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Component model states are initialized via the initialization methods each component would use in standalone mode. These states will be modified to reflect the full coupled system before executing the simulation.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"@info \"Init Models and Maps\"\n\nt_start, t_end = (0.0, 1e4)\nΔt_coupled = 0.1\nsaveat = collect(t_start:10.0:t_end)\natm_nsteps, ocn_nsteps, lnd_nsteps = (5, 1, 1)\n\n# Initialize Models\natm_Y_default, atm_bc, atm_domain = atm_init(\n    xmin = -500,\n    xmax = 500,\n    zmin = 0,\n    zmax = 1000,\n    npoly = 4,\n    helem = 20,\n    velem = 20,\n    bc = (ρθ = (bottom = CoupledFlux(), top = ZeroFlux()),),\n)\n\nocn_Y_default, ocn_domain = ocn_init(xmin = -500, xmax = 0, helem = 10, npoly = 0)\n\nlnd_Y_default, lnd_domain = lnd_init(xmin = 0, xmax = 500, helem = 10, npoly = 0)","category":"page"},{"location":"generated/sea_breeze/run/#Remapping","page":"Coupled Sea Breeze","title":"Remapping","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Because models may live on different grids, remapping is necessary at the boundaries. Maps between coupled components must be constructed for each interacting pair. Remapping utilities are imported from ClimaCore.Operators.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"atm_boundary = CC.Spaces.level(atm_domain.hv_face_space, CC.Utilities.PlusHalf(0))\n\nmaps = (\n    atmos_to_ocean = CC.Operators.LinearRemap(ocn_domain, atm_boundary),\n    atmos_to_land = CC.Operators.LinearRemap(lnd_domain, atm_boundary),\n    ocean_to_atmos = CC.Operators.LinearRemap(atm_boundary, ocn_domain),\n    land_to_atmos = CC.Operators.LinearRemap(atm_boundary, lnd_domain),\n)\n\n# initialize coupling fields\natm_T_sfc =\n    CC.Operators.remap(maps.ocean_to_atmos, ocn_Y_default.T_sfc) .+\n    CC.Operators.remap(maps.land_to_atmos, lnd_Y_default.T_sfc) # masked arrays; regrid to atm grid\natm_F_sfc = CC.Fields.zeros(atm_boundary)\nocn_F_sfc = CC.Fields.zeros(ocn_domain)\nlnd_F_sfc = CC.Fields.zeros(lnd_domain)","category":"page"},{"location":"generated/sea_breeze/run/#Simulations","page":"Coupled Sea Breeze","title":"Simulations","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Each component is wrapped as a Sim, which contains both the model (tendency) and the time-stepping information (solver, step size, etc). Sims are the standard structures that the coupler works with, enabling dispatch of coupler methods. Here, we create three simulations: AtmosSim, OceanSim, and LandSim.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"atm_Y =\n    CC.Fields.FieldVector(Yc = atm_Y_default.Yc, ρw = atm_Y_default.ρw, F_sfc = atm_F_sfc)\natm_p = (cpl_p = cpl_parameters, T_sfc = atm_T_sfc, bc = atm_bc)\natmos = AtmosSim(\n    atm_Y,\n    t_start,\n    Δt_coupled / atm_nsteps,\n    t_end,\n    CTS.RK4(),\n    atm_p,\n    saveat,\n    dss_callback,\n)\n\nocn_Y = CC.Fields.FieldVector(T_sfc = ocn_Y_default.T_sfc)\nocn_p = (cpl_parameters, F_sfc = ocn_F_sfc)\nocean = OceanSim(ocn_Y, t_start, Δt_coupled / ocn_nsteps, t_end, CTS.RK4(), ocn_p, saveat)\n\nlnd_Y = CC.Fields.FieldVector(T_sfc = lnd_Y_default.T_sfc)\nlnd_p = (cpl_parameters, F_sfc = lnd_F_sfc)\nland = LandSim(lnd_Y, t_start, Δt_coupled / lnd_nsteps, t_end, CTS.RK4(), lnd_p, saveat)","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Additionally, we create a coupled simulation that contains the component simulations and the coupled time-stepping information.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"struct AOLCoupledSim{A <: AtmosSim, O <: OceanSim, L <: LandSim, C <: CouplerState} <:\n       AbstractCoupledSim\n    # Atmosphere Simulation\n    atmos::A\n    # Ocean Simulation\n    ocean::O\n    # Land Simulation\n    land::L\n    # Coupler storage\n    coupler::C\nend","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"step! is a key method within the Sims interface. It advances a simulation to the specified t_stop, with that simulation advancing by its own internal step size to reach the specified time. Each simulation type should specify its own step method, allowing components to have different time integration backends. Here, all components are using SciMLBase integrators and can share the same step! method.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"function step!(sim::AbstractSim, t_stop)\n    Δt = t_stop - sim.integrator.t\n    SciMLBase.step!(sim.integrator)\nend","category":"page"},{"location":"generated/sea_breeze/run/#The-Coupler","page":"Coupled Sea Breeze","title":"The Coupler","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"The CouplerState is a coupling struct used to store pointers or copies of the shared boundary information. All components are coupled by updating or accessing data in this CouplerState; component models do not directly interface with one another, only through the coupler.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"After creating the CouplerState object, coupled fields can be registered index the coupler via the coupler_add_field! method. This field is then accessible by coupler_get methods and can be updated via the coupler_put! methods.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Similarly, the coupler_add_map! method registers remapping operators in the coupler. To provide automatic remapping, there is a strict name convention for remap operators: a map from SimA to SimB (where ClimaCoupler.name returns :simA and :simB, respectively) must be named simA_to_simB so that the correct operator can be used.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Here, the models are coupled through heat transfer at the surface. This heat flux is computed by a bulk formula:","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"F_sfc = c_p rho_1 C_H u_1 (theta_sfc - theta_atm1)","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"where theta_sfc is the potential temperature at the land or ocean surface, theta_atm1 is the potential temperature at the lowest atmospheric level, c_p is the specific heat, C_H = 00015 is the bulk transfer coefficient for sensible heat, and u_1 is the near-surface atmospheric wind speed. We assume that the potential temperature is defined with respect to the surface pressure, so that theta_sfc = T_sfc.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"coupler = CouplerState(Δt_coupled)\ncoupler_add_field!(coupler, :T_sfc_ocean, ocean.integrator.u.T_sfc; write_sim = ocean)\ncoupler_add_field!(coupler, :T_sfc_land, land.integrator.u.T_sfc; write_sim = land)\ncoupler_add_field!(coupler, :F_sfc, atmos.integrator.u.F_sfc; write_sim = atmos)\nfor (name, map) in pairs(maps)\n    coupler_add_map!(coupler, name, map)\nend\n\nsim = AOLCoupledSim(atmos, ocean, land, coupler)","category":"page"},{"location":"generated/sea_breeze/run/#Coupled-Time-Integration","page":"Coupled Sea Breeze","title":"Coupled Time Integration","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Finally, the execution sequence of the component models must be specified. This is currently done explicitly with a combination of step!, coupler_pull!, and coupler_push! methods. The coupler_pull! and coupler_push! methods receive and send coupled field info from the coupler, respectively. They must be written for each component simulation, and are simply collections of coupler_get and coupler_put! methods for each component.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Here, the atmosphere steps forward first and then sends updated fields to the coupler. The ocean and land (which are not coupled to each other) then retreive the updated coupled information, advance and send their own updates to the coupler.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Because the models exchange fluxes only at the coupled timestep, the surface flux is accumulated over the coupled time-step coupling time step, Δt_cpl","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"F_integ = int_Delta t_coupler F_sfc  dt","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"where  F_integ has units of J m^-2.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"function cpl_run(simulation::AOLCoupledSim)\n    @info \"Run model\"\n    (; atmos, ocean, land, coupler) = simulation\n    Δt_coupled = coupler.Δt_coupled\n    # coupler stepping\n    for t in ((t_start + Δt_coupled):Δt_coupled:t_end)\n        # Atmos\n        coupler_pull!(atmos, coupler)\n        step!(atmos, t)\n        coupler_push!(coupler, atmos)\n\n        # Ocean\n        coupler_pull!(ocean, coupler)\n        step!(ocean, t)\n        coupler_push!(coupler, ocean)\n\n        # Land\n        coupler_pull!(land, coupler)\n        step!(land, t)\n        coupler_push!(coupler, land)\n    end\n    @info \"Simulation Complete\"\nend\n\n# Run simulation\ncpl_run(sim)","category":"page"},{"location":"generated/sea_breeze/run/#References","page":"Coupled Sea Breeze","title":"References","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Antonelli & Rotunno 2007","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"# Post-processing\n","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"JLD2.save(joinpath(path, \"lastsim.jld2\"), \"coupledsim\", sim) #hide","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Plot atmospheric potential temperature [K] throughout the simulation","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"theta_fig = Makie.Figure();\ntheta_ax = Makie.Axis(theta_fig[1, 1])","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"initial plot to setup axis and make consistent levels","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"theta_plot = ClimaCoreMakie.fieldcontourf!(theta_ax, sol.u[end].Yc.ρθ ./ sol.u[end].Yc.ρ)\ntheta_cb = Makie.Colorbar(theta_fig[1, 2], theta_plot)\ntheta_levels =\n    [k for k in range(theta_cb.limits[][1], theta_cb.limits[][2], theta_plot.levels[])]\nMakie.record(theta_fig, joinpath(path, \"theta.mp4\"), 1:length(sol.u); framerate = 20) do i\n    ClimaCoreMakie.fieldcontourf!(\n        theta_ax,\n        sol.u[i].Yc.ρθ ./ sol.u[i].Yc.ρ,\n        levels = theta_levels,\n    )\nend\n","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Plot atmospheric vertical velocity [m/s] throughout the simulation","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"vel_w_fig = Makie.Figure();\nvel_w_ax = Makie.Axis(vel_w_fig[1, 1])","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"initial plot to setup axis and make consistent levels","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"vel_w_plot =\n    ClimaCoreMakie.fieldcontourf!(vel_w_ax, If2c.(sol.u[end].ρw) ./ sol.u[end].Yc.ρ)\nvel_w_cb = Makie.Colorbar(vel_w_fig[1, 2], vel_w_plot)\nvel_w_levels =\n    [k for k in range(vel_w_cb.limits[][1], vel_w_cb.limits[][2], vel_w_plot.levels[])]\nMakie.record(vel_w_fig, joinpath(path, \"vel_w.mp4\"), 1:length(sol.u); framerate = 20) do i\n    ClimaCoreMakie.fieldcontourf!(\n        vel_w_ax,\n        If2c.(sol.u[i].ρw) ./ sol.u[i].Yc.ρ,\n        levels = vel_w_levels,\n    )\nend","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Plot atmospheric longitudinal velocity [m/s] throughout the simulation","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"vel_u_fig = Makie.Figure();\nvel_u_ax = Makie.Axis(vel_u_fig[1, 1])","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"initial plot to setup axis and make consistent levels","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"vel_u_plot = ClimaCoreMakie.fieldcontourf!(vel_u_ax, sol.u[end].Yc.ρuₕ ./ sol.u[end].Yc.ρ)\nvel_u_cb = Makie.Colorbar(vel_u_fig[1, 2], vel_u_plot)\nvel_u_levels =\n    [k for k in range(vel_u_cb.limits[][1], vel_u_cb.limits[][2], vel_u_plot.levels[])]\nMakie.record(vel_u_fig, joinpath(path, \"vel_u.mp4\"), 1:length(sol.u); framerate = 20) do i\n    ClimaCoreMakie.fieldcontourf!(\n        vel_u_ax,\n        sol.u[i].Yc.ρuₕ ./ sol.u[i].Yc.ρ,\n        levels = vel_u_levels,\n    )\nend","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"This page was generated using Literate.jl.","category":"page"},{"location":"leaderboard/#Leaderboard","page":"Leaderboard","title":"Leaderboard","text":"","category":"section"},{"location":"leaderboard/#AMIP-Driver","page":"Leaderboard","title":"AMIP Driver","text":"","category":"section"},{"location":"leaderboard/#Add-a-new-variable-to-compare-against-observations","page":"Leaderboard","title":"Add a new variable to compare against observations","text":"","category":"section"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"Computing errors against observations are all contained in the leaderboard folder. The files in the leaderboard folder are data_sources.jl and leaderboard.jl. Loading and preprocessing variables of interest are done in data_sources.jl and computing the errors and plotting are done in leaderboard.jl. To add a new variable, you ideally only need to modify data_sources.jl.","category":"page"},{"location":"leaderboard/#Add-a-new-3D-variable-to-the-bias-plots","page":"Leaderboard","title":"Add a new 3D variable to the bias plots","text":"","category":"section"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"If you want to add a new 3D variable defined over latitude, longitude, and time to the bias plots, you add the variable to sim_var_dict, obs_var_dict, compare_vars_biases_groups, and optionally compare_vars_biases_plot_extrema. The variables sim_var_dict, obs_var_dict, compare_vars_biases_groups, compare_vars_biases_plot_extrema are in the function get_sim_var_dict, get_obs_var_dict, get_compare_vars_biases_groups, and get_compare_vars_biases_plot_extrema respectively.","category":"page"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"The dictionaries sim_var_dict and obs_var_dict map short names to an anonymous function that returns a OutputVar. Both dictionaries must use the same short names as the keys so that the right simulation and observational data are compared.","category":"page"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"tip: Preprocessing\nObservational and simulational data should be preprocessed for dates and units. When preprocessing data, we follow the convention that the first day corresponds to the monthly average for that month. For observational data, you should check the convention being followed and preprocess the dates if necessary.For obs_var_dict, the anonymous function must take in a start date. The start date is used in leaderboard.jl to adjust the seconds in the OutputVar to match between start date in the simulation data.Units should be the same between the simulation and observational data.","category":"page"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"The variable compare_vars_biases_groups is an array of arrays of short names that control which variables are plotted together. You can add the variable to an existing array or make a new array. The dictionary compare_vars_biases_plot_extrema maps short names to tuples. The dictionary sets the lower and upper bounds of the bias plots.","category":"page"},{"location":"leaderboard/#Add-a-new-variable-to-the-leaderboard","page":"Leaderboard","title":"Add a new variable to the leaderboard","text":"","category":"section"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"If you want to add a new variable to the leaderboard, you add the variable to rmse_var_names and rmse_var_dict. The array rmse_var_names is a list of short names. The dictionary rmse_var_dict maps short name to RMSEVariable. A RMSEVariable must be initialized for each variable of interest. The CliMA model is added with units to the RMSEVariable. It is assumed that the RMSEVariable contains only the columns \"DJF\", \"MAM\", \"JJA\", \"SON\", and \"ANN\" in that order. The file leaderboard.jl will load the appropriate data into the RMSEVariable.","category":"page"},{"location":"leaderboard/#Add-a-new-variable-to-compare-against-observations-in-pressure-coordinates","page":"Leaderboard","title":"Add a new variable to compare against observations in pressure coordinates","text":"","category":"section"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"To add a new variable, you only need to modify the variable sim_var_pfull_dict in the function get_sim_var_in_pfull_dict, the variable obs_var_dict in the function get_obs_var_in_pfull_dict, and the variable compare_vars_biases_plot_extrema in the function get_compare_vars_biases_plot_extrema_pfull. The variables and functions are defined exactly the same as their analogous versions in the section above.","category":"page"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"It is expected that the dimensions of the variables are time, latitude, longitude, and pressure in no particular order and the units for the pressure dimension is expected to be hPa.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"CurrentModule = CalibrationTools","category":"page"},{"location":"calibrationtools/#CalibrationTools","page":"CalibrationTools","title":"CalibrationTools","text":"","category":"section"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"This module contains utilities to help with setting up calibration experiments of the coupled model. These utilities are meant to be broadly useful and are not specific to one particular calibration experiment.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"note: Other helpful resources\nFor calibration, other resources that you may find helpful are the documentation for EnsembleKalmanProcesses, ClimaCalibrate, ClimaAnalysis, and the ClimaCoupler calibration experiments.","category":"page"},{"location":"calibrationtools/#Data-loading","page":"CalibrationTools","title":"Data loading","text":"","category":"section"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"note: OutputVar\nThis section assumes you are familiar with ClimaAnalysis.OutputVar.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"As of now, CalibrationTools provide a single data loader which is the ERA5DataLoader for loading preprocessed ERA5 data. This data loader automatically applies preprocessing to make it convenient to use for calibration. See the documentation for ERA5DataLoader for details on the preprocessing steps applied.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"You can retrieve a variable with get and get a set of all available preprocessed variables with available_vars.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"import ClimaCoupler: CalibrationTools\ndata_loader = CalibrationTools.ERA5DataLoader()\nCalibrationTools.available_vars(data_loader)\nvar = get(data_loader, \"rsus\");","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"In the example, we retrieve a OutputVar with the short name rsus which represents the mean surface upward short-wave radiation flux.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"note: Other data loaders\nIf you want a data loader for other data sources, then please open an issue for it!","category":"page"},{"location":"calibrationtools/#I-want-to-add-a-new-variable-to-an-existing-data-loader","page":"CalibrationTools","title":"I want to add a new variable to an existing data loader","text":"","category":"section"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"To add a new variable, you must","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"Define a mapping between the ERA5 name and CliMA name,\nDefine a preprocess function for this variable.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"To determine which variables are already available, refer to the artifact's documentation. For ERA5DataLoader we can load the variable representing mean evaporation rate or mer from the data source. We also want to give it the name er. For step 1, we add \"mer\" => \"er\" as a mapping for the data loader to recognize.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"import ClimaCoupler: CalibrationTools\ndata_loader = CalibrationTools.ERA5DataLoader()\n# ERA5_TO_CLIMA_NAMES define the existing pairings for the data loader\nera5_to_clima_names = [CalibrationTools.ERA5_TO_CLIMA_NAMES..., \"mer\" => \"er\"]\ndata_loader = CalibrationTools.ERA5DataLoader(; era5_to_clima_names)","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"For the second step, we define a preprocessing function specific to the variable.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"note: Preprocessing functions\nSee ClimaAnalysis documentation for available transformations on OutputVars.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"In our example, no preprocessing is applied.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"CalibrationTools.preprocess(::CalibrationTools.ERA5DataLoader, var, ::Val{:er}) = var\nnothing # hide","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"Now, you can use get to retrieve the OutputVar with the short name  \"mer\"`.","category":"page"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"data_loader = CalibrationTools.ERA5DataLoader(; era5_to_clima_names)\nget(data_loader, \"er\")\nnothing # hide","category":"page"},{"location":"calibrationtools/#CalibrationTools-API","page":"CalibrationTools","title":"CalibrationTools API","text":"","category":"section"},{"location":"calibrationtools/","page":"CalibrationTools","title":"CalibrationTools","text":"CalibrationTools.CalibrateConfig\nCalibrationTools.CalibrateConfig()\nCalibrationTools.ERA5DataLoader\nCalibrationTools.ERA5DataLoader()\nCalibrationTools.available_vars\nCalibrationTools.get(loader::CalibrationTools.ERA5DataLoader, short_name::String)","category":"page"},{"location":"calibrationtools/#ClimaCoupler.CalibrationTools.CalibrateConfig","page":"CalibrationTools","title":"ClimaCoupler.CalibrationTools.CalibrateConfig","text":"struct CalibrateConfig{SPINUP <: Dates.Period, EXTEND <: Dates.Period}\n\nA configuration struct for keeping track of multiple fields that are of interest to a user running calibration, or that are needed in multiple places (e.g., for ensemble members and generating observations).\n\n\n\n\n\n","category":"type"},{"location":"calibrationtools/#ClimaCoupler.CalibrationTools.CalibrateConfig-Tuple{}","page":"CalibrationTools","title":"ClimaCoupler.CalibrationTools.CalibrateConfig","text":"CalibrateConfig(;\n    config_file,\n    short_names::Vector{String},\n    minibatch_size::Integer,\n    n_iterations::Integer,\n    sample_date_ranges,\n    extend::Dates.Period,\n    spinup::Dates.Period,\n    output_dir,\n    rng_seed = 42,\n)\n\nInitializes a CalibrateConfig which contains values needed in multiple places during calibration.\n\nKeyword arguments\n\nconfig_file: Configuration file to use for ClimaCoupler simulation.\nshort_names: Short names of the observations.\nminibatch_size: The size of the minibatch for each iteration.\nn_iterations: The number of iterations to run the calibration for.\nsample_date_ranges: The date ranges for each sample. The dates should be the same as found in the time series data of the observations.\nextend: The amount of time to run the simulation after the end date determined by sample_date_ranges. For seasonal averages, extend should be Dates.Month(3) and for monthly averages, extend should be Dates.Month(1).\nspinup: The amount of time to run the simulation before the start date determined by sample_date_ranges.\noutput_dir: The location to save the calibration at.\nrng_seed: An integer to ensure that calibration runs with the same settings are the same.\n\n\n\n\n\n","category":"method"},{"location":"calibrationtools/#ClimaCoupler.CalibrationTools.ERA5DataLoader","page":"CalibrationTools","title":"ClimaCoupler.CalibrationTools.ERA5DataLoader","text":"ERA5DataLoader\n\nA struct for loading preprocessed ERA5 data as OutputVars.\n\n\n\n\n\n","category":"type"},{"location":"calibrationtools/#ClimaCoupler.CalibrationTools.ERA5DataLoader-Tuple{}","page":"CalibrationTools","title":"ClimaCoupler.CalibrationTools.ERA5DataLoader","text":"ERA5DataLoader(; era5_to_clima_names = ERA5_TO_CLIMA_NAMES)\n\nConstruct a data loader which you can load preprocessed ERA5 monthly time-averaged data in OutputVar, where\n\nthe short name, sign of the data, and units match CliMA conventions\nthe latitudes are shifted to be -180 to 180 degrees,\nthe times are at the start of the time period (e.g. the time average of January is on the first of January instead of January 15th),\nunits match the variables in the output of the CliMA diagnostics.\n\nThe ERA5 data comes from the era5_monthly_averages_surface_single_level_1979_2024 artifact. See ClimaArtifacts for more information about this artifact.\n\nThe keyword argument era5_to_clima_names is a vector of pairs mapping ERA5 name to CliMA name.\n\n\n\n\n\n","category":"method"},{"location":"calibrationtools/#ClimaCoupler.CalibrationTools.available_vars","page":"CalibrationTools","title":"ClimaCoupler.CalibrationTools.available_vars","text":"available_vars(data_loader::ERA5DataLoader)\n\nReturn the available preprocessed variables in data_loader.\n\n\n\n\n\n","category":"function"},{"location":"calibrationtools/#Base.get-Tuple{ClimaCoupler.CalibrationTools.ERA5DataLoader, String}","page":"CalibrationTools","title":"Base.get","text":"get(loader::ERA5DataLoader, short_name)\n\nGet the preprocessed OutputVar with the name short_name from the ERA5 dataset.\n\n\n\n\n\n","category":"method"},{"location":"fluxcalculator/#FluxCalculator","page":"FluxCalculator","title":"FluxCalculator","text":"","category":"section"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"This module contains the infrastructure to compute turbulent fluxes.","category":"page"},{"location":"fluxcalculator/#How-are-fluxes-computed?","page":"FluxCalculator","title":"How are fluxes computed?","text":"","category":"section"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"The key function that computes surface fluxes is FluxCalculator.turbulent_fluxes!. This function computes turbulent fluxes and ancillary quantities, such as the Obukhov length, using SurfaceFluxes.jl. Generally, this function is called at the end of each coupling step.","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"All the quantities computed in turbulent_fluxes! are calculated separately for each surface model using the FluxCalculator.compute_surface_fluxes! function. This function can be extended by component models if they need specific type of flux calculation, and a default is provided for models that can use the standard flux calculation.","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"The default method of FluxCalculator.compute_surface_fluxes!, in turn, calls FluxCalculator.get_surface_fluxes. This function uses a thermal state obtained by using the model surface temperature, extrapolates atmospheric density adiabatically to the surface, and with the surface humidity (if available, if not, assuming a saturation specific humidity for liquid phase). compute_surface_fluxes! also updates the component internal fluxes fields via FluxCalculator.update_turbulent_fluxes!, and adds the area-weighted contribution from this component model to the CoupledSimulation fluxes fields.","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"Any extension of FluxCalculator.compute_surface_fluxes! for a particular surface model is also expected to update both the component models' internal fluxes and the CoupledSimulation object's fluxes fields.","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"FluxCalculator.compute_surface_fluxes! sets:","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"the flux of momenta, F_turb_ρτxz, F_turb_ρτyz;\nthe flux of energy due to latent heat, F_lh;\nthe flux of energy due to sensible heat, F_sh;\nthe flux of moisture, F_turb_moisture;\nthe Obukhov length, L_MO;\nthe buoyancy flux, buoyancy_flux;\nthe roughness lengths for momentum and buoyancy, z0m and z0b;\nthe frictional velocity ustar.","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"note: Note\nFluxCalculator.compute_surface_fluxes! always returns the area weighted sum, even if this is not necessarily the most meaningful operation for a given quantity (e.g., for the Obukhov length). This can be improved in the future, if you know how, please open an issue.","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"Note also that FluxCalculator.turbulent_fluxes! only computes turbulent fluxes, not radiative fluxes. Currently, these are computed within the atmospheric model.","category":"page"},{"location":"fluxcalculator/#FluxCalculator-API","page":"FluxCalculator","title":"FluxCalculator API","text":"","category":"section"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"    FluxCalculator.turbulent_fluxes!\n    FluxCalculator.compute_surface_fluxes!\n    FluxCalculator.get_surface_fluxes\n    FluxCalculator.update_turbulent_fluxes!","category":"page"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.turbulent_fluxes!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.turbulent_fluxes!","text":"turbulent_fluxes!(cs::CoupledSimulation)\nturbulent_fluxes!(fields, model_sims, thermo_params)\n\nCompute turbulent fluxes and associated quantities. Store the results in fields as area-weighted sums.\n\nThis function uses SurfaceFluxes.jl under the hood.\n\nArgs:\n\ncsf: [Field of NamedTuple] containing coupler fields.\nmodel_sims: [NamedTuple] containing AbstractComponentSimulations.\nthermo_params: [TD.Parameters.ThermodynamicsParameters] the thermodynamic parameters.\n\nTODO:\n\ngeneralize interface for regridding and take land state out of atmos's integrator.p\nadd flux accumulation\nadd flux bounds\n\n(NB: Radiation surface fluxes are calculated by the atmosphere.)\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.compute_surface_fluxes!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.compute_surface_fluxes!","text":"compute_surface_fluxes!(csf, sim::BucketSimulation, atmos_sim, thermo_params)\n\nThis function computes surface fluxes between the bucket simulation and the atmosphere.\n\nUpdate the input coupler surface fields csf in-place with the computed fluxes for this model. These are then summed using area-weighting across all surface models to get the total fluxes. Fluxes where the area fraction is zero are set to zero.\n\nCurrently, this calculation is done on the land surface space, and the computed fluxes are remapped onto the coupler boundary space as the coupler fields are updated. In the future, we may compute fluxes in the bucket model's internal step! function.\n\nArguments\n\ncsf: [CC.Fields.Field] containing a NamedTuple of turbulent flux fields: F_turb_ρτxz, F_turb_ρτyz, F_lh, F_sh, F_turb_moisture.\nsim: [BucketSimulation] the bucket simulation to compute fluxes for.\natmos_sim: [Interfacer.AbstractAtmosSimulation] the atmosphere simulation to compute fluxes with.\nthermo_params: [ClimaParams.ThermodynamicParameters] the thermodynamic parameters for the simulation.\n\n\n\n\n\ncompute_surface_fluxes!(csf, sim::ClimaLandSimulation, atmos_sim, thermo_params)\n\nThis function computes surface fluxes between the integrated land model simulation and the atmosphere.\n\nUpdate the input coupler surface fields csf in-place with the computed fluxes for this model. These are then summed using area-weighting across all surface models to get the total fluxes. Fluxes where the area fraction is zero are set to zero.\n\nThe integrated land model requires fluxes to be computed implicitly, so they are computed in the land model's internal step! function, where they can be solved for at the same time as canopy temperature. As a result, this function does not actually compute the fluxes. However, it does access them from the land cache, combine them to get the total fluxes for the integrated land model, and update the coupler fields in-place.\n\nBecause the integrated land model is composed of multiple sub-components, the fluxes are computed for each sub-component and then combined here to get the total for this model. The land model cache contains the computed fluxes for each sub-component.\n\nArguments\n\ncsf: [CC.Fields.Field] containing a NamedTuple of turbulent flux fields: F_turb_ρτxz, F_turb_ρτyz, F_lh, F_sh, F_turb_moisture.\nsim: [ClimaLandSimulation] the integrated land simulation to compute fluxes for.\natmos_sim: [Interfacer.AbstractAtmosSimulation] the atmosphere simulation to compute fluxes with.\nthermo_params: [ClimaParams.ThermodynamicParameters] the thermodynamic parameters for the simulation.\n\n\n\n\n\ncompute_surface_fluxes!(csf, sim, atmos_sim, thermo_params)\n\nThis function computes surface fluxes between the input component model simulation and the atmosphere.\n\nUpdate the input coupler surface fields csf in-place with the computed fluxes for this model. These are then summed using area-weighting across all surface models to get the total fluxes.\n\nSince the fluxes are computed between the input model and the atmosphere, this function does nothing if called on an atmosphere model simulation.\n\nThe function for AbstractImplicitFluxSimulation is a placeholder that does nothing. Currently, the only AbstractImplicitFluxSimulation is ClimaLandSimulation, for which computesurfacefluxes! is defined in the component model. We can extend this function for other AbstractImplicitFluxSimulation in the future.\n\nArguments\n\ncsf: [CC.Fields.Field] containing a NamedTuple of turbulent flux fields: F_turb_ρτxz, F_turb_ρτyz, F_lh, F_sh, F_turb_moisture.\nsim: [Interfacer.AbstractComponentSimulation] the surface simulation to compute fluxes for.\natmos_sim: [Interfacer.AbstractAtmosSimulation] the atmosphere simulation to compute fluxes with.\nthermo_params: [TD.Parameters.ThermodynamicsParameters] the thermodynamic parameters.\n\nThe roughness model is obtained from the simulation via get_field(sim, Val(:roughness_model)). Ocean simulations return :coare3, while land and ice simulations return :constant (the default).\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.get_surface_fluxes","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.get_surface_fluxes","text":"get_surface_fluxes(inputs, surface_params::SF.Parameters.SurfaceFluxesParameters)\n\nUses SurfaceFluxes.jl to calculate turbulent surface fluxes. It should be atmos model agnostic, and columnwise. Fluxes are computed over the entire surface, even where the relevant surface model is not present.\n\nWhen available, it also computes ancillary quantities, such as the Monin-Obukov lengthscale.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.update_turbulent_fluxes!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.update_turbulent_fluxes!","text":"FluxCalculator.update_turbulent_fluxes!(sim::OceananigansSimulation, fields)\n\nUpdate the turbulent fluxes in the simulation using the values computed at this time step. These include latent heat flux, sensible heat flux, momentum fluxes, and moisture flux.\n\nRather than setting the surface fluxes and overwriting previous values, this function adds only the contributions from the turbulent fluxes. update_sim! sets the surface fluxes due to radiation and precipitation. Additional contributions may be made in ocean_seaice_fluxes!. An exception is the momentum fluxes, which are set directly here since they are not updated in update_sim!.\n\nA note on sign conventions: SurfaceFluxes and Oceananigans both use the convention that a positive flux is an upward flux. No sign change is needed during the exchange, except for moisture/salinity fluxes: SurfaceFluxes provides moisture moving from atmosphere to ocean as a negative flux at the surface, and Oceananigans represents moisture moving from atmosphere to ocean as a positive salinity flux, so a sign change is needed when we convert from moisture to salinity flux.\n\n\n\n\n\nFluxCalculator.update_turbulent_fluxes!(sim::ClimaSeaIceSimulation, fields)\n\nUpdate the turbulent fluxes in the simulation using the values stored in the coupler fields. These include latent heat flux, sensible heat flux, momentum fluxes, and moisture flux.\n\nThe input fields are already area-weighted, so there's no need to weight them again.\n\nNote that currently the moisture flux has no effect on the sea ice model, which has constant salinity.\n\nA note on sign conventions: SurfaceFluxes and ClimaSeaIce both use the convention that a positive flux is an upward flux. No sign change is needed during the exchange, except for moisture/salinity fluxes: SurfaceFluxes provides moisture moving from atmosphere to ocean as a negative flux at the surface, and ClimaSeaIce represents moisture moving from atmosphere to ocean as a positive salinity flux, so a sign change is needed when we convert from moisture to salinity flux.\n\n\n\n\n\nupdate_turbulent_fluxes!(sim::Interfacer.AbstractComponentSimulation, fields::NamedTuple)\n\nUpdates the fluxes in the simulation sim with the fluxes in fields.\n\nFor surface models, this should be the fluxes computed between the surface model and the atmosphere. For atmosphere models, this should be the area-weighted sum of fluxes across all surface models.\n\n\n\n\n\n","category":"function"},{"location":"generated/amip/run_amip/#AMIP-Driver","page":"AMIP Driver","title":"AMIP Driver","text":"","category":"section"},{"location":"generated/amip/run_amip/#Overview","page":"AMIP Driver","title":"Overview","text":"","category":"section"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"AMIP is a standard experimental protocol of the Program for Climate Model Diagnosis & Intercomparison (PCMDI). It is used as a model benchmark for the atmospheric and land model components, while sea-surface temperatures (SST) and sea-ice concentration (SIC) are prescribed using time-interpolations between monthly observed data. We use standard data files with original sources:","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"SST and SIC: https://gdex.ucar.edu/dataset/158_asphilli.html\nland-sea mask: https://www.ncl.ucar.edu/Applications/Data/#cdf","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"For more information, see the PCMDI's specifications for AMIP I and AMIP II.","category":"page"},{"location":"generated/amip/run_amip/#Running-the-AMIP-configuration","page":"AMIP Driver","title":"Running the AMIP configuration","text":"","category":"section"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"To run a coupled simulation in the default AMIP configuration, run the following command from the root directory of the repository:","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"julia --project=experiments/ClimaEarth experiments/ClimaEarth/run_amip.jl","category":"page"},{"location":"generated/amip/run_amip/#Configuration","page":"AMIP Driver","title":"Configuration","text":"","category":"section"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"You can also specify a custom configuration file to run the coupled simulation in a different setup. The configuration file should be a TOML file that overwrites the input fields specified in experiments/ClimaEarth/cli_options.jl. A set of example configuration files can be found in the config/ci_configs/ directory.","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"For example, to run the coupled simulation with a different configuration file:","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"julia --project=experiments/ClimaEarth experiments/ClimaEarth/run_amip.jl --config_file=\"path/to/config.toml\"","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"To run the coupled simulation interactively with a different configuration file, set the config_file variable in this script to be the path to that file.","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"For more details about running a coupled simulation, including how to run in a Slabplanet configuration, please see our README.md.","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"Load the necessary modules to run the coupled simulation","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"include(\"code_loading.jl\")","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"Get the configuration file from the command line (or manually set it here)","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"config_file = Input.parse_commandline(Input.argparse_settings())[\"config_file\"]","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"Set up and run the coupled simulation","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"cs = CoupledSimulation(config_file)\nrun!(cs)","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"Postprocessing","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"conservation_softfail = Input.get_coupler_config_dict(config_file)[\"conservation_softfail\"]\nrmse_check = Input.get_coupler_config_dict(config_file)[\"rmse_check\"]\npostprocess(cs; conservation_softfail, rmse_check)","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Ocean-Model","page":"Ocean Model","title":"Ocean Model","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"import DiffEqCallbacks\nimport SciMLBase\nimport ClimaCore as CC\nimport ClimaTimeSteppers as CTS","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"Load coupled simulation code","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"include(\"../CoupledSims/coupled_sim.jl\")","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Slab-Ocean-ODE","page":"Ocean Model","title":"Slab Ocean ODE","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"For our ocean component, we solve a simple slab ocean ODE just as we did for the land:","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"rho_o c_o H_o partial_t T_ocn = - F_integ  Delta t_coupler","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"where rho_o = 1025 kg m ^-3, c_o=3850 J K ^-1 kg ^-1, H_o = 100 m are the density, specific heat and depth of the ocean,\nand F_integ is the integrated surface fluxes in time.","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Model-Code","page":"Ocean Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"function ocn_rhs!(du, u, (parameters, F_accumulated), t)\n    \"\"\"\n    Slab layer equation\n        d(T_sfc)/dt = - (F_accumulated) / (h_ocn * ρ_ocn * c_ocn)\n        where\n            F_accumulated = F_integrated / Δt_coupler\n    \"\"\"\n    (; ocn_h, ocn_ρ, ocn_c) = parameters\n    (; T_sfc) = du\n\n    @. T_sfc = (-F_accumulated) / (ocn_h * ocn_ρ * ocn_c)\nend\n\n# set up domain\nfunction hspace_1D(xlim = (-π, π), npoly = 0, helem = 10)\n    FT = Float64\n\n    domain = CC.Domains.IntervalDomain(\n        CC.Geometry.XPoint{FT}(xlim[1]) .. CC.Geometry.XPoint{FT}(xlim[2]),\n        periodic = true,\n    )\n    mesh = CC.Meshes.IntervalMesh(domain; nelems = helem)\n    topology = CC.Topologies.IntervalTopology(mesh)\n\n    # Finite Volume Approximation: Gauss-Lobatto with 1pt per element\n    quad = CC.Spaces.Quadratures.GL{npoly + 1}()\n    space = CC.Spaces.SpectralElementSpace1D(topology, quad)\n\n    return space\nend\n\n# init simulation\nfunction ocn_init(; xmin = -1000, xmax = 1000, helem = 20, npoly = 0)\n\n    # construct domain spaces - get only surface layer (NB: z should be zero, not z = first central height)\n    space = hspace_1D((xmin, xmax), npoly, helem)\n    coords = CC.Fields.coordinate_field(space)\n    domain = space\n\n    # initial condition\n    T_sfc = map(coords) do coord\n        T_sfc = 257.0\n    end\n\n    # prognostic variable\n    Y = CC.Fields.FieldVector(T_sfc = T_sfc)\n\n    return Y, domain\nend","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Coupled-Ocean-Wrappers","page":"Ocean Model","title":"Coupled Ocean Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"# Ocean Simulation - Later to live in Oceananigans\nstruct OceanSim <: AbstractOceanSim\n    integrator::Any\nend\n\nfunction OceanSim(\n    Y_init,\n    t_start,\n    dt,\n    t_end,\n    timestepper,\n    p,\n    saveat,\n    callbacks = DiffEqCallbacks.CallbackSet(),\n)\n    ode_algo = CTS.ExplicitAlgorithm(timestepper)\n    ode_function = CTS.ClimaODEFunction(T_exp! = ocn_rhs!)\n\n    problem = SciMLBase.ODEProblem(ode_function, Y_init, (t_start, t_end), p)\n    ocn_integ = SciMLBase.init(\n        problem,\n        ode_algo,\n        dt = dt,\n        saveat = saveat,\n        adaptive = false,\n        callback = callbacks,\n    )\n\n    return OceanSim(ocn_integ)\nend\n\nfunction coupler_push!(coupler::CouplerState, ocean::OceanSim)\n    coupler_put!(coupler, :T_sfc_ocean, ocean.integrator.u.T_sfc, ocean)\nend\n\nfunction coupler_pull!(ocean::OceanSim, coupler::CouplerState)\n    coupler_get!(ocean.integrator.p.F_sfc, coupler, :F_sfc, ocean)\n    ocean.integrator.p.F_sfc ./= coupler.Δt_coupled\nend","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"conservation/#Conservation-Checks","page":"Conservation Checks","title":"Conservation Checks","text":"","category":"section"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"If the model is a physically closed system (e.g., in the slabplanet configuration with free slip conditions), it should conserve mass (including water), energy and momentum. The conservation checker logs global conservation.","category":"page"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"Only energy and water are currently implemented.","category":"page"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"Note that kinetic energy is not included in the calculation of the global energy, reflecting the formulation on ClimaAtmos, which assumes that kinetic energy is negligible in comparison with the moist static energy components.","category":"page"},{"location":"conservation/#ConservationChecker-API","page":"Conservation Checks","title":"ConservationChecker API","text":"","category":"section"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"ConservationChecker.EnergyConservationCheck\nConservationChecker.WaterConservationCheck\nConservationChecker.check_conservation!","category":"page"},{"location":"conservation/#ClimaCoupler.ConservationChecker.EnergyConservationCheck","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.EnergyConservationCheck","text":"EnergyConservationCheck{A} <: AbstractConservationCheck\n\nStruct of type AbstractConservationCheck containing global energy conservation logs.\n\n\n\n\n\n","category":"type"},{"location":"conservation/#ClimaCoupler.ConservationChecker.WaterConservationCheck","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.WaterConservationCheck","text":"WaterConservationCheck{A} <: AbstractConservationCheck\n\nStruct of type AbstractConservationCheck containing global water mass conservation logs.\n\n\n\n\n\n","category":"type"},{"location":"conservation/#ClimaCoupler.ConservationChecker.check_conservation!","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.check_conservation!","text":"check_conservation!(coupler_sim::Interfacer.CoupledSimulation; runtime_check = false)\n\nitertes over all specified conservation checks and returns values.\n\n\n\n\n\n    check_conservation!(\n    cc::EnergyConservationCheck,\n    coupler_sim::Interfacer.CoupledSimulation,\n    runtime_check = false,\n    )\n\ncomputes the total energy, ∫ ρe dV, of the model components of the coupled simulations and the TOA radiation, and updates cc with these values.\n\n\n\n\n\ncheck_conservation!(\ncc::WaterConservationCheck,\ncoupler_sim::Interfacer.CoupledSimulation,\nruntime_check = false,\n)\n\ncomputes the total water, ∫ ρq_tot dV, of the various components of the coupled simulations, and updates cc with the values.\n\nNote: in the future this should not use push!.\n\n\n\n\n\n","category":"function"},{"location":"simoutput/#SimOutput","page":"SimOutput","title":"SimOutput","text":"","category":"section"},{"location":"simoutput/","page":"SimOutput","title":"SimOutput","text":"The SimOutput module provides utilities for output operations including diagnostics and performance analysis.","category":"page"},{"location":"simoutput/#Diagnostics-Setup","page":"SimOutput","title":"Diagnostics Setup","text":"","category":"section"},{"location":"simoutput/","page":"SimOutput","title":"SimOutput","text":"The diagnostics setup function configures default diagnostics for AMIP simulations, which uses ClimaDiagnostics.jl to save variables throughout the course of a simulation.","category":"page"},{"location":"simoutput/","page":"SimOutput","title":"SimOutput","text":"For more information about diagnostics in ClimaCoupler, including how to customize which variables to save, how often, and with which reductions, see the Diagnostics documentation.","category":"page"},{"location":"simoutput/#Functions","page":"SimOutput","title":"Functions","text":"","category":"section"},{"location":"simoutput/","page":"SimOutput","title":"SimOutput","text":"SimOutput.diagnostics_setup","category":"page"},{"location":"simoutput/#ClimaCoupler.SimOutput.diagnostics_setup","page":"SimOutput","title":"ClimaCoupler.SimOutput.diagnostics_setup","text":"diagnostics_setup(fields, output_dir, start_date, t_start, diagnostics_dt)\n\nSet up the default diagnostics for an AMIP simulation, using ClimaDiagnostics. The diagnostics are saved to NetCDF files. Currently, this just includes a diagnostic for turbulent energy fluxes.\n\nReturn a DiagnosticsHandler object to coordinate the diagnostics.\n\n\n\n\n\n","category":"function"},{"location":"simoutput/#Benchmarking-Analysis","page":"SimOutput","title":"Benchmarking Analysis","text":"","category":"section"},{"location":"simoutput/","page":"SimOutput","title":"SimOutput","text":"The benchmark analysis functions help compare performance metrics (e.g. SYPD, or simulated years per day) between different simulation runs. This information is formatted into a table format using PrettyTables.jl, and is sent to Slack automatically each time the \"benchmarks\" buildkite pipeline is run.","category":"page"},{"location":"simoutput/#Functions-2","page":"SimOutput","title":"Functions","text":"","category":"section"},{"location":"simoutput/","page":"SimOutput","title":"SimOutput","text":"SimOutput.get_benchmark_args\nSimOutput.get_run_info\nSimOutput.append_table_data","category":"page"},{"location":"simoutput/#ClimaCoupler.SimOutput.get_benchmark_args","page":"SimOutput","title":"ClimaCoupler.SimOutput.get_benchmark_args","text":"get_benchmark_args()\n\nParse command-line arguments for the benchmarks script.\n\nReturns\n\nA dictionary of parsed command-line arguments\n\n\n\n\n\n","category":"function"},{"location":"simoutput/#ClimaCoupler.SimOutput.get_run_info","page":"SimOutput","title":"ClimaCoupler.SimOutput.get_run_info","text":"get_run_info(parsed_args, run_type)\n\nUse the input parsed_args to get the job ID and artifacts directories for the GPU run of the given run_type.\n\nrun_type must be one of \"coupled\", \"coupledio\", \"atmos\", \"atmosdiagedmf\", \"coupledprogedmfcoarse\", or \"coupledprogedmffine\".\n\n\n\n\n\n","category":"function"},{"location":"simoutput/#ClimaCoupler.SimOutput.append_table_data","page":"SimOutput","title":"ClimaCoupler.SimOutput.append_table_data","text":"append_table_data(table_data, setup_id, job_id, artifacts_dir)\n\nAppend data for a given setup to the table data.\n\n\n\n\n\n","category":"function"},{"location":"simoutput/#Simulation-and-Observation-Data","page":"SimOutput","title":"Simulation and Observation Data","text":"","category":"section"},{"location":"simoutput/","page":"SimOutput","title":"SimOutput","text":"These functions provide dictionaries mapping diagnostic variable names to preprocessed simulation and observational data for use in leaderboard comparisons. They are used by compute_leaderboard to load and prepare variables for comparison against observations.","category":"page"},{"location":"simoutput/","page":"SimOutput","title":"SimOutput","text":"For more information about adding variables to the leaderboard, see the Leaderboard documentation.","category":"page"},{"location":"simoutput/#Functions-3","page":"SimOutput","title":"Functions","text":"","category":"section"},{"location":"simoutput/","page":"SimOutput","title":"SimOutput","text":"SimOutput.get_sim_var_dict\nSimOutput.get_obs_var_dict","category":"page"},{"location":"simoutput/#ClimaCoupler.SimOutput.get_sim_var_dict","page":"SimOutput","title":"ClimaCoupler.SimOutput.get_sim_var_dict","text":"get_sim_var_dict(diagnostics_folder_path)\n\nReturn a dictionary mapping short names to OutputVar containing preprocessed simulation data. This is used by the function compute_leaderboard.\n\nTo add a variable for the leaderboard, add a key-value pair to the dictionary sim_var_dict whose key is the short name of the variable and the value is an anonymous function that returns a OutputVar. For each variable, any preprocessing should be done in the corresponding anonymous function which includes unit conversion.\n\nThe variable should have only three dimensions: latitude, longitude, and time.\n\n\n\n\n\n","category":"function"},{"location":"simoutput/#ClimaCoupler.SimOutput.get_obs_var_dict","page":"SimOutput","title":"ClimaCoupler.SimOutput.get_obs_var_dict","text":"get_obs_var_dict()\n\nReturn a dictionary mapping short names to OutputVar containing preprocessed observational data. This is used by the function compute_leaderboard.\n\nTo add a variable for the leaderboard, add a key-value pair to the dictionary obs_var_dict whose key is the short name of the variable and the value is an anonymous function that returns a OutputVar. The function must take in a start date which is used to align the times in the observational data to match the simulation data. The short name must be the same as in sim_var_dict in the function sim_var_dict. For each variable, any preprocessing is done in the corresponding anonymous function which includes unit conversion and shifting the dates.\n\nThe variable should have only three dimensions: latitude, longitude, and time.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The Plotting module provides functionality for visualizing ClimaCoupler simulation output, including diagnostic plots, visualizations for debugging, leaderboards comparing to observations, and calibration parameter plots.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"By default, the Plotting module provides stub implementations that do nothing. The actual plotting implementations are provided by the ClimaCouplerMakieExt extension when Makie.jl and related packages are available, and by ClimaCouplerCMIPMakieExt when the plotting packages and Oceananigans.jl are available.","category":"page"},{"location":"plotting/#Plotting-API","page":"Plotting","title":"Plotting API","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Plotting.postprocess\nPlotting.make_diagnostics_plots\nPlotting.make_ocean_diagnostics_plots\nPlotting.debug\nPlotting.debug_plot_fields\nPlotting.debug_plot!\nPlotting.plot_global_conservation\nPlotting.compute_leaderboard\nPlotting.compute_pfull_leaderboard","category":"page"},{"location":"plotting/#ClimaCoupler.Plotting.postprocess","page":"Plotting","title":"ClimaCoupler.Plotting.postprocess","text":"postprocess(cs; conservation_softfail = false, rmse_check = false)\n\nProcess the results after a simulation has completed, including generating plots, checking conservation, and other diagnostics. All postprocessing is performed using the root process only, if applicable.\n\nWhen conservation_softfail is true, throw an error if conservation of water and/or energy is not respected.\n\nWhen rmse_check is true, compute the RMSE against observations and test that it is below a certain threshold.\n\nThe postprocessing includes:\n\nEnergy and water conservation checks (if running SlabPlanet with checks enabled)\nAnimations (if not running in MPI)\nAMIP plots of the final state of the model\nError against observations\nOptional additional atmosphere diagnostics plots\nPlots of useful coupler and component model fields for debugging\n\n\n\n\n\n","category":"function"},{"location":"plotting/#ClimaCoupler.Plotting.make_diagnostics_plots","page":"Plotting","title":"ClimaCoupler.Plotting.make_diagnostics_plots","text":"make_diagnostics_plots(\n    output_path::AbstractString,\n    plot_path::AbstractString;\n    output_prefix = \"\",\n)\n\nCreate plots for diagnostics. The plots are saved to plot_path. This function will plot all variables that have been saved in output_path. The reduction keyword argument should be consistent with the reduction used to save the diagnostics.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#ClimaCoupler.Plotting.make_ocean_diagnostics_plots","page":"Plotting","title":"ClimaCoupler.Plotting.make_ocean_diagnostics_plots","text":"make_ocean_diagnostics_plots(output_path::AbstractString, plot_path::AbstractString; output_prefix = \"\")\n\nCreate plots for diagnostics. The plots are saved to ocean_summary_2D.pdf in plot_path. This function will plot the following variables, if they have been saved in output_path:     - Temperature (T)     - Salinity (S)     - Zonal velocity (u)     - Meridional velocity (v)\n\nFor each variable, take the surface level (top level) of the variable and create a 2D plot. The plots will be saved in a single PDF file.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#ClimaCoupler.Plotting.debug","page":"Plotting","title":"ClimaCoupler.Plotting.debug","text":"debug(cs::Interfacer.CoupledSimulation, dir = \"debug\", cs_fields_ref = nothing)\n\nPlot the fields of a coupled simulation and save plots to a directory.\n\n\n\n\n\ndebug(cs_fields::CC.Fields.Field, dir, cs_fields_ref = nothing)\n\nPlot useful coupler fields (in field_names) and save plots to a directory.\n\nIf cs_fields_ref is provided (e.g., using a copy of cs.fields from the initialization), plot the anomalies of the fields with respect to cs_fields_ref.\n\nFor vector fields which are not defined on a Cartesian basis, rotate them to the Cartesian basis before plotting so they can be interpreted physically.\n\n\n\n\n\ndebug(sim::Interfacer.AbstractComponentSimulation, dir)\n\nPlot the fields of a component model simulation and save plots to a directory.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#ClimaCoupler.Plotting.debug_plot_fields","page":"Plotting","title":"ClimaCoupler.Plotting.debug_plot_fields","text":"Plotting.debug_plot_fields(sim::Interfacer.AbstractSurfaceSimulation)\n\nReturn the default fields to include in debug plots for a surface model. This should be extended for any atmosphere model, and any surface model that has additional fields to plot.\n\n\n\n\n\nPlotting.debug_plot_fields(sim::OceananigansSimulation)\n\nReturn the fields to include in debug plots for an Oceananigans simulation. This includes the area fraction, surface temperature, salinity, velocity, and free surface displacement. These plots are not polished, and are intended for debugging.\n\n\n\n\n\nPlotting.debug_plot_fields(sim::ClimaSeaIceSimulation)\n\nReturn the fields to include in debug plots for a ClimaSeaIce simulation. This includes the area fraction, surface temperature, ice concentration, and ice thickness. These plots are not polished, and are intended for debugging.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#ClimaCoupler.Plotting.debug_plot!","page":"Plotting","title":"ClimaCoupler.Plotting.debug_plot!","text":"Plotting.debug_plot!(ax, fig, field::CC.Fields.Field, i, j)\n\nHelper function to plot a heatmap of a ClimaCore field in the given figure at position (i, j). If the field is constant, skip plotting it to avoid heatmap errors.\n\n\n\n\n\nPlotting.debug_plot!(ax, fig, field, i, j)\n\nMake a line plot of the provided array.\n\n\n\n\n\nPlotting.debug_plot!(ax, fig, field, i, j)\n\nPlot a heatmap of the provided Oceananigans field or operation. This is intended to be used as part of the debug plotting system.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#ClimaCoupler.Plotting.plot_global_conservation","page":"Plotting","title":"ClimaCoupler.Plotting.plot_global_conservation","text":"plot_global_conservation(\n    cc::AbstractConservationCheck,\n    coupler_sim::Interfacer.CoupledSimulation,\n    softfail = false;\n    figname1 = \"total.png\",\n    figname2 = \"total_log.png\",\n)\n\nCreates two plots of the globally integrated quantity (energy, rho e):\n\nglobal quantity of each model component as a function of time,\n\nrelative to the initial value;\n\nfractional change in the sum of all components over time on a log scale.\n\nConservation checks are available for energy and water, and can be enabled by running a Slabplanet simulation with energy_check set to true.\n\nIf softfail is false, asserts that the relative error in conservation of the provided quantity is less than a pre-determined threshold. This argument is controlled by the conservation_softfail simulation flag.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#ClimaCoupler.Plotting.compute_leaderboard","page":"Plotting","title":"ClimaCoupler.Plotting.compute_leaderboard","text":"compute_leaderboard(leaderboard_base_path, diagnostics_folder_path, spinup)\n\nPlot the biases and a leaderboard of various variables defined over longitude, latitude, and time.\n\nThe argument leaderboard_base_path is the path to save the leaderboards and bias plots, diagnostics_folder_path is the path to the simulation data, and spinup is the number of months to remove from the beginning of the simulation.\n\nLoading and preprocessing simulation data is done by get_sim_var_dict. Loading and preprocessing observational data is done by get_obs_var_dict. The ranges of the bias plots are determined by get_compare_vars_biases_plot_extrema. The groups of variables plotted on the bias plots are determined by get_compare_vars_biases_groups(). Loading the RMSEs from other models is done by get_rmse_var_dict. See the functions defined in data_sources.jl.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#ClimaCoupler.Plotting.compute_pfull_leaderboard","page":"Plotting","title":"ClimaCoupler.Plotting.compute_pfull_leaderboard","text":"compute_pfull_leaderboard(leaderboard_base_path, diagnostics_folder_path, spinup)\n\nPlot the biases and a leaderboard of various variables defined over longitude, latitude, time, and pressure levels.\n\nThe argument leaderboard_base_path is the path to save the leaderboards and bias plots, diagnostics_folder_path is the path to the simulation data, and spinup is the number of months to remove from the beginning of the simulation.\n\nLoading and preprocessing simulation data is done by get_sim_var_in_pfull_dict. Loading and preprocessing observational data is done by get_obs_var_in_pfull_dict. The ranges of the bias plots is defined by get_compare_vars_biases_plot_extrema_pfull. See the functions defined in data_sources.jl for more information.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Postprocessing","page":"Plotting","title":"Postprocessing","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The postprocess function coordinates all postprocessing operations after a simulation completes, including generating diagnostic plots, leaderboards, conservation plots, and debug visualizations. It also performs RMSE checks against observations and closes diagnostics file writers.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Note: While postprocess can be called without the Makie extension loaded, it will not generate any plots. To produce visualizations, ensure the ClimaCouplerMakieExt extension is loaded by importing the required Makie packages (see ClimaCouplerMakieExt Extension below).","category":"page"},{"location":"plotting/#ClimaCouplerMakieExt-Extension","page":"Plotting","title":"ClimaCouplerMakieExt Extension","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The ClimaCouplerMakieExt extension provides the actual implementations of all plotting functions when the following packages are loaded:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Makie - The core plotting package\nCairoMakie - For PDF image output and other backend plotting work\nClimaCoreMakie - For plotting ClimaCore fields\nGeoMakie - For geographic/map visualizations\nPoppler_jll - For saving PDFs nicely\nPrintf - For string manipulation","category":"page"},{"location":"plotting/#Loading-the-Extension","page":"Plotting","title":"Loading the Extension","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The extension is automatically loaded when you using or import all of the required Makie packages:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Makie, GeoMakie, CairoMakie, ClimaCoreMakie, Poppler_jll, Printf","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Once loaded, all plotting functions in the Plotting module will use the full implementations instead of the stub methods.","category":"page"},{"location":"plotting/#Features","page":"Plotting","title":"Features","text":"","category":"section"},{"location":"plotting/#Diagnostics-plots","page":"Plotting","title":"Diagnostics plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"ClimaCouplerMakieExt.jl uses ClimaAnalysis.jl to generate plots of diagnostic variables saved using the ClimaDiagnostics.jl infrastructure.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"For information about diagnostics in ClimaCoupler, including how to customize which variables to save, how often, and with which reductions, see the Diagnostics documentation.","category":"page"},{"location":"plotting/#Leaderboards","page":"Plotting","title":"Leaderboards","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Leaderboards compare simulation output against observational data, computing bias and RMSE metrics for various variables. Both 2D surface variables and 3D pressure-level variables are supported.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"For detailed information about adding variables to leaderboards and customizing comparisons, see the Leaderboard documentation.","category":"page"},{"location":"plotting/#Calibration-plots","page":"Plotting","title":"Calibration plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Calibration plots visualize parameter calibration results, including scatter plots of parameter values versus observations and parameter evolution across iterations.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"These plots are used to visualize the results of model parameter calibration with EnsembleKalmanProcesses.jl.","category":"page"},{"location":"plotting/#Conservation-plots","page":"Plotting","title":"Conservation plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Conservation plots show time series of global conservation quantities (energy and water) over the course of a simulation. These plots help verify that the coupled system maintains physical conservation properties.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Please note that the current AMIP/CMIP configurations are not expected to be conservative, so conservation plots are only available for the Slabplanet configuration.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"For information about conservation checks in ClimaCoupler, see the Conservation Checks documentation.","category":"page"},{"location":"plotting/#Debug-plots","page":"Plotting","title":"Debug plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To facilitate debugging, ClimaCoupler.jl plots most coupler fields and model fields of physical interest by default. These plots are availabe at the end of a simulation in the provided artifacts directory.","category":"page"},{"location":"plotting/#ClimaCouplerCMIPMakieExt-Extension","page":"Plotting","title":"ClimaCouplerCMIPMakieExt Extension","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The ClimaCouplerCMIPMakieExt extension extends the base plotting functionality to support Oceananigans.jl fields when Oceananigans is used as the ocean component model.","category":"page"},{"location":"plotting/#Loading-the-Extension-2","page":"Plotting","title":"Loading the Extension","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The extension is automatically loaded when Oceananigans.jl and the required Makie packages are available:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Makie, GeoMakie, CairoMakie, ClimaCoreMakie, Poppler_jll, Printf\nusing Oceananigans","category":"page"},{"location":"plotting/#Additional-Features","page":"Plotting","title":"Additional Features","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The Oceananigans extension adds support for:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Oceananigans field plotting: Extends Plotting.debug_plot! to handle Oceananigans.Field and Oceananigans.AbstractOperations.AbstractOperation types, allowing debug plots to visualize ocean model fields directly.\nOceananigans field extrema: Extends Plotting.print_extrema to format the minimum and maximum values of Oceananigans fields for display in plot titles and labels.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"These extensions enable the debug plotting system to automatically handle Oceananigans fields when they are encountered in coupled simulations, without requiring any special handling in user code.","category":"page"},{"location":"timemanager/#TimeManager","page":"TimeManager","title":"TimeManager","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"This module contains functions that handle dates and times in simulations. The functions in this module often call functions from Julia's Dates module.","category":"page"},{"location":"timemanager/#TimeManager-API","page":"TimeManager","title":"TimeManager API","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"TimeManager.maybe_trigger_callback","category":"page"},{"location":"timemanager/#ClimaCoupler.TimeManager.maybe_trigger_callback","page":"TimeManager","title":"ClimaCoupler.TimeManager.maybe_trigger_callback","text":"maybe_trigger_callback(callback, cs)\n\nCheck if it is time to call callback, if yes, call its function on cs.\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ITime","page":"TimeManager","title":"ITime","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"ITime, or integer time, is a time type used by CliMA simulations to keep track of simulation time. For more information, refer to the TimeManager section in ClimaUtilities and the ITime section in ClimaAtmos.","category":"page"},{"location":"timemanager/#How-do-I-use-ITime?","page":"TimeManager","title":"How do I use ITime?","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"If you are running a simulation from a YAML file, you can simply set use_itime to true to enable ITime. If you do not want to use ITime and want to use floating point numbers, then set use_itime to false to not use ITime.","category":"page"},{"location":"#ClimaCoupler.jl","page":"Home","title":"ClimaCoupler.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Coupling CliMA Models","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ClimaCoupler","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaCoupler.jl provides a means to couple CliMA  model components. It is designed to provide a flexible way to map boundary fluxes of quantities, like moisture and heat, that leave one component model (for example the atmosphere) to boundary fluxes of another component model (for example the ocean model). Functionality includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"coupled system time stepping control that integrates fluxes in time for sharing between components with differing time steps and/or time stepping schemes.\nsupport for mapping import and export boundary information between components so that fluxes of properties transferred between components are conserved.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ClimaCoupler supports coupling components that are all within the same process or coupling components (using MPI) that are running on different processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Coupler Scheme)\nClimaCoupler.jl allows for independent development of interchangeable component models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaCoupler","category":"page"},{"location":"#ClimaCoupler.ClimaCoupler","page":"Home","title":"ClimaCoupler.ClimaCoupler","text":"ClimaCoupler\n\nModule for atmos-ocean-land coupled simulations.\n\n\n\n\n\n","category":"module"},{"location":"generated/sea_breeze/atmos_rhs/#Atmospheric-Model","page":"Atmospheric Model","title":"Atmospheric Model","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/#Atmosphere-Conservation-Equations","page":"Atmospheric Model","title":"Atmosphere Conservation Equations","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Density:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rhopartial t + nabla cdot (rho vecu)= S(chi )","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Momentum (flux form):","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho vecupartial t + nabla cdot (rho vecu otimes vecu + pI)= nabla cdot (rho tau) - rho g + F_B()","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Potential temperature:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho thetapartial t + nabla cdot (rho theta vecu) = nabla cdot (kappa rho nabla theta)","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Total Energy (possibly replace potential temperature equation with total energy conservation):","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho e_totpartial t + nabla cdot ((rho e_tot + p )vecu) = nabla cdot (kappa rho nabla h_tot)","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"where h_tot is the total specific enthalpy given by internal and potential energy contributions.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Tracer transport:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho chipartial t + nabla cdot (rho chi vecu) = nabla cdot (kappa rho nabla chi) + S(chi )","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Diffusion (Constant Viscosity): The simplest model to represent diffusive processes is a constant-viscosity model, with prescribed kinematic viscosity nu such that the stress tensor can be modelled by","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"rhotau = -2rhonunabla u","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Smagorinsky Closure: The Smagorinsky closure is an eddy-viscosity model that captures the effect of energy transfer to the smallest scales of motion in the flow.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\nrhotau = -2rhonuvecS \nvecS = frac12((nabla u) + (nabla u)^T) \nnu = (C_sDelta_xyz)^2sqrt2S_ijS_ij\nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"with Delta_xyz the grid lengthscale (sometimes approximated as a geometric average Delta = (Delta_xDelta_yDelta_z)^13), nu is a spatially varying kinematic viscosity that depends on the local shear, vecS the symmetric rate-of-strain tensor, tau the diffusive momentum flux tensor. In stratified flows, we can apply a correction to the eddy viscosity to account for buoyancy effects. Thermal diffusivities are related to the modelled eddy-viscosity through the turbulent Prandtl number which takes a typical value of Pr_t= 13 such that kappa_2 = nuPr_t.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Tendencies for fourth-order hyperdiffusion are included in the rhs! construction, but the coefficient kappa_4 is 0 in this demonstrative case. Hyperdiffusive tendencies are typically included as a scale-selective diffusion mechanism for high-frequency noise (e.g. stabilization in GCMs).","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Consider components of the viscous stress tensor in three dimensions:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\ntau_xx = 2nu fracpartial upartial x \n\ntau_yy = 2nu fracpartial vpartial y \n\ntau_zz = 2nu fracpartial wpartial z \n\ntau_xy = nu Big(fracpartial upartial y +  fracpartial vpartial xBig) \n\ntau_xz = nu Big(fracpartial upartial z +  fracpartial wpartial xBig) \n\ntau_yz = nu Big(fracpartial vpartial z +  fracpartial wpartial yBig)\nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Assume terms in the y-direction are neglected (2-dimensional simplicfication). The contributions to the momentum equation are then given by:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\n(rho u)  partial_x (rho tau_xx) + partial_z(rhotau_xz)  = partial_x  Big(2nu fracpartial upartial xBig) + partial_zBig(nu fracpartial upartial zBig) + partial_zBig(nu fracpartial wpartial xBig) \n(rho w) partial_x (rho tau_zx)+ partial_z(rhotau_zz)  = partial_xBig(nu fracpartial upartial zBig) +  partial_xBig(nu fracpartial wpartial xBig) + partial_zBig(2nufracpartial wpartial z Big) \nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Which can be interpreted as, for horizontal-momentum:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Horizontal divergence of vertical gradients of cell-centered variables u\nVertical divergence of vertical gradients of cell-centered variables u\nVertical divergence of horizontal gradients of cell-face variables w","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"and for vertical-momentum, as:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Horizontal divergence of vertical gradients of cell-centered variables u\nHorizontal divergence of horizontal gradients of cell-face variables w\nVertical divergence of vertical gradients of cell-face variables w.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Model-Code","page":"Atmospheric Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"push!(LOAD_PATH, joinpath(@__DIR__, \"..\", \"..\", \"..\"))\n\nimport LinearAlgebra\nimport SciMLBase\nimport StaticArrays\n\nimport ClimaCore as CC\nimport ClimaCore.Geometry: ⊗\nimport ClimaComms","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Load coupled simulation code","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"include(\"../CoupledSims/coupled_sim.jl\")\n\n# set up function space\nfunction hvspace_2D(xlim = (-π, π), zlim = (0, 4π), helem = 20, velem = 20, npoly = 1)\n    FT = Float64\n    vertdomain = CC.Domains.IntervalDomain(\n        CC.Geometry.ZPoint{FT}(zlim[1]),\n        CC.Geometry.ZPoint{FT}(zlim[2]);\n        boundary_names = (:bottom, :top),\n    )\n    context = ClimaComms.context()\n    vertmesh = CC.Meshes.IntervalMesh(vertdomain, nelems = velem)\n    device = ClimaComms.device(context)\n    vert_center_space = CC.Spaces.CenterFiniteDifferenceSpace(device, vertmesh)\n\n    horzdomain = CC.Domains.IntervalDomain(\n        CC.Geometry.XPoint{FT}(xlim[1]),\n        CC.Geometry.XPoint{FT}(xlim[2]),\n        periodic = true,\n    )\n    horzmesh = CC.Meshes.IntervalMesh(horzdomain; nelems = helem)\n    horztopology = CC.Topologies.IntervalTopology(horzmesh)\n\n    quad = CC.Spaces.Quadratures.GLL{npoly + 1}()\n    horzspace = CC.Spaces.SpectralElementSpace1D(horztopology, quad)\n\n    hv_center_space = CC.Spaces.ExtrudedFiniteDifferenceSpace(horzspace, vert_center_space)\n    hv_face_space = CC.Spaces.FaceExtrudedFiniteDifferenceSpace(hv_center_space)\n    return (hv_center_space, hv_face_space)\nend\n\nfunction pressure(ρθ)\n    if ρθ >= 0\n        return MSLP * (R_d * ρθ / MSLP)^γ\n    else\n        return NaN\n    end\nend\n\nΦ(z) = grav * z\n\nabstract type BCtag end\nstruct ZeroFlux <: BCtag end\n\nbc_divF2C_bottom!(::ZeroFlux, dY, Y, p, t) = CC.Operators.SetValue(CC.Geometry.WVector(0.0))\nbc_divF2C_top!(::ZeroFlux, dY, Y, p, t) = CC.Operators.SetValue(CC.Geometry.WVector(0.0))\n\nfunction init_sea_breeze_2d(x, z)\n    θ₀ = atm_T_ini\n    cp_d = C_p\n    cv_d = C_v\n    p₀ = MSLP\n    g = grav\n    γ = cp_d / cv_d\n    z_c = 100.0\n    θ_b = atm_T_ini\n    θ_p = z < z_c ? rand() - 0.5 : 0.0 # potential temperature perturbation\n    θ = θ_b + θ_p # potential temperature\n    π_exn = 1.0 - g * z / cp_d / θ # exner function\n    T = π_exn * θ # temperature\n    p = p₀ * π_exn^(cp_d / R_d) # pressure\n    ρ = p / R_d / T # density\n    ρθ = ρ * θ # potential temperature density\n    return (ρ = ρ, ρθ = ρθ, ρuₕ = ρ * CC.Geometry.UVector(0.0))\nend\n\nfunction atm_rhs!(dY, Y, params, t)\n    ρw = Y.ρw\n    Yc = Y.Yc\n    dYc = dY.Yc\n    dρw = dY.ρw\n\n    center_coords = CC.Fields.coordinate_field(axes(Yc))\n\n    # spectral horizontal operators\n    hdiv = CC.Operators.Divergence()\n    hgrad = CC.Operators.Gradient()\n    hwdiv = CC.Operators.WeakDivergence()\n    hwgrad = CC.Operators.WeakGradient()\n\n    # vertical FD operators with BC's\n    vdivf2c = CC.Operators.DivergenceF2C(\n        bottom = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n        top = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n    )\n    vvdivc2f = CC.Operators.DivergenceC2F(\n        bottom = CC.Operators.SetDivergence(CC.Geometry.WVector(0.0)),\n        top = CC.Operators.SetDivergence(CC.Geometry.WVector(0.0)),\n    )\n    uvdivf2c = CC.Operators.DivergenceF2C(\n        bottom = CC.Operators.SetValue(CC.Geometry.WVector(0.0) ⊗ CC.Geometry.UVector(0.0)),\n        top = CC.Operators.SetValue(CC.Geometry.WVector(0.0) ⊗ CC.Geometry.UVector(0.0)),\n    )\n    If = CC.Operators.InterpolateC2F(\n        bottom = CC.Operators.Extrapolate(),\n        top = CC.Operators.Extrapolate(),\n    )\n    Ic = CC.Operators.InterpolateF2C()\n    ∂ = CC.Operators.DivergenceF2C(\n        bottom = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n        top = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n    )\n    ∂f = CC.Operators.GradientC2F()\n    ∂c = CC.Operators.GradientF2C()\n    B = CC.Operators.SetBoundaryOperator(\n        bottom = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n        top = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n    )\n\n    ∇_z_ρθ = CC.Operators.DivergenceF2C(\n        bottom = bc_divF2C_bottom!(params.bc.ρθ.bottom, dY, Y, params, t),\n        top = bc_divF2C_top!(params.bc.ρθ.top, dY, Y, params, t),\n    )\n\n    uₕ = @. Yc.ρuₕ / Yc.ρ\n    w = @. ρw / If(Yc.ρ)\n    wc = @. Ic(ρw) / Yc.ρ\n    p = @. pressure(Yc.ρθ)\n    θ = @. Yc.ρθ / Yc.ρ\n    Yfρ = @. If(Yc.ρ)\n\n    ### HYPERVISCOSITY\n    # 1) compute hyperviscosity coefficients\n    @. dYc.ρθ = hwdiv(hgrad(θ))\n    @. dYc.ρuₕ = hwdiv(hgrad(uₕ))\n    @. dρw = hwdiv(hgrad(w))\n    CC.Spaces.weighted_dss!(dYc)\n    CC.Spaces.weighted_dss!(dρw)\n\n    κ₄ = 0.0 # m^4/s\n    @. dYc.ρθ = -κ₄ * hwdiv(Yc.ρ * hgrad(dYc.ρθ))\n    @. dYc.ρuₕ = -κ₄ * hwdiv(Yc.ρ * hgrad(dYc.ρuₕ))\n    @. dρw = -κ₄ * hwdiv(Yfρ * hgrad(dρw))\n\n    # density\n    @. dYc.ρ = -∂(ρw)\n    @. dYc.ρ -= hdiv(Yc.ρuₕ)\n\n    # potential temperature\n    @. dYc.ρθ += -(∇_z_ρθ(ρw * If(Yc.ρθ / Yc.ρ)))\n    @. dYc.ρθ -= hdiv(uₕ * Yc.ρθ)\n\n    # horizontal momentum\n    Ih = Ref(\n        CC.Geometry.Axis2Tensor(\n            (CC.Geometry.UAxis(), CC.Geometry.UAxis()),\n            StaticArrays.@SMatrix [1.0]\n        ),\n    )\n    @. dYc.ρuₕ += -uvdivf2c(ρw ⊗ If(uₕ))\n    @. dYc.ρuₕ -= hdiv(Yc.ρuₕ ⊗ uₕ + p * Ih)\n\n    # vertical momentum\n    @. dρw += B(\n        CC.Geometry.transform(\n            CC.Geometry.WAxis(),\n            -(∂f(p)) - If(Yc.ρ) * ∂f(Φ(center_coords.z)),\n        ) - vvdivc2f(Ic(ρw ⊗ w)),\n    )\n    uₕf = @. If(Yc.ρuₕ / Yc.ρ) # requires boundary conditions\n    @. dρw -= hdiv(uₕf ⊗ ρw)\n\n    # DIFFUSION\n    κ₂ = 5.0 # m^2/s\n    #  1a) horizontal div of horizontal grad of horiz momentun\n    @. dYc.ρuₕ += hwdiv(κ₂ * (Yc.ρ * hgrad(Yc.ρuₕ / Yc.ρ)))\n    #  1b) vertical div of vertical grad of horiz momentun\n    @. dYc.ρuₕ += uvdivf2c(κ₂ * (Yfρ * ∂f(Yc.ρuₕ / Yc.ρ)))\n\n    #  1c) horizontal div of horizontal grad of vert momentum\n    @. dρw += hwdiv(κ₂ * (Yfρ * hgrad(ρw / Yfρ)))\n    #  1d) vertical div of vertical grad of vert momentun\n    @. dρw += vvdivc2f(κ₂ * (Yc.ρ * ∂c(ρw / Yfρ)))\n\n    #  2a) horizontal div of horizontal grad of potential temperature\n    @. dYc.ρθ += hwdiv(κ₂ * (Yc.ρ * hgrad(Yc.ρθ / Yc.ρ)))\n    #  2b) vertical div of vertial grad of potential temperature\n    @. dYc.ρθ += ∇_z_ρθ(κ₂ * (Yfρ * ∂f(Yc.ρθ / Yc.ρ)))\n\n    CC.Spaces.weighted_dss!(dYc)\n    CC.Spaces.weighted_dss!(dρw)\n    return dY\nend\n\n# init simulation\nfunction atm_init(;\n    xmin = -500,\n    xmax = 500,\n    zmin = 0,\n    zmax = 1000,\n    npoly = 3,\n    helem = 20,\n    velem = 20,\n    bc = nothing,\n)\n\n    # construct domain spaces\n    hv_center_space, hv_face_space =\n        hvspace_2D((xmin, xmax), (zmin, zmax), helem, velem, npoly) # [m]\n    center_coords = CC.Fields.coordinate_field(hv_center_space)\n    face_coords = CC.Fields.coordinate_field(hv_face_space)\n    domain = (hv_center_space = hv_center_space, hv_face_space = hv_face_space)\n\n    # initialize prognostic variables\n    Yc = map(center_coords) do coord\n        sea_breeze = init_sea_breeze_2d(coord.x, coord.z)\n        sea_breeze\n    end\n\n    ρw = map(face_coords) do coord\n        CC.Geometry.WVector(0.0)\n    end\n\n    Y = CC.Fields.FieldVector(Yc = Yc, ρw = ρw)\n\n    # select boundary conditions\n    if bc === nothing\n        bc = (\n            ρθ = (bottom = CoupledFlux(), top = ZeroFlux()),\n            ρu = nothing, # for now BCs are hard coded, except for ρθ\n        )\n    end\n\n    return Y, bc, domain\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Coupled-Atmos-Wrappers","page":"Atmospheric Model","title":"Coupled Atmos Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"# Atmos Simulation - later to live in ClimaAtmos\nstruct AtmosSim{T} <: AbstractAtmosSim\n    integrator::T\nend\n\nfunction AtmosSim(\n    Y_init,\n    t_start,\n    dt,\n    t_end,\n    timestepper,\n    p,\n    saveat,\n    callbacks = CallbackSet(),\n)\n    ode_algo = CTS.ExplicitAlgorithm(timestepper)\n    ode_function = CTS.ClimaODEFunction(T_exp! = atm_rhs!)\n\n    problem = SciMLBase.ODEProblem(ode_function, Y_init, (t_start, t_end), p)\n    atm_integ = SciMLBase.init(\n        problem,\n        ode_algo,\n        dt = dt,\n        saveat = saveat,\n        adaptive = false,\n        progress = true,\n        progress_message = (dt, u, params, t) -> t,\n        callback = callbacks,\n    )\n\n    return AtmosSim(atm_integ)\nend\n\nfunction coupler_push!(coupler::CouplerState, atmos::AtmosSim)\n    coupler_put!(coupler, :F_sfc, atmos.integrator.u.F_sfc, atmos)\nend\n\nfunction coupler_pull!(atmos::AtmosSim, coupler::CouplerState)\n    # reset flux accumulator\n    atmos.integrator.u.F_sfc .= 0.0 # reset surface flux to be accumulated\n\n    T_sfc_ocean = coupler_get(coupler, :T_sfc_ocean, atmos)\n    T_sfc_land = coupler_get(coupler, :T_sfc_land, atmos)\n    atmos.integrator.p.T_sfc .= T_sfc_land .+ T_sfc_ocean\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Coupled-Boundary-Conditions","page":"Atmospheric Model","title":"Coupled Boundary Conditions","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"The standalone atmosphere model uses two boundary condition methods in its tendency: bc_divF2C_bottom! and bc_divF2C_top!. Since the bottom boundary is coupled, bc_divF2C_bottom! must be altered when running in coupled mode to properly calculate and accumulate the boundary flux from the ocean and land components.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"To solve this, a CoupledFlux boundary tag is set for the bottom boundary during initialization. Then, a new method of bc_divF2C_bottom! is written to dispatch on the CoupledFlux boundary tag. This method can then compute the flux appropriately.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"struct CoupledFlux <: BCtag end\nfunction bc_divF2C_bottom!(::CoupledFlux, dY, Y, p, t)\n    # flux calculation\n    Yc = Y.Yc\n    uₕ = Yc.ρuₕ ./ Yc.ρ\n    ρw = Y.ρw\n    If2c = CC.Operators.InterpolateF2C()\n    Ic2f = CC.Operators.InterpolateC2F(\n        bottom = CC.Operators.Extrapolate(),\n        top = CC.Operators.Extrapolate(),\n    )\n    w = If2c.(ρw) ./ Yc.ρ\n    cuv = @. CC.Geometry.UWVector(uₕ)\n    windspeed = @. LinearAlgebra.norm(cuv)\n    windspeed_boundary = CC.Fields.level(windspeed, 1)\n    θ_boundary = CC.Fields.level(Yc.ρθ ./ Yc.ρ, 1)\n    ρ_boundary = CC.Fields.level(Yc.ρ, 1)\n\n    # build atmos face fields on surface boundary space to enable broadcasting\n    windspeed_boundary =\n        CC.Fields.Field(CC.Fields.field_values(windspeed_boundary), axes(p.T_sfc))\n    θ_boundary = CC.Fields.Field(CC.Fields.field_values(θ_boundary), axes(p.T_sfc))\n    ρ_boundary = CC.Fields.Field(CC.Fields.field_values(ρ_boundary), axes(p.T_sfc))\n\n    λ = @. p.cpl_p.C_p * p.cpl_p.C_H * ρ_boundary * windspeed_boundary\n    dθ = @. θ_boundary - p.T_sfc\n    heat_flux = @. -λ * dθ\n    @. dY.F_sfc += heat_flux # accumulation\n\n    return CC.Operators.SetValue(CC.Geometry.WVector.(heat_flux))\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"This page was generated using Literate.jl.","category":"page"}]
}
