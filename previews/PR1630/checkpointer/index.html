<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Checkpointer · ClimaCoupler.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ClimaCoupler.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCoupler.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Sea Breeze</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated/sea_breeze/atmos_rhs/">Atmospheric Model</a></li><li><a class="tocitem" href="../generated/sea_breeze/land_rhs/">Land Model</a></li><li><a class="tocitem" href="../generated/sea_breeze/ocean_rhs/">Ocean Model</a></li><li><a class="tocitem" href="../generated/sea_breeze/run/">Coupled Sea Breeze</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">AMIP</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated/amip/run_amip/">AMIP Driver</a></li></ul></li></ul></li><li><span class="tocitem">Coupler Interface</span><ul><li><a class="tocitem" href="../input/">Input</a></li><li class="is-active"><a class="tocitem" href>Checkpointer</a><ul class="internal"><li><a class="tocitem" href="#How-to-save-and-restart-from-checkpoints"><span>How to save and restart from checkpoints</span></a></li><li><a class="tocitem" href="#Developer-notes"><span>Developer notes</span></a></li><li><a class="tocitem" href="#Checkpointer-API"><span>Checkpointer API</span></a></li></ul></li><li><a class="tocitem" href="../conservation/">Conservation Checks</a></li><li><a class="tocitem" href="../fieldexchanger/">FieldExchanger</a></li><li><a class="tocitem" href="../fluxcalculator/">FluxCalculator</a></li><li><a class="tocitem" href="../interfacer/">Interfacer</a></li><li><a class="tocitem" href="../timemanager/">TimeManager</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../simoutput/">SimOutput</a></li></ul></li><li><span class="tocitem">Performance</span><ul><li><a class="tocitem" href="../performance/">Performance Analysis Tools</a></li></ul></li><li><span class="tocitem">Model Output</span><ul><li><a class="tocitem" href="../diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../leaderboard/">Leaderboard</a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Coupler Interface</a></li><li class="is-active"><a href>Checkpointer</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Checkpointer</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaCoupler.jl/blob/main/docs/src/checkpointer.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Checkpointer"><a class="docs-heading-anchor" href="#Checkpointer">Checkpointer</a><a id="Checkpointer-1"></a><a class="docs-heading-anchor-permalink" href="#Checkpointer" title="Permalink"></a></h1><h2 id="How-to-save-and-restart-from-checkpoints"><a class="docs-heading-anchor" href="#How-to-save-and-restart-from-checkpoints">How to save and restart from checkpoints</a><a id="How-to-save-and-restart-from-checkpoints-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-save-and-restart-from-checkpoints" title="Permalink"></a></h2><p><code>ClimaCoupler</code> supports saving and reading simulation checkpoints. This is useful to split a long simulation into smaller, more manageable chunks.</p><p>Checkpoints are a mix of HDF5 and JLD2 files and are typically saved in a <code>checkpoints</code> folder in the simulation output. See <a href="@ref"><code>Utilities.setup_output_dirs</code></a> for more information.</p><div class="admonition is-warning"><header class="admonition-header">Known limitations</header><div class="admonition-body"><ul><li>The number of MPI processes has to remain the same across checkpoints</li><li>Restart files are generally not portable across machines, julia versions, and package versions</li><li>Adding/changing new component models will probably require adding/changing code</li></ul></div></div><h3 id="Saving-checkpoints"><a class="docs-heading-anchor" href="#Saving-checkpoints">Saving checkpoints</a><a id="Saving-checkpoints-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-checkpoints" title="Permalink"></a></h3><p>If you are running a model (such as AMIP), chances are that you can enable checkpointing just by setting a command-line argument; The <code>checkpoint_dt</code> option controls how frequently a checkpoint should be produced.</p><p>If your model does not come with this option already, you can checkpoint the simulation by adding a callback that calls the <a href="@ref"><code>Checkpointer.checkpoint_sims</code></a> function.</p><p>For example, to add a callback to checkpoint every hour of simulated time, assuming you have a <code>start_date</code></p><pre><code class="language-julia hljs">import Dates

import ClimaCoupler: Checkpointer, TimeManager
import ClimaDiagnostics.Schedules: EveryCalendarDtSchedule

schedule = EveryCalendarDtSchedule(Dates.Hour(1); start_date)
checkpoint_callback = TimeManager.Callback(schedule_checkpoint, Checkpointer.checkpoint_sims)

# In the coupling loop:
TimeManager.maybe_trigger_callback(checkpoint_callback, coupled_simulation, time)</code></pre><h3 id="Reading-checkpoints"><a class="docs-heading-anchor" href="#Reading-checkpoints">Reading checkpoints</a><a id="Reading-checkpoints-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-checkpoints" title="Permalink"></a></h3><p>There are two ways to restart a simulation from checkpoints. By default, <code>ClimaCoupler</code> tries finding suitable checkpoints and automatically use them. Alternatively, you can specify a directory <code>restart_dir</code> and a simulation time <code>restart_t</code> and restart from files saved in the given directory at the given time. If the model you are running supports writing checkpoints via command-line argument, it will probably also support reading them. In this case, the arguments <code>restart_dir</code> and <code>restart_t</code> identify the path of the top level directory containing all the checkpoint files and the simulated times in second.</p><p>If the model does not support directly reading a checkpoint, the <code>Checkpointer</code> module provides a straightforward way to add this feature. <a href="@ref"><code>Checkpointer.restart!</code></a> takes a coupled simulation, a <code>restart_dir</code>, and a <code>restart_t</code> and overwrites the content of the coupled simulation with what is in the checkpoint.</p><h2 id="Developer-notes"><a class="docs-heading-anchor" href="#Developer-notes">Developer notes</a><a id="Developer-notes-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-notes" title="Permalink"></a></h2><p>In theory, the state of the component models should fully determine the state of the coupled simulation and one should be able to restart a coupled simulation just by using the states of the component models. Unfortunately, this is currently not the case in <code>ClimaCoupler</code>. The main reason for this is the complex interdependencies between component models and within <code>ClimaAtmos</code> which make the initialization step inconsistent. For example, in a coupled simulation, the surface albedo should be determined by the surface models and used by the atmospheric model for radiation transfer, but <code>ClimaAtmos</code> also tries to set the surface albedo (since it has to do so when run in standalone mode). In addition to this, <code>ClimaAtmos</code> has a large cache that has internal interdependencies that are hard to disentangle, and changing a field might require changing some other field in a different part of the cache. As a result, it is not easy for <code>ClimaCoupler</code> to consistently do initialization from a cold state. To conclude, restarting a simulation exclusively using the states of the component models is currently impossible.</p><p>Given that restarting a simulation from the state is impossible, <code>ClimaCoupler</code> needs to save the states and the caches. Let us review how we use <code>ClimaCore.InputOutput</code> and <code>JLD2</code> package to accomplish this.</p><p><code>ClimaCore.InputOutput</code> provides a loss-less way to save the content of certain <code>ClimaCore</code> objects to HDF5 files. Objects saved in this way are not tied to a particular computing device or configuration. When running with MPI, <code>ClimaCore.InputOutput</code> are also efficiently written in parallel.</p><p>Unfortunately, <code>ClimaCore.InputOutput</code> only supports certain objects, such as <code>Field</code>s and <code>Space</code>s, but the cache in component models is more complex than this and contains complex objects with highly stateful quantities (e.g., C pointers). Because of this, model states are saved to HDF5 but caches must be saved to JLD2 files.</p><p><code>JLD2</code> allows us to save more complex objects without writing specific serialization methods for every struct. <code>JLD2</code> allows us to take a big step forward, but there are still several challenges that need to be solved:</p><ol><li><code>JLD2</code> does not support CUDA natively. To go around this, we have to move everything onto the CPU first. Then, when the data is read back, we have to move it back to the GPU.</li><li><code>JLD2</code> does not support MPI natively. To go around this, each process writes its <code>jld2</code> checkpoint and reads it back. This introduces the constraint that the number of MPI processes cannot change across restarts.</li><li>Some quantities are best not saved and read (for example, anything with pointers). For this, we write a recursive function that traverses the cache and only restores quantities of a certain type (typically, <code>ClimaCore</code> objects)</li></ol><p>Point 3. adds significant amount of code and requires component models to specify how their cache has to be restored.</p><p>If you are adding a component model, you have to extend the methods.</p><pre><code class="nohighlight hljs">Checkpointer.get_model_prog_state
Checkpointer.get_model_cache
Checkpointer.restore_cache!</code></pre><p><code>ClimaCoupler</code> moves objects to the CPU with <code>Adapt(Array, x)</code>. <code>Adapt</code> traverses the object recursively, and proper <code>Adapt</code> methods have to be defined for every object involved in the chain. The easiest way to do this is using the <code>Adapt.@adapt_structure</code> macro, which defines a recursive Adapt for the given object.</p><p>Types to watch for:</p><ul><li><code>MPI</code> related objects (e.g., <code>MPICommsContext</code>)</li><li><code>TimeVaryingInputs</code> (because they contain <code>NCDatasets</code>, which contain pointers to files)</li></ul><div class="admonition is-warning"><header class="admonition-header">Adapt and references</header><div class="admonition-body"><p>For objects that contain multiple fields referencing the same object, using the <code>Adapt.@adapt_structure</code> macro leads to unnecessary copies of the same object. This happens because <code>Adapt.@adapt_structure</code> defines a recursive <code>Adapt</code> that does not account for the possibility that multiple fields could be referencing the same object. As a result, this means that the same object is recreated over and over again when calling <code>Adapt</code> on the cache. This can easily make the file size of the saved cache much bigger than it needs to be. Because of this, we&#39;ve implemented a <code>CacheIterator</code> object - please see the section below for details.</p></div></div><h3 id="CacheIterator"><a class="docs-heading-anchor" href="#CacheIterator"><code>CacheIterator</code></a><a id="CacheIterator-1"></a><a class="docs-heading-anchor-permalink" href="#CacheIterator" title="Permalink"></a></h3><p>Instead of defining a proper <code>Adapt</code> method for the cache, an alternative approach is to recursively iterate over the cache fields and selectively save only the parts that need to be saved. This recursive iteration is performed by the <code>CacheIterator</code>. To initialize a <code>CacheIterator</code> for a component model, you must implement <code>get_cache_ignore</code>.</p><p>Using the <code>CacheIterator</code> allows <code>adapt</code> to be called on each individual field instead of on the entire cache. Furthermore, the file size can be reduced by avoiding duplicate saves of fields that reference the same memory. This is accomplished by tracking object IDs and storing references to objects instead of creating copies when the same object is encountered multiple times.</p><p>This approach allows for a signficant reducation in the file size of the cache.</p><h2 id="Checkpointer-API"><a class="docs-heading-anchor" href="#Checkpointer-API">Checkpointer API</a><a id="Checkpointer-API-1"></a><a class="docs-heading-anchor-permalink" href="#Checkpointer-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCoupler.Checkpointer.get_model_prog_state" href="#ClimaCoupler.Checkpointer.get_model_prog_state"><code>ClimaCoupler.Checkpointer.get_model_prog_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_model_prog_state(sim::Interfacer.ComponentModelSimulation)</code></pre><p>Returns the model state of a simulation as a <code>ClimaCore.FieldVector</code>. This is a template function that should be implemented for each component model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCoupler.Checkpointer.get_model_cache" href="#ClimaCoupler.Checkpointer.get_model_cache"><code>ClimaCoupler.Checkpointer.get_model_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_model_cache(sim::Interfacer.ComponentModelSimulation)</code></pre><p>Returns the model cache of a simulation. This is a template function that should be implemented for each component model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCoupler.Checkpointer.get_model_cache_to_checkpoint" href="#ClimaCoupler.Checkpointer.get_model_cache_to_checkpoint"><code>ClimaCoupler.Checkpointer.get_model_cache_to_checkpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_model_cache_to_checkpoint(sim::Interfacer.ComponentModelSimulation)</code></pre><p>Prepare the cache for checkpointing by moving the entire cache to CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L118-L122">source</a></section><section><div><pre><code class="nohighlight hljs">get_model_cache_to_checkpoint(sim::Interfacer.AtmosModelSimulation)</code></pre><p>Prepare the atmos cache for checkpoint by selectively moving parts of the atmos cache to CPU instead of moving the entire atmos cache to CPU, resulting in a much smaller saved file.</p><p><strong>Implementation Details</strong></p><p>When moving the cache from GPU to CPU, calling <code>adapt</code> on the entire cache creates unnecessary duplicate objects because <code>adapt</code> is not properly defined for the entire cache structure. This function addresses three key issues:</p><ol><li><p><strong>Individual adaptation</strong>: On GPU, <code>adapt</code> is called on each object separately rather than on the entire cache at once.</p></li><li><p><strong>Deduplication</strong>: Objects sharing the same object ID are not duplicated. Instead, references to already-processed objects are reused.</p></li><li><p><strong>Selective saving</strong>: Only the parts of the cache needed for restoration are saved.</p></li></ol><p><strong>Returns</strong></p><p>A vector of objects from the cache. Elements may reference the same underlying data if they share object IDs. The order of the objects in the vector is determined by <code>CacheIterator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L127-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCoupler.Checkpointer.restart!" href="#ClimaCoupler.Checkpointer.restart!"><code>ClimaCoupler.Checkpointer.restart!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">restart!(cs::CoupledSimulation, checkpoint_dir, checkpoint_t, restart_cache)</code></pre><p>Overwrite the content of <code>cs</code> with checkpoints in <code>checkpoint_dir</code> at time <code>checkpoint_t</code>.</p><p>If <code>restart_cache</code> is true, the cache will be read from the restart file using <code>restore_cache!</code>. Otherwise, the cache will be left unchanged.</p><p>Return a true if the simulation was restarted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L238-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCoupler.Checkpointer.checkpoint_sims" href="#ClimaCoupler.Checkpointer.checkpoint_sims"><code>ClimaCoupler.Checkpointer.checkpoint_sims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">checkpoint_sims(cs::CoupledSimulation)</code></pre><p>This is a callback function that checkpoints all simulations defined in the current coupled simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCoupler.Checkpointer.t_start_from_checkpoint" href="#ClimaCoupler.Checkpointer.t_start_from_checkpoint"><code>ClimaCoupler.Checkpointer.t_start_from_checkpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">t_start_from_checkpoint(checkpoint_dir)</code></pre><p>Look for restart files in <code>checkpoint_dir</code>, if found, return the time of the latest. If not found, return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L325-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCoupler.Checkpointer.restore!" href="#ClimaCoupler.Checkpointer.restore!"><code>ClimaCoupler.Checkpointer.restore!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">restore!(v1, v2, comms_ctx; name = &quot;&quot;, ignore = Set())</code></pre><p>Recursively traverse <code>v1</code> and <code>v2</code>, setting each field of <code>v1</code> with the corresponding field in <code>v2</code>. In this, ignore all the properties that have name within the <code>ignore</code> iterable.</p><p>This is intended to be used when restarting a simulation&#39;s cache object from a checkpoint.</p><p><code>ignore</code> is useful when there are stateful properties, such as live pointers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L357-L368">source</a></section><section><div><pre><code class="nohighlight hljs">restore!(
    v1::Union{
        AbstractTimeVaryingInput,
        ClimaComms.AbstractCommsContext,
        ClimaComms.AbstractDevice,
        UnionAll,
        DataType,
    },
    v2::Union{
        AbstractTimeVaryingInput,
        ClimaComms.AbstractCommsContext,
        ClimaComms.AbstractDevice,
        UnionAll,
        DataType,
    },
    _comms_ctx;
    name = &quot;&quot;,
    ignore = Set(),
)</code></pre><p>Ignore certain types that don&#39;t need to be restored. <code>UnionAll</code> and <code>DataType</code> are infinitely recursive, so we also ignore those.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L391-L414">source</a></section><section><div><pre><code class="nohighlight hljs">restore!(
    v1::Union{CC.DataLayouts.AbstractData, AbstractArray},
    v2::Union{CC.DataLayouts.AbstractData, AbstractArray},
    comms_ctx;
    name = &quot;&quot;,
    ignore = Set(),
)</code></pre><p>For array-like objects, we move the original data (v2) to the device of the new data (v1). Then we copy the original data to the new object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L437-L449">source</a></section><section><div><pre><code class="nohighlight hljs">restore!(v1::LinearIndices, v2::AbstractArray, comms_ctx; name = &quot;&quot;, ignore = Set())</code></pre><p>Special case to compare LinearIndices to AbstractArray, which is needed for ClimaAtmos v0.32.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L465-L469">source</a></section><section><div><pre><code class="nohighlight hljs">restore!(
    v1::Union{StaticArrays.StaticArray, Number, UnitRange, LinRange, Symbol},
    v2::Union{StaticArrays.StaticArray, Number, UnitRange, LinRange, Symbol},
    comms_ctx;
    name = &quot;&quot;,
    ignore = Set(),
)</code></pre><p>Ensure that immutable objects have been initialized correctly, as they cannot be restored from a checkpoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L481-L492">source</a></section><section><div><pre><code class="nohighlight hljs">restore!(v1::Dict, v2::Dict, comms_ctx; name = &quot;&quot;, ignore = Set())</code></pre><p>RRTMGP has some internal dictionaries, which we check for consistency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L518-L522">source</a></section><section><div><pre><code class="nohighlight hljs">restore!(
    v1::T1,
    v2::T2,
    comms_ctx;
    name = &quot;&quot;,
    ignore = Set(),
) where {
    T1 &lt;: Union{Dates.DateTime, Dates.UTInstant, Dates.Millisecond},
    T2 &lt;: Union{Dates.DateTime, Dates.UTInstant, Dates.Millisecond},
}</code></pre><p>Special case to compare time-related types to allow different timestamps during restore.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCoupler.jl/blob/5655bdacf12f4461868ca975496120e87b1c38ca/src/Checkpointer.jl#L528-L541">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../input/">« Input</a><a class="docs-footer-nextpage" href="../conservation/">Conservation Checks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 23 December 2025 14:19">Tuesday 23 December 2025</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
