<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AMIP Driver · ClimaCoupler.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.svg" alt="ClimaCoupler.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">ClimaCoupler.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Sea Breeze</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sea_breeze/atmos_rhs/">Atmospheric Model</a></li><li><a class="tocitem" href="../../sea_breeze/land_rhs/">Land Model</a></li><li><a class="tocitem" href="../../sea_breeze/ocean_rhs/">Ocean Model</a></li><li><a class="tocitem" href="../../sea_breeze/run/">Coupled Sea Breeze</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">AMIP</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>AMIP Driver</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Logging"><span>Logging</span></a></li><li><a class="tocitem" href="#Configuration-initialization"><span>Configuration initialization</span></a></li><li><a class="tocitem" href="#ClimaESM-packages"><span>ClimaESM packages</span></a></li><li><a class="tocitem" href="#Coupler-specific-imports"><span>Coupler specific imports</span></a></li><li><a class="tocitem" href="#Setup-Communication-Context"><span>Setup Communication Context</span></a></li><li><a class="tocitem" href="#Data-File-Paths"><span>Data File Paths</span></a></li><li><a class="tocitem" href="#Component-Model-Initialization"><span>Component Model Initialization</span></a></li><li><a class="tocitem" href="#Coupler-Initialization"><span>Coupler Initialization</span></a></li><li><a class="tocitem" href="#Initialize-Conservation-Checks"><span>Initialize Conservation Checks</span></a></li><li><a class="tocitem" href="#Initialize-Callbacks"><span>Initialize Callbacks</span></a></li><li><a class="tocitem" href="#Initialize-turbulent-fluxes"><span>Initialize turbulent fluxes</span></a></li><li><a class="tocitem" href="#Initialize-Coupled-Simulation"><span>Initialize Coupled Simulation</span></a></li><li><a class="tocitem" href="#Restart-component-model-states-if-specified"><span>Restart component model states if specified</span></a></li><li><a class="tocitem" href="#Initialize-Component-Model-Exchange"><span>Initialize Component Model Exchange</span></a></li><li><a class="tocitem" href="#Coupling-Loop"><span>Coupling Loop</span></a></li><li><a class="tocitem" href="#Postprocessing"><span>Postprocessing</span></a></li></ul></li></ul></li></ul></li><li><span class="tocitem">Coupler Interface</span><ul><li><a class="tocitem" href="../../../bcreader/">BCReader</a></li><li><a class="tocitem" href="../../../checkpointer/">Checkpointer</a></li><li><a class="tocitem" href="../../../conservation/">Conservation Checks</a></li><li><a class="tocitem" href="../../../diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../../../fieldexchanger/">FieldExchanger</a></li><li><a class="tocitem" href="../../../fluxcalculator/">FluxCalculator</a></li><li><a class="tocitem" href="../../../interfacer/">Interfacer</a></li><li><a class="tocitem" href="../../../postprocessor/">PostProcessor</a></li><li><a class="tocitem" href="../../../regridder/">Regridder</a></li><li><a class="tocitem" href="../../../testhelper/">TestHelper</a></li><li><a class="tocitem" href="../../../timemanager/">TimeManager</a></li><li><a class="tocitem" href="../../../utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Performance</span><ul><li><a class="tocitem" href="../../../performance/">Performance Analysis Tools</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">AMIP</a></li><li class="is-active"><a href>AMIP Driver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AMIP Driver</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaCoupler.jl/blob/main/docs/src/generated/amip/run_amip.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="AMIP-Driver"><a class="docs-heading-anchor" href="#AMIP-Driver">AMIP Driver</a><a id="AMIP-Driver-1"></a><a class="docs-heading-anchor-permalink" href="#AMIP-Driver" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>AMIP is a standard experimental protocol of the Program for Climate Model Diagnosis &amp; Intercomparison (PCMDI). It is used as a model benchmark for the atmospheric and land model components, while sea-surface temperatures (SST) and sea-ice concentration (SIC) are prescribed using time-interpolations between monthly observed data. We use standard data files with original sources:</p><ul><li>SST and SIC: https://gdex.ucar.edu/dataset/158_asphilli.html</li><li>land-sea mask: https://www.ncl.ucar.edu/Applications/Data/#cdf</li></ul><p>For more information, see the PCMDI&#39;s specifications for <a href="https://pcmdi.github.io/mips/amip/">AMIP I</a> and <a href="https://pcmdi.github.io/mips/amip2/">AMIP II</a>.</p><p>This driver contains two modes. The full <code>AMIP</code> mode and a <code>SlabPlanet</code> (all surfaces are thermal slabs) mode. Since <code>AMIP</code> is not a closed system, the <code>SlabPlanet</code> mode is useful for checking conservation properties of the coupling.</p><h2 id="Logging"><a class="docs-heading-anchor" href="#Logging">Logging</a><a id="Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Logging" title="Permalink"></a></h2><p>When Julia 1.10+ is used interactively, stacktraces contain reduced type information to make them shorter. Given that ClimaCore objects are heavily parametrized, non-abbreviated stacktraces are hard to read, so we force abbreviated stacktraces even in non-interactive runs. (See also <code>Base.type_limited_string_from_context()</code>)</p><pre><code class="language-julia hljs">redirect_stderr(IOContext(stderr, :stacktrace_types_limited =&gt; Ref(false)))</code></pre><h2 id="Configuration-initialization"><a class="docs-heading-anchor" href="#Configuration-initialization">Configuration initialization</a><a id="Configuration-initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration-initialization" title="Permalink"></a></h2><p>Here we import standard Julia packages, ClimaESM packages, parse in command-line arguments (if none are specified then the defaults in <code>cli_options.jl</code> apply). We then specify the input data file names. If these are not already downloaded, include <code>artifacts/download_artifacts.jl</code>.</p><h3 id="Package-Import"><a class="docs-heading-anchor" href="#Package-Import">Package Import</a><a id="Package-Import-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Import" title="Permalink"></a></h3><pre><code class="language-julia hljs"># standard packages
import Dates
import YAML</code></pre><h2 id="ClimaESM-packages"><a class="docs-heading-anchor" href="#ClimaESM-packages">ClimaESM packages</a><a id="ClimaESM-packages-1"></a><a class="docs-heading-anchor-permalink" href="#ClimaESM-packages" title="Permalink"></a></h2><pre><code class="language-julia hljs">import ClimaAtmos as CA
import ClimaComms
import ClimaCore as CC</code></pre><h2 id="Coupler-specific-imports"><a class="docs-heading-anchor" href="#Coupler-specific-imports">Coupler specific imports</a><a id="Coupler-specific-imports-1"></a><a class="docs-heading-anchor-permalink" href="#Coupler-specific-imports" title="Permalink"></a></h2><pre><code class="language-julia hljs">import ClimaCoupler
import ClimaCoupler:
    BCReader,
    ConservationChecker,
    Checkpointer,
    Diagnostics,
    FieldExchanger,
    FluxCalculator,
    Interfacer,
    Regridder,
    TimeManager,
    Utilities

pkg_dir = pkgdir(ClimaCoupler)</code></pre><h3 id="Helper-Functions"><a class="docs-heading-anchor" href="#Helper-Functions">Helper Functions</a><a id="Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Functions" title="Permalink"></a></h3><p>These will be eventually moved to their respective component model and diagnostics packages, and so they should not contain any internals of the ClimaCoupler source code, except extensions to the Interfacer functions.</p><pre><code class="language-julia hljs"># helpers for component models
include(&quot;components/atmosphere/climaatmos.jl&quot;)
include(&quot;components/land/climaland_bucket.jl&quot;)
include(&quot;components/ocean/slab_ocean.jl&quot;)
include(&quot;components/ocean/prescr_seaice.jl&quot;)
include(&quot;components/ocean/eisenman_seaice.jl&quot;)

# helpers for user-specified IO
include(&quot;user_io/user_diagnostics.jl&quot;)
include(&quot;user_io/user_logging.jl&quot;)
include(&quot;user_io/debug_plots.jl&quot;)
include(&quot;user_io/io_helpers.jl&quot;)</code></pre><h3 id="Configuration-Dictionaries"><a class="docs-heading-anchor" href="#Configuration-Dictionaries">Configuration Dictionaries</a><a id="Configuration-Dictionaries-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration-Dictionaries" title="Permalink"></a></h3><p>Each simulation mode has its own configuration dictionary. The <code>config_dict</code> of each simulation is a merge of the default configuration dictionary and the simulation-specific configuration dictionary, which allows the user to override the default settings.</p><p>We can additionally pass the configuration dictionary to the component model initializers, which will then override the default settings of the component models.</p><pre><code class="language-julia hljs"># coupler simulation default configuration
include(&quot;cli_options.jl&quot;)
parsed_args = parse_commandline(argparse_settings())

if isinteractive()
    parsed_args[&quot;config_file&quot;] =
        isnothing(parsed_args[&quot;config_file&quot;]) ? joinpath(pkg_dir, &quot;config/ci_configs/interactive_debug.yml&quot;) :
        parsed_args[&quot;config_file&quot;]
    parsed_args[&quot;job_id&quot;] = &quot;interactive_debug&quot;
end

# the unique job id should be passed in via the command line
job_id = parsed_args[&quot;job_id&quot;]
@assert !isnothing(job_id) &quot;job_id must be passed in via the command line&quot;

# read in config dictionary from file, overriding the coupler defaults in `parsed_args`
config_dict = YAML.load_file(parsed_args[&quot;config_file&quot;])
config_dict = merge(parsed_args, config_dict)

# get component model dictionaries (if applicable)
atmos_config_dict, config_dict = get_atmos_config_dict(config_dict, job_id)
atmos_config_object = CA.AtmosConfig(atmos_config_dict)

# read in some parsed command line arguments, required by this script
mode_name = config_dict[&quot;mode_name&quot;]
energy_check = config_dict[&quot;energy_check&quot;]
const FT = config_dict[&quot;FLOAT_TYPE&quot;] == &quot;Float64&quot; ? Float64 : Float32
land_sim_name = &quot;bucket&quot;
t_end = Float64(time_to_seconds(config_dict[&quot;t_end&quot;]))
t_start = 0.0
tspan = (t_start, t_end)
Δt_cpl = Float64(config_dict[&quot;dt_cpl&quot;])
saveat = Float64(time_to_seconds(config_dict[&quot;dt_save_to_sol&quot;]))
date0 = date = Dates.DateTime(config_dict[&quot;start_date&quot;], Dates.dateformat&quot;yyyymmdd&quot;)
mono_surface = config_dict[&quot;mono_surface&quot;]
hourly_checkpoint = config_dict[&quot;hourly_checkpoint&quot;]
hourly_checkpoint_dt = config_dict[&quot;hourly_checkpoint_dt&quot;]
restart_dir = config_dict[&quot;restart_dir&quot;]
restart_t = Int(config_dict[&quot;restart_t&quot;])
evolving_ocean = config_dict[&quot;evolving_ocean&quot;]
dt_rad = config_dict[&quot;dt_rad&quot;]
use_coupler_diagnostics = config_dict[&quot;use_coupler_diagnostics&quot;]</code></pre><h2 id="Setup-Communication-Context"><a class="docs-heading-anchor" href="#Setup-Communication-Context">Setup Communication Context</a><a id="Setup-Communication-Context-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Communication-Context" title="Permalink"></a></h2><p>We set up communication context for CPU single thread/CPU with MPI/GPU. If no device is passed to <code>ClimaComms.context()</code> then <code>ClimaComms</code> automatically selects the device from which this code is called.</p><pre><code class="language-julia hljs">comms_ctx = Utilities.get_comms_context(parsed_args)
ClimaComms.init(comms_ctx)

# make sure we don&#39;t use animations for GPU runs
if comms_ctx.device isa ClimaComms.CUDADevice
    config_dict[&quot;anim&quot;] = false
end</code></pre><h3 id="I/O-Directory-Setup"><a class="docs-heading-anchor" href="#I/O-Directory-Setup">I/O Directory Setup</a><a id="I/O-Directory-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#I/O-Directory-Setup" title="Permalink"></a></h3><p><code>setup_output_dirs</code> returns <code>dir_paths.output = COUPLER_OUTPUT_DIR</code>, which is the directory where the output of the simulation will be saved, and <code>dir_paths.artifacts</code> is the directory where the plots (from postprocessing and the conservation checks) of the simulation will be saved. <code>dir_paths.regrid</code> is the directory where the regridding temporary files will be saved.</p><pre><code class="language-julia hljs">COUPLER_OUTPUT_DIR = joinpath(config_dict[&quot;coupler_output_dir&quot;], joinpath(mode_name, job_id))
dir_paths = setup_output_dirs(output_dir = COUPLER_OUTPUT_DIR, comms_ctx = comms_ctx)


if ClimaComms.iamroot(comms_ctx)
    @info(dir_paths.output)
    config_dict[&quot;print_config_dict&quot;] &amp;&amp; @info(config_dict)
end</code></pre><h2 id="Data-File-Paths"><a class="docs-heading-anchor" href="#Data-File-Paths">Data File Paths</a><a id="Data-File-Paths-1"></a><a class="docs-heading-anchor-permalink" href="#Data-File-Paths" title="Permalink"></a></h2><p>The data files are downloaded from the <code>ClimaCoupler</code> artifacts directory. If the data files are not present, they are downloaded from the original sources.</p><pre><code class="language-julia hljs">include(joinpath(pkgdir(ClimaCoupler), &quot;artifacts&quot;, &quot;artifact_funcs.jl&quot;))
sst_data = artifact_data(sst_dataset_path(), &quot;sst&quot;, &quot;SST&quot;, dir_paths.regrid, date0, t_start, t_end, comms_ctx)
sic_data = artifact_data(sic_dataset_path(), &quot;sic&quot;, &quot;SEAICE&quot;, dir_paths.regrid, date0, t_start, t_end, comms_ctx)
co2_data = artifact_data(co2_dataset_path(), &quot;mauna_loa_co2&quot;, &quot;co2&quot;, dir_paths.regrid, date0, t_start, t_end, comms_ctx)
land_mask_data = artifact_data(mask_dataset_path(), &quot;seamask&quot;)</code></pre><h2 id="Component-Model-Initialization"><a class="docs-heading-anchor" href="#Component-Model-Initialization">Component Model Initialization</a><a id="Component-Model-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Component-Model-Initialization" title="Permalink"></a></h2><p>Here we set initial and boundary conditions for each component model. Each component model is required to have an <code>init</code> function that returns a <code>ComponentModelSimulation</code> object (see <code>Interfacer</code> docs for more details).</p><h3 id="Atmosphere"><a class="docs-heading-anchor" href="#Atmosphere">Atmosphere</a><a id="Atmosphere-1"></a><a class="docs-heading-anchor-permalink" href="#Atmosphere" title="Permalink"></a></h3><p>This uses the <code>ClimaAtmos.jl</code> model, with parameterization options specified in the <code>atmos_config_object</code> dictionary.</p><pre><code class="language-julia hljs">Utilities.show_memory_usage(comms_ctx)

# init atmos model component
atmos_sim = atmos_init(atmos_config_object);
Utilities.show_memory_usage(comms_ctx)

thermo_params = get_thermo_params(atmos_sim) # TODO: this should be shared by all models #610</code></pre><h3 id="Boundary-Space"><a class="docs-heading-anchor" href="#Boundary-Space">Boundary Space</a><a id="Boundary-Space-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Space" title="Permalink"></a></h3><p>We use a common <code>Space</code> for all global surfaces. This enables the MPI processes to operate on the same columns in both the atmospheric and surface components, so exchanges are parallelized. Note this is only possible when the atmosphere and surface are of the same horizontal resolution.</p><pre><code class="language-julia hljs"># init a 2D boundary space at the surface
boundary_space = CC.Spaces.horizontal_space(atmos_sim.domain.face_space) # TODO: specify this in the coupler and pass it to all component models #665</code></pre><h3 id="Land-sea-Fraction"><a class="docs-heading-anchor" href="#Land-sea-Fraction">Land-sea Fraction</a><a id="Land-sea-Fraction-1"></a><a class="docs-heading-anchor-permalink" href="#Land-sea-Fraction" title="Permalink"></a></h3><p>This is a static field that contains the area fraction of land and sea, ranging from 0 to 1. If applicable, sea ice is included in the sea fraction. at this stage. Note that land-sea area fraction is different to the land-sea mask, which is a binary field (masks are used internally by the coupler to indicate passive cells that are not populated by a given component model).</p><pre><code class="language-julia hljs">land_area_fraction =
    FT.(
        Regridder.land_fraction(
            FT,
            dir_paths.regrid,
            comms_ctx,
            land_mask_data,
            &quot;LSMASK&quot;,
            boundary_space,
            mono = mono_surface,
        )
    )
Utilities.show_memory_usage(comms_ctx)</code></pre><h3 id="Surface-Models:-AMIP-and-SlabPlanet-Modes"><a class="docs-heading-anchor" href="#Surface-Models:-AMIP-and-SlabPlanet-Modes">Surface Models: AMIP and SlabPlanet Modes</a><a id="Surface-Models:-AMIP-and-SlabPlanet-Modes-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-Models:-AMIP-and-SlabPlanet-Modes" title="Permalink"></a></h3><p>Both modes evolve <code>ClimaLand.jl</code>&#39;s bucket model.</p><p>In the <code>AMIP</code> mode, all ocean properties are prescribed from a file, while sea-ice temperatures are calculated using observed SIC and assuming a 2m thickness of the ice.</p><p>In the <code>SlabPlanet</code> mode, all ocean and sea ice are dynamical models, namely thermal slabs, with different parameters. We have several <code>SlabPlanet</code> versions</p><ul><li><code>slabplanet</code> = land + slab ocean</li><li><code>slabplanet_aqua</code> = slab ocean everywhere</li><li><code>slabplanet_terra</code> = land everywhere</li><li><code>slabplanet_eisenman</code> = land + slab ocean + slab sea ice with an evolving thickness</li></ul><pre><code class="language-julia hljs">ClimaComms.iamroot(comms_ctx) &amp;&amp; @info(mode_name)
if mode_name == &quot;amip&quot;
    ClimaComms.iamroot(comms_ctx) &amp;&amp; @info(&quot;AMIP boundary conditions - do not expect energy conservation&quot;)

    # land model
    land_sim = bucket_init(
        FT,
        tspan,
        config_dict[&quot;land_domain_type&quot;],
        config_dict[&quot;land_albedo_type&quot;],
        config_dict[&quot;land_temperature_anomaly&quot;],
        dir_paths.regrid;
        dt = Δt_cpl,
        space = boundary_space,
        saveat = saveat,
        area_fraction = land_area_fraction,
        date_ref = date0,
        t_start = t_start,
        energy_check = energy_check,
    )

    # ocean stub
    SST_info = BCReader.bcfile_info_init(
        FT,
        dir_paths.regrid,
        sst_data,
        &quot;SST&quot;,
        boundary_space,
        comms_ctx,
        interpolate_daily = true,
        scaling_function = scale_sst, ## convert to Kelvin
        land_fraction = land_area_fraction,
        date0 = date0,
        mono = mono_surface,
    )

    BCReader.update_midmonth_data!(date0, SST_info)
    SST_init = BCReader.interpolate_midmonth_to_daily(date0, SST_info)
    ocean_sim = Interfacer.SurfaceStub((;
        T_sfc = SST_init,
        ρ_sfc = CC.Fields.zeros(boundary_space),
        z0m = FT(1e-3),
        z0b = FT(1e-3),
        beta = FT(1),
        α_direct = CC.Fields.ones(boundary_space) .* FT(0.06),
        α_diffuse = CC.Fields.ones(boundary_space) .* FT(0.06),
        area_fraction = (FT(1) .- land_area_fraction),
        phase = TD.Liquid(),
        thermo_params = thermo_params,
    ))

    # sea ice model
    SIC_info = BCReader.bcfile_info_init(
        FT,
        dir_paths.regrid,
        sic_data,
        &quot;SEAICE&quot;,
        boundary_space,
        comms_ctx,
        interpolate_daily = true,
        scaling_function = scale_sic, ## convert to fraction
        land_fraction = land_area_fraction,
        date0 = date0,
        mono = mono_surface,
    )
    BCReader.update_midmonth_data!(date0, SIC_info)
    SIC_init = BCReader.interpolate_midmonth_to_daily(date0, SIC_info)
    ice_fraction = get_ice_fraction.(SIC_init, mono_surface)
    ice_sim = ice_init(
        FT;
        tspan = tspan,
        dt = Δt_cpl,
        space = boundary_space,
        saveat = saveat,
        area_fraction = ice_fraction,
        thermo_params = thermo_params,
    )

    # CO2 concentration from temporally varying file
    CO2_info = BCReader.bcfile_info_init(
        FT,
        dir_paths.regrid,
        co2_data,
        &quot;co2&quot;,
        boundary_space,
        comms_ctx,
        interpolate_daily = true,
        land_fraction = ones(boundary_space),
        date0 = date0,
        mono = mono_surface,
    )

    BCReader.update_midmonth_data!(date0, CO2_info)
    CO2_init = BCReader.interpolate_midmonth_to_daily(date0, CO2_info)
    Interfacer.update_field!(atmos_sim, Val(:co2), CO2_init)

    mode_specifics = (; name = mode_name, SST_info = SST_info, SIC_info = SIC_info, CO2_info = CO2_info)
    Utilities.show_memory_usage(comms_ctx)

elseif mode_name in (&quot;slabplanet&quot;, &quot;slabplanet_aqua&quot;, &quot;slabplanet_terra&quot;)


    land_area_fraction = mode_name == &quot;slabplanet_aqua&quot; ? land_area_fraction .* 0 : land_area_fraction
    land_area_fraction = mode_name == &quot;slabplanet_terra&quot; ? land_area_fraction .* 0 .+ 1 : land_area_fraction

    # land model
    land_sim = bucket_init(
        FT,
        tspan,
        config_dict[&quot;land_domain_type&quot;],
        config_dict[&quot;land_albedo_type&quot;],
        config_dict[&quot;land_temperature_anomaly&quot;],
        dir_paths.regrid;
        dt = Δt_cpl,
        space = boundary_space,
        saveat = saveat,
        area_fraction = land_area_fraction,
        date_ref = date0,
        t_start = t_start,
        energy_check = energy_check,
    )

    # ocean model
    ocean_sim = ocean_init(
        FT;
        tspan = tspan,
        dt = Δt_cpl,
        space = boundary_space,
        saveat = saveat,
        area_fraction = (FT(1) .- land_area_fraction), ## NB: this ocean fraction includes areas covered by sea ice (unlike the one contained in the cs)
        thermo_params = thermo_params,
        evolving = evolving_ocean,
    )

    # sea ice stub (here set to zero area coverage)
    ice_sim = Interfacer.SurfaceStub((;
        T_sfc = CC.Fields.ones(boundary_space),
        ρ_sfc = CC.Fields.zeros(boundary_space),
        z0m = FT(0),
        z0b = FT(0),
        beta = FT(1),
        α_direct = CC.Fields.ones(boundary_space) .* FT(1),
        α_diffuse = CC.Fields.ones(boundary_space) .* FT(1),
        area_fraction = CC.Fields.zeros(boundary_space),
        phase = TD.Ice(),
        thermo_params = thermo_params,
    ))

    mode_specifics = (; name = mode_name, SST_info = nothing, SIC_info = nothing)
    Utilities.show_memory_usage(comms_ctx)

elseif mode_name == &quot;slabplanet_eisenman&quot;

    # land model
    land_sim = bucket_init(
        FT,
        tspan,
        config_dict[&quot;land_domain_type&quot;],
        config_dict[&quot;land_albedo_type&quot;],
        config_dict[&quot;land_temperature_anomaly&quot;],
        dir_paths.regrid;
        dt = Δt_cpl,
        space = boundary_space,
        saveat = saveat,
        area_fraction = land_area_fraction,
        date_ref = date0,
        t_start = t_start,
        energy_check = energy_check,
    )

    # ocean stub (here set to zero area coverage)
    ocean_sim = ocean_init(
        FT;
        tspan = tspan,
        dt = Δt_cpl,
        space = boundary_space,
        saveat = saveat,
        area_fraction = CC.Fields.zeros(boundary_space), # zero, since ML is calculated below
        thermo_params = thermo_params,
    )

    # sea ice + ocean model
    ice_sim = eisenman_seaice_init(
        FT,
        tspan,
        space = boundary_space,
        area_fraction = (FT(1) .- land_area_fraction),
        dt = Δt_cpl,
        saveat = saveat,
        thermo_params = thermo_params,
    )

    mode_specifics = (; name = mode_name, SST_info = nothing, SIC_info = nothing)
    Utilities.show_memory_usage(comms_ctx)
end</code></pre><h2 id="Coupler-Initialization"><a class="docs-heading-anchor" href="#Coupler-Initialization">Coupler Initialization</a><a id="Coupler-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Coupler-Initialization" title="Permalink"></a></h2><p>The coupler needs to contain exchange information, manage the calendar and be able to access all component models. It can also optionally save online diagnostics. These are all initialized here and saved in a global <code>CoupledSimulation</code> struct, <code>cs</code>.</p><pre><code class="language-julia hljs"># coupler exchange fields
coupler_field_names = (
    :T_S,
    :z0m_S,
    :z0b_S,
    :ρ_sfc,
    :q_sfc,
    :surface_direct_albedo,
    :surface_diffuse_albedo,
    :beta,
    :F_turb_energy,
    :F_turb_moisture,
    :F_turb_ρτxz,
    :F_turb_ρτyz,
    :F_radiative,
    :P_liq,
    :P_snow,
    :radiative_energy_flux_toa,
    :P_net,
    :temp1,
    :temp2,
)
coupler_fields =
    NamedTuple{coupler_field_names}(ntuple(i -&gt; CC.Fields.zeros(boundary_space), length(coupler_field_names)))
Utilities.show_memory_usage(comms_ctx)

# model simulations
model_sims = (atmos_sim = atmos_sim, ice_sim = ice_sim, land_sim = land_sim, ocean_sim = ocean_sim);

# dates
dates = (; date = [date], date0 = [date0], date1 = [Dates.firstdayofmonth(date0)], new_month = [false])</code></pre><h3 id="Online-Diagnostics"><a class="docs-heading-anchor" href="#Online-Diagnostics">Online Diagnostics</a><a id="Online-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Online-Diagnostics" title="Permalink"></a></h3><p>User can write custom diagnostics in the <code>user_diagnostics.jl</code>. Note, this will be replaced by the diagnostics framework currently in ClimaAtmos, once it is abstracted into a more general package, so we can use it to save fields from surface models.</p><pre><code class="language-julia hljs">if use_coupler_diagnostics
    monthly_3d_diags = Diagnostics.init_diagnostics(
        (:T, :u, :q_tot, :q_liq_ice),
        atmos_sim.domain.center_space;
        save = TimeManager.Monthly(),
        operations = (; accumulate = Diagnostics.TimeMean([Int(0)])),
        output_dir = COUPLER_OUTPUT_DIR,
        name_tag = &quot;monthly_mean_3d_&quot;,
    )

    monthly_3d_diags = Diagnostics.init_diagnostics(
        (:T, :u, :q_tot, :q_liq_ice),
        atmos_sim.domain.center_space;
        save = TimeManager.Monthly(),
        operations = (; accumulate = Diagnostics.TimeMean([Int(0)])),
        output_dir = dir_paths.output,
        name_tag = &quot;monthly_mean_3d_&quot;,
    )

    monthly_2d_diags = Diagnostics.init_diagnostics(
        (:precipitation_rate, :toa_fluxes, :T_sfc, :tubulent_energy_fluxes),
        boundary_space;
        save = TimeManager.Monthly(),
        operations = (; accumulate = Diagnostics.TimeMean([Int(0)])),
        output_dir = dir_paths.output,
        name_tag = &quot;monthly_mean_2d_&quot;,
    )

    diagnostics = (monthly_3d_diags, monthly_2d_diags)
    Utilities.show_memory_usage(comms_ctx)
else
    diagnostics = ()
end</code></pre><h2 id="Initialize-Conservation-Checks"><a class="docs-heading-anchor" href="#Initialize-Conservation-Checks">Initialize Conservation Checks</a><a id="Initialize-Conservation-Checks-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-Conservation-Checks" title="Permalink"></a></h2><p>The conservation checks are used to monitor the global energy and water conservation of the coupled system. The checks are only applicable to the <code>slabplanet</code> mode, as the <code>amip</code> mode is not a closed system. The conservation checks are initialized here and saved in a global <code>ConservationChecks</code> struct, <code>conservation_checks</code>.</p><pre><code class="language-julia hljs"># init conservation info collector
conservation_checks = nothing
if energy_check
    @assert(
        mode_name[1:10] == &quot;slabplanet&quot; &amp;&amp; !CA.is_distributed(ClimaComms.context(boundary_space)),
        &quot;Only non-distributed slabplanet allowable for energy_check&quot;
    )
    conservation_checks = (;
        energy = ConservationChecker.EnergyConservationCheck(model_sims),
        water = ConservationChecker.WaterConservationCheck(model_sims),
    )
end</code></pre><h2 id="Initialize-Callbacks"><a class="docs-heading-anchor" href="#Initialize-Callbacks">Initialize Callbacks</a><a id="Initialize-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-Callbacks" title="Permalink"></a></h2><p>Callbacks are used to update at a specified interval. The callbacks are initialized here and saved in a global <code>Callbacks</code> struct, <code>callbacks</code>. The <code>trigger_callback!</code> function is used to call the callback during the simulation below.</p><p>The frequency of the callbacks is specified in the <code>HourlyCallback</code> and <code>MonthlyCallback</code> structs. The <code>func</code> field specifies the function to be called, the <code>ref_date</code> field specifies the reference (first) date for the callback, and the <code>active</code> field specifies whether the callback is active or not.</p><p>The currently implemented callbacks are:</p><ul><li><code>checkpoint_cb</code>: generates a checkpoint of all model states at a specified interval. This is mainly used for restarting simulations.</li><li><code>update_firstdayofmonth!_cb</code>: generates a callback to update the first day of the month for monthly message print (and other monthly operations).</li><li><code>albedo_cb</code>: for the amip mode, the water albedo is time varying (since the reflectivity of water depends on insolation and wave characteristics, with the latter being approximated from wind speed). It is updated at the same frequency as the atmospheric radiation. NB: Eventually, we will call all of radiation from the coupler, in addition to the albedo calculation.</li></ul><pre><code class="language-julia hljs">checkpoint_cb = TimeManager.HourlyCallback(
    dt = hourly_checkpoint_dt,
    func = checkpoint_sims,
    ref_date = [dates.date[1]],
    active = hourly_checkpoint,
) # 20 days
update_firstdayofmonth!_cb = TimeManager.MonthlyCallback(
    dt = FT(1),
    func = TimeManager.update_firstdayofmonth!,
    ref_date = [dates.date1[1]],
    active = true,
)
dt_water_albedo = parse(FT, filter(x -&gt; !occursin(x, &quot;hours&quot;), dt_rad))
albedo_cb = TimeManager.HourlyCallback(
    dt = dt_water_albedo,
    func = FluxCalculator.water_albedo_from_atmosphere!,
    ref_date = [dates.date[1]],
    active = mode_name == &quot;amip&quot;,
)
callbacks =
    (; checkpoint = checkpoint_cb, update_firstdayofmonth! = update_firstdayofmonth!_cb, water_albedo = albedo_cb)</code></pre><h2 id="Initialize-turbulent-fluxes"><a class="docs-heading-anchor" href="#Initialize-turbulent-fluxes">Initialize turbulent fluxes</a><a id="Initialize-turbulent-fluxes-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-turbulent-fluxes" title="Permalink"></a></h2><p>Decide on the type of turbulent flux partition (see <code>FluxCalculator</code> documentation for more details).</p><pre><code class="language-julia hljs">turbulent_fluxes = nothing
if config_dict[&quot;turb_flux_partition&quot;] == &quot;PartitionedStateFluxes&quot;
    turbulent_fluxes = FluxCalculator.PartitionedStateFluxes()
elseif config_dict[&quot;turb_flux_partition&quot;] == &quot;CombinedStateFluxesMOST&quot;
    turbulent_fluxes = FluxCalculator.CombinedStateFluxesMOST()
else
    error(&quot;turb_flux_partition must be either PartitionedStateFluxes or CombinedStateFluxesMOST&quot;)
end</code></pre><h2 id="Initialize-Coupled-Simulation"><a class="docs-heading-anchor" href="#Initialize-Coupled-Simulation">Initialize Coupled Simulation</a><a id="Initialize-Coupled-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-Coupled-Simulation" title="Permalink"></a></h2><p>The coupled simulation is initialized here and saved in a global <code>CoupledSimulation</code> struct, <code>cs</code>. It contains all the information required to run the coupled simulation, including the communication context, the dates, the boundary space, the coupler fields, the configuration dictionary, the conservation checks, the time span, the time step, the land fraction, the model simulations, the mode specifics, the diagnostics, the callbacks, and the directory paths.</p><pre><code class="language-julia hljs">cs = Interfacer.CoupledSimulation{FT}(
    comms_ctx,
    dates,
    boundary_space,
    coupler_fields,
    config_dict,
    conservation_checks,
    [tspan[1], tspan[2]],
    atmos_sim.integrator.t,
    Δt_cpl,
    (; land = land_area_fraction, ocean = zeros(boundary_space), ice = zeros(boundary_space)),
    model_sims,
    mode_specifics,
    diagnostics,
    callbacks,
    dir_paths,
    turbulent_fluxes,
    thermo_params,
);
Utilities.show_memory_usage(comms_ctx)</code></pre><h2 id="Restart-component-model-states-if-specified"><a class="docs-heading-anchor" href="#Restart-component-model-states-if-specified">Restart component model states if specified</a><a id="Restart-component-model-states-if-specified-1"></a><a class="docs-heading-anchor-permalink" href="#Restart-component-model-states-if-specified" title="Permalink"></a></h2><p>If a restart directory is specified and contains output files from the <code>checkpoint_cb</code> callback, the component model states are restarted from those files. The restart directory is specified in the <code>config_dict</code> dictionary. The <code>restart_t</code> field specifies the time step at which the restart is performed.</p><pre><code class="language-julia hljs">if restart_dir !== &quot;unspecified&quot;
    for sim in cs.model_sims
        if Checkpointer.get_model_prog_state(sim) !== nothing
            Checkpointer.restart_model_state!(sim, comms_ctx, restart_t; input_dir = restart_dir)
        end
    end
end</code></pre><h2 id="Initialize-Component-Model-Exchange"><a class="docs-heading-anchor" href="#Initialize-Component-Model-Exchange">Initialize Component Model Exchange</a><a id="Initialize-Component-Model-Exchange-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-Component-Model-Exchange" title="Permalink"></a></h2><p>We need to ensure all models&#39; initial conditions are shared to enable the coupler to calculate the first instance of surface fluxes. Some auxiliary variables (namely surface humidity and radiation fluxes) depend on initial conditions of other component models than those in which the variables are calculated, which is why we need to step these models in time and/or reinitialize them. The concrete steps for proper initialization are:</p><p>1.coupler updates surface model area fractions</p><pre><code class="language-julia hljs">Regridder.update_surface_fractions!(cs)</code></pre><p>2.surface density (<code>ρ_sfc</code>): calculated by the coupler by adiabatically extrapolating atmospheric thermal state to the surface. For this, we need to import surface and atmospheric fields. The model sims are then updated with the new surface density.</p><pre><code class="language-julia hljs">FieldExchanger.import_combined_surface_fields!(cs.fields, cs.model_sims, cs.turbulent_fluxes)
FieldExchanger.import_atmos_fields!(cs.fields, cs.model_sims, cs.boundary_space, cs.turbulent_fluxes)
FieldExchanger.update_model_sims!(cs.model_sims, cs.fields, cs.turbulent_fluxes)</code></pre><p>3.surface vapor specific humidity (<code>q_sfc</code>): step surface models with the new surface density to calculate their respective <code>q_sfc</code> internally</p><pre><code class="language-julia hljs"># TODO: the q_sfc calculation follows the design of the bucket q_sfc, but it would be neater to abstract this from step! (#331)
Interfacer.step!(land_sim, Δt_cpl)
Interfacer.step!(ocean_sim, Δt_cpl)
Interfacer.step!(ice_sim, Δt_cpl)</code></pre><p>4.turbulent fluxes: now we have all information needed for calculating the initial turbulent surface fluxes using the combined state or the partitioned state method</p><pre><code class="language-julia hljs">if cs.turbulent_fluxes isa FluxCalculator.CombinedStateFluxesMOST
    # import the new surface properties into the coupler (note the atmos state was also imported in step 3.)
    FieldExchanger.import_combined_surface_fields!(cs.fields, cs.model_sims, cs.turbulent_fluxes) # i.e. T_sfc, albedo, z0, beta, q_sfc
    # calculate turbulent fluxes inside the atmos cache based on the combined surface state in each grid box
    FluxCalculator.combined_turbulent_fluxes!(cs.model_sims, cs.fields, cs.turbulent_fluxes) # this updates the atmos thermo state, sfc_ts
elseif cs.turbulent_fluxes isa FluxCalculator.PartitionedStateFluxes
    # calculate turbulent fluxes in surface models and save the weighted average in coupler fields
    FluxCalculator.partitioned_turbulent_fluxes!(
        cs.model_sims,
        cs.fields,
        cs.boundary_space,
        FluxCalculator.MoninObukhovScheme(),
        cs.thermo_params,
    )

    # update atmos sfc_conditions for surface temperature
    # TODO: this is hard coded and needs to be simplified (req. CA modification) (#479)
    new_p = get_new_cache(atmos_sim, cs.fields)
    CA.SurfaceConditions.update_surface_conditions!(atmos_sim.integrator.u, new_p, atmos_sim.integrator.t) ## sets T_sfc (but SF calculation not necessary - requires split functionality in CA)
    atmos_sim.integrator.p.precomputed.sfc_conditions .= new_p.precomputed.sfc_conditions
end</code></pre><p>5.reinitialize models + radiative flux: prognostic states and time are set to their initial conditions. For atmos, this also triggers the callbacks and sets a nonzero radiation flux (given the new sfc_conditions)</p><pre><code class="language-julia hljs">FieldExchanger.reinit_model_sims!(cs.model_sims)</code></pre><p>6.update all fluxes: coupler re-imports updated atmos fluxes (radiative fluxes for both <code>turbulent_fluxes</code> types and also turbulent fluxes if <code>turbulent_fluxes isa CombinedStateFluxesMOST</code>, and sends them to the surface component models. If <code>turbulent_fluxes isa PartitionedStateFluxes</code> atmos receives the turbulent fluxes from the coupler.</p><pre><code class="language-julia hljs">FieldExchanger.import_atmos_fields!(cs.fields, cs.model_sims, cs.boundary_space, cs.turbulent_fluxes)
FieldExchanger.update_model_sims!(cs.model_sims, cs.fields, cs.turbulent_fluxes)</code></pre><h2 id="Coupling-Loop"><a class="docs-heading-anchor" href="#Coupling-Loop">Coupling Loop</a><a id="Coupling-Loop-1"></a><a class="docs-heading-anchor-permalink" href="#Coupling-Loop" title="Permalink"></a></h2><p>The coupling loop is the main part of the simulation. It runs the component models sequentially for one coupling timestep (<code>Δt_cpl</code>), and exchanges combined fields and calculates fluxes using combined states. Note that we want to implement this in a dispatchable function to allow for other forms of timestepping (e.g. leapfrog). (TODO: #610)</p><pre><code class="language-julia hljs">function solve_coupler!(cs)
    (; model_sims, Δt_cpl, tspan, comms_ctx) = cs
    (; atmos_sim, land_sim, ocean_sim, ice_sim) = model_sims

    ClimaComms.iamroot(comms_ctx) &amp;&amp; @info(&quot;Starting coupling loop&quot;)
    # step in time
    for t in ((tspan[begin] + Δt_cpl):Δt_cpl:tspan[end])

        cs.dates.date[1] = TimeManager.current_date(cs, t)

        # print date on the first of month
        if cs.dates.date[1] &gt;= cs.dates.date1[1]
            ClimaComms.iamroot(comms_ctx) &amp;&amp; @show(cs.dates.date[1])
        end

        if cs.mode.name == &quot;amip&quot;

            # monthly read of boundary condition data for SST and SIC and CO2
            if cs.dates.date[1] &gt;= BCReader.next_date_in_file(cs.mode.SST_info)
                BCReader.update_midmonth_data!(cs.dates.date[1], cs.mode.SST_info)
            end
            SST_current = BCReader.interpolate_midmonth_to_daily(cs.dates.date[1], cs.mode.SST_info)
            Interfacer.update_field!(ocean_sim, Val(:surface_temperature), SST_current)

            if cs.dates.date[1] &gt;= BCReader.next_date_in_file(cs.mode.SIC_info)
                BCReader.update_midmonth_data!(cs.dates.date[1], cs.mode.SIC_info)
            end
            SIC_current =
                get_ice_fraction.(
                    BCReader.interpolate_midmonth_to_daily(cs.dates.date[1], cs.mode.SIC_info),
                    cs.mode.SIC_info.mono,
                )
            Interfacer.update_field!(ice_sim, Val(:area_fraction), SIC_current)

            if cs.dates.date[1] &gt;= BCReader.next_date_in_file(cs.mode.CO2_info)
                BCReader.update_midmonth_data!(cs.dates.date[1], cs.mode.CO2_info)
            end
            CO2_current = BCReader.interpolate_midmonth_to_daily(cs.dates.date[1], cs.mode.CO2_info)
            Interfacer.update_field!(atmos_sim, Val(:co2), CO2_current)

            # calculate and accumulate diagnostics at each timestep, if we&#39;re using diagnostics in this run
            if !isempty(cs.diagnostics)
                ClimaComms.barrier(comms_ctx)
                Diagnostics.accumulate_diagnostics!(cs)

                # save and reset monthly averages
                Diagnostics.save_diagnostics(cs)
            end
        end

        # compute global energy
        !isnothing(cs.conservation_checks) &amp;&amp; ConservationChecker.check_conservation!(cs)
        ClimaComms.barrier(comms_ctx)

        # update water albedo from wind at dt_water_albedo (this will be extended to a radiation callback from the coupler)
        TimeManager.trigger_callback!(cs, cs.callbacks.water_albedo)

        # run component models sequentially for one coupling timestep (Δt_cpl)
        Regridder.update_surface_fractions!(cs)
        FieldExchanger.update_model_sims!(cs.model_sims, cs.fields, cs.turbulent_fluxes)

        # step sims
        FieldExchanger.step_model_sims!(cs.model_sims, t)

        # exchange combined fields and (if specified) calculate fluxes using combined states
        FieldExchanger.import_combined_surface_fields!(cs.fields, cs.model_sims, cs.turbulent_fluxes) # i.e. T_sfc, surface_albedo, z0, beta
        if cs.turbulent_fluxes isa FluxCalculator.CombinedStateFluxesMOST
            FluxCalculator.combined_turbulent_fluxes!(cs.model_sims, cs.fields, cs.turbulent_fluxes) # this updates the surface thermo state, sfc_ts, in ClimaAtmos (but also unnecessarily calculates fluxes)
        elseif cs.turbulent_fluxes isa FluxCalculator.PartitionedStateFluxes
            # calculate turbulent fluxes in surfaces and save the weighted average in coupler fields
            FluxCalculator.partitioned_turbulent_fluxes!(
                cs.model_sims,
                cs.fields,
                cs.boundary_space,
                FluxCalculator.MoninObukhovScheme(),
                cs.thermo_params,
            )

            # update atmos sfc_conditions for surface temperature - TODO: this needs to be simplified (need CA modification)
            new_p = get_new_cache(atmos_sim, cs.fields)
            CA.SurfaceConditions.update_surface_conditions!(atmos_sim.integrator.u, new_p, atmos_sim.integrator.t) # to set T_sfc (but SF calculation not necessary - CA modification)
            atmos_sim.integrator.p.precomputed.sfc_conditions .= new_p.precomputed.sfc_conditions
        end

        FieldExchanger.import_atmos_fields!(cs.fields, cs.model_sims, cs.boundary_space, cs.turbulent_fluxes) # radiative and/or turbulent

        # callback to update the fist day of month if needed (for BCReader)
        TimeManager.trigger_callback!(cs, cs.callbacks.update_firstdayofmonth!)

        # callback to checkpoint model state
        TimeManager.trigger_callback!(cs, cs.callbacks.checkpoint)

    end

    return nothing
end


# run the coupled simulation for one timestep to precompile everything before timing
cs.tspan[2] = Δt_cpl * 2
solve_coupler!(cs)

# run the coupled simulation for the full timespan and time it
cs.tspan[1] = Δt_cpl * 2
cs.tspan[2] = tspan[2]

# Run garbage collection before solving for more accurate memory comparison to ClimaAtmos
GC.gc()

# Use ClimaComms.@elapsed to time the simulation on both CPU and GPU
walltime = ClimaComms.@elapsed comms_ctx.device begin
    s = CA.@timed_str begin
        solve_coupler!(cs)
    end
end
ClimaComms.iamroot(comms_ctx) &amp;&amp; @show(walltime)

# Use ClimaAtmos calculation to show the simulated years per day of the simulation (SYPD)
es = CA.EfficiencyStats(tspan, walltime)
sypd = CA.simulated_years_per_day(es)
@info &quot;SYPD: $sypd&quot;

# Save the SYPD and allocation information
if ClimaComms.iamroot(comms_ctx)
    sypd_filename = joinpath(dir_paths.artifacts, &quot;sypd.txt&quot;)
    write(sypd_filename, &quot;$sypd&quot;)

    cpu_max_rss_GB = Utilities.show_memory_usage(comms_ctx)
    cpu_max_rss_filename = joinpath(dir_paths.artifacts, &quot;max_rss_cpu.txt&quot;)
    write(cpu_max_rss_filename, cpu_max_rss_GB)
end</code></pre><h2 id="Postprocessing"><a class="docs-heading-anchor" href="#Postprocessing">Postprocessing</a><a id="Postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocessing" title="Permalink"></a></h2><p>Currently all postprocessing is performed using the root process only.</p><pre><code class="language-julia hljs">if ClimaComms.iamroot(comms_ctx)

    # energy check plots
    if !isnothing(cs.conservation_checks) &amp;&amp; cs.mode.name[1:10] == &quot;slabplanet&quot;
        @info &quot;Conservation Check Plots&quot;
        ConservationChecker.plot_global_conservation(
            cs.conservation_checks.energy,
            cs,
            config_dict[&quot;conservation_softfail&quot;],
            figname1 = joinpath(dir_paths.artifacts, &quot;total_energy_bucket.png&quot;),
            figname2 = joinpath(dir_paths.artifacts, &quot;total_energy_log_bucket.png&quot;),
        )
        ConservationChecker.plot_global_conservation(
            cs.conservation_checks.water,
            cs,
            config_dict[&quot;conservation_softfail&quot;],
            figname1 = joinpath(dir_paths.artifacts, &quot;total_water_bucket.png&quot;),
            figname2 = joinpath(dir_paths.artifacts, &quot;total_water_log_bucket.png&quot;),
        )
    end

    # sample animations (not compatible with MPI)
    if !CA.is_distributed(comms_ctx) &amp;&amp; config_dict[&quot;anim&quot;]
        @info &quot;Animations&quot;
        include(&quot;user_io/viz_explorer.jl&quot;)
        plot_anim(cs, dir_paths.artifacts)
    end

    # plotting AMIP results
    if cs.mode.name == &quot;amip&quot; &amp;&amp; !isempty(cs.diagnostics)
        # plot data that correspond to the model&#39;s last save_hdf5 call (i.e., last month)
        @info &quot;AMIP plots&quot;

        # ClimaESM
        include(&quot;user_io/amip_visualizer.jl&quot;)
        post_spec = (;
            T = (:regrid, :zonal_mean),
            u = (:regrid, :zonal_mean),
            q_tot = (:regrid, :zonal_mean),
            toa_fluxes = (:regrid, :horizontal_slice),
            precipitation_rate = (:regrid, :horizontal_slice),
            T_sfc = (:regrid, :horizontal_slice),
            tubulent_energy_fluxes = (:regrid, :horizontal_slice),
            q_liq_ice = (:regrid, :zonal_mean),
        )

        plot_spec = (;
            T = (; clims = (190, 320), units = &quot;K&quot;),
            u = (; clims = (-50, 50), units = &quot;m/s&quot;),
            q_tot = (; clims = (0, 30), units = &quot;g/kg&quot;),
            toa_fluxes = (; clims = (-250, 250), units = &quot;W/m^2&quot;),
            precipitation_rate = (clims = (0, 1e-4), units = &quot;kg/m^2/s&quot;),
            T_sfc = (clims = (225, 310), units = &quot;K&quot;),
            tubulent_energy_fluxes = (; clims = (-250, 250), units = &quot;W/m^2&quot;),
            q_liq_ice = (; clims = (0, 10), units = &quot;g/kg&quot;),
        )
        amip_data, fig_amip = amip_paperplots(
            post_spec,
            plot_spec,
            dir_paths.output,
            files_root = &quot;.monthly&quot;,
            output_dir = dir_paths.artifacts,
        )

        # NCEP reanalysis
        @info &quot;NCEP plots&quot;
        include(&quot;user_io/ncep_visualizer.jl&quot;)
        ncep_post_spec = (;
            T = (:zonal_mean,),
            u = (:zonal_mean,),
            q_tot = (:zonal_mean,),
            toa_fluxes = (:horizontal_slice,),
            precipitation_rate = (:horizontal_slice,),
            T_sfc = (:horizontal_slice,),
            tubulent_energy_fluxes = (:horizontal_slice,),
        )
        ncep_plot_spec = plot_spec
        ncep_data, fig_ncep = ncep_paperplots(
            ncep_post_spec,
            ncep_plot_spec,
            dir_paths.output,
            output_dir = dir_paths.artifacts,
            month_date = cs.dates.date[1],
        )

        # combine AMIP and NCEP plots
        plot_combined = Plots.plot(fig_amip, fig_ncep, layout = (2, 1), size = (1400, 1800))
        Plots.png(joinpath(dir_paths.artifacts, &quot;amip_ncep.png&quot;))

        # Compare against observations
        if t_end &gt; 84600 &amp;&amp; config_dict[&quot;output_default_diagnostics&quot;]
            @info &quot;Error against observations&quot;
            diagnostics_times = copy(atmos_sim.integrator.sol.t)</code></pre><p>Remove the first <code>spinup_months</code> months from the leaderboard</p><pre><code class="language-julia hljs">            spinup_months = 6
            spinup_cutoff = spinup_months * 30 * 86400.0
            if t_end &gt; spinup_cutoff
                filter!(x -&gt; x &lt; spinup_cutoff, diagnostics_times)
            end

            output_dates = cs.dates.date0[] .+ Dates.Second.(diagnostics_times)
            @info &quot;Working with dates:&quot;
            @info output_dates

            include(&quot;user_io/leaderboard.jl&quot;)
            compare_vars = [&quot;pr&quot;, &quot;rsut&quot;, &quot;rlut&quot;]
            function compute_biases(dates)
                if isempty(dates)
                    return map(x -&gt; 0.0, compare_vars)
                else
                    return Leaderboard.compute_biases(atmos_sim.integrator.p.output_dir, compare_vars, dates)
                end
            end

            function plot_biases(dates, biases, output_name)
                isempty(dates) &amp;&amp; return nothing

                output_path = joinpath(dir_paths.artifacts, &quot;bias_$(output_name).png&quot;)
                Leaderboard.plot_biases(biases; output_path)
            end

            ann_biases = compute_biases(output_dates)
            plot_biases(output_dates, ann_biases, &quot;total&quot;)

            # collect all days between cs.dates.date0 and cs.dates.date
            MAM, JJA, SON, DJF = Leaderboard.split_by_season(output_dates)

            MAM_biases = compute_biases(MAM)
            plot_biases(MAM, MAM_biases, &quot;MAM&quot;)
            JJA_biases = compute_biases(JJA)
            plot_biases(JJA, JJA_biases, &quot;JJA&quot;)
            SON_biases = compute_biases(SON)
            plot_biases(SON, SON_biases, &quot;SON&quot;)
            DJF_biases = compute_biases(DJF)
            plot_biases(DJF, DJF_biases, &quot;DJF&quot;)

            rmses = map(
                (index) -&gt; Leaderboard.RMSEs(;
                    model_name = &quot;CliMA&quot;,
                    ANN = ann_biases[index],
                    DJF = DJF_biases[index],
                    MAM = MAM_biases[index],
                    JJA = JJA_biases[index],
                    SON = SON_biases[index],
                ),
                1:length(compare_vars),
            )

            Leaderboard.plot_leaderboard(rmses; output_path = joinpath(dir_paths.artifacts, &quot;bias_leaderboard.png&quot;))
        end
    end

    # ci plots
    if config_dict[&quot;ci_plots&quot;]
        @info &quot;Generating CI plots&quot;
        include(&quot;user_io/ci_plots.jl&quot;)
        make_plots(Val(:general_ci_plots), [atmos_sim.integrator.p.output_dir], dir_paths.artifacts)
    end

    # plot all model states and coupler fields (useful for debugging)
    !(comms_ctx isa ClimaComms.MPICommsContext) &amp;&amp; debug(cs, dir_paths.artifacts)

    if isinteractive()
        # clean up for interactive runs, retain all output otherwise
        rm(dir_paths.output; recursive = true, force = true)
    end

end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../sea_breeze/run/">« Coupled Sea Breeze</a><a class="docs-footer-nextpage" href="../../../bcreader/">BCReader »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 20 June 2024 23:56">Thursday 20 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
