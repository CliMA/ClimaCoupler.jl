var documenterSearchIndex = {"docs":
[{"location":"generated/run/#Heat-Equation-Slab-Tutorial","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"In this tutorial, we demonstrate simple sequential coupling of two PDE models using the ClimaCore.jl backends.","category":"page"},{"location":"generated/run/#Model-1","page":"Heat Equation + Slab Tutorial","title":"Model 1","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Model 1 represents a simplified atmosphere (atm) and solves the heat equation in a one-column domain:","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"frac T t +   (-μ T) = 0","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"with top and bottom boundary conditions set to fixed-temperature (non-zero Dirichlet) and fixed-flux (non-zero Neumann) conditions, respectively:","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"T_top  = 280 K  frac T_bottom t = -  F_sfc","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"where","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"t is time\nμ is the thermal diffusivity\nT is the temperature\nF_sfc is the thermal boundary flux (see below for calculation)","category":"page"},{"location":"generated/run/#Model-2","page":"Heat Equation + Slab Tutorial","title":"Model 2","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Model 2 assumes a simplified soil (lnd) domain to be a slab, represented by an ODE for its surface temperature:","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"fracdT_sfcdt = - (F_accumulated + G )  h_lnd","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"where","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"F_accumulated = F_integrated  Δt_coupler","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"where","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Δt_coupler is the duration of the coupling cycle\nT_sfc is the temperature\nh_lnd is the slab thickness\nF_integrated and F_accumulated thermal boundary fluxes, respectively (see below for calculation)\nG represents soil physics, which we assume to be 0 for now","category":"page"},{"location":"generated/run/#Coupling-and-Flux-Calculation","page":"Heat Equation + Slab Tutorial","title":"Coupling and Flux Calculation","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"We use this Model 1 (usually this is done by the model with the shortest timestep) to calculate and accumulate the downward surface fluxes, F_sfc:","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"F_sfc = - λ (T_sfc - T1)","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"d(F_integrated)dt  = F_sfc","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"where","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"T1 is the atm temperature near the surface (here assumed equal to the first model level)\nλ a constant relaxation timescale","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Note that in a more realistic setup the above equations would be weighted by their domains' densities and thermal heat capacities, so that the thermal flux would have the units of W m^-2. Here we assume these are unity for both domains.","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Sequential coupling has the following steps:","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"pre-Model 1: supply Model 1 with T_sfc for the F_sfc calculation; reset F_integrated to zero\nrun Model 1: step forward for all Model 1 timesteps within one coupling cycle using F_sfc as the bottom boundary condition; accumulate F_integrated at each (sub-)step\npost-Model 1: pass F_integrated into coupler and convert to F_accumulated for the correct units.\npre-Model 2: supply Model 2 with F_accumulated\nrun Model 2: step forward for all Model 2 timesteps within one coupling cycle;\npost-Model 2: state variable, T_sfc of Model 2 into coupler.\nrepeat steps 1-6 for all coupling timesteps.","category":"page"},{"location":"generated/run/#Implementation","page":"Heat Equation + Slab Tutorial","title":"Implementation","text":"","category":"section"},{"location":"generated/run/#Loading-code-coupler","page":"Heat Equation + Slab Tutorial","title":"Loading Packages","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"First, we'll load our pre-requisites:","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"load CliMA packages under development - you may need to add unregistered packages in Pkg, e.g.:","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"# import Pkg; Pkg.add(url=\"https://github.com/CliMA/ClimaCore.jl\",rev=\"main\")","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"load external packages:","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"import LinearAlgebra, UnPack\nimport ClimaCore: Fields, Domains, Topologies, Meshes, DataLayouts, Operators, Geometry, Spaces\n\nusing Base: show_supertypes\nusing OrdinaryDiffEq: ODEProblem, solve, SSPRK33\n\nusing Logging: global_logger\nusing TerminalLoggers: TerminalLogger\n\nusing RecursiveArrayTools\n\nusing OrdinaryDiffEq\n\nusing Statistics","category":"page"},{"location":"generated/run/#Define-Parameters","page":"Heat Equation + Slab Tutorial","title":"Define Parameters","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Global Constants","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"const FT = Float64;","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Experiment-specific Parameters","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"parameters = (\n    # atmos parameters\n    zmin_atm = FT(0.0), # height of atm stack bottom [m]\n    zmax_atm = FT(1.0), # height of atm stack top [m]\n    n = 15,  # number of elements in atm stack\n    μ = FT(0.0001), # diffusion coefficient [m^2 / s]\n    T_top = FT(280.0), # fixed temperature at the top of the domain_atm [K]\n    T_atm_ini = FT(280.0), # initial condition of at temperature (isothermal) [K]\n    # slab parameters\n    h_lnd = FT(0.5), # depth of slab layer [m]\n    T_lnd_ini = FT(260.0), # initial condition of at temperature (isothermal) [K]\n    # coupling parameters\n    λ = FT(1e-5), # transfer coefficient\n)","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"(zmin_atm = 0.0, zmax_atm = 1.0, n = 15, μ = 0.0001, T_top = 280.0, T_atm_ini = 280.0, h_lnd = 0.5, T_lnd_ini = 260.0, λ = 1.0e-5)","category":"page"},{"location":"generated/run/#Define-Model-Functions","page":"Heat Equation + Slab Tutorial","title":"Define Model Functions","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Model 1 (atm) Equations","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"\"\"\"\n    ∑tendencies_atm!(du, u, (parameters, T_sfc), t)\n\nHeat diffusion equation\n    dT/dt =  ∇ μ ∇ T\n    where\n        T  = 280 K              at z = zmax_atm\n        dT/dt = - ∇ F_sfc       at z = zmin_atm\n\nWe also use this model to calculate and accumulate the downward surface fluxes, F_sfc:\n    F_sfc = - λ * (T_sfc - T1)\n    d(F_integrated)/dt  = F_sfc\n    where\n        F_integrated is reset to 0 at the beginning of each coupling cycle\n        T1 = atm temperature near the surface (here assumed equal to the first model level)\n\"\"\"\nfunction ∑tendencies_atm!(du, u, (parameters, T_sfc), t)\n    T = u.x[1] # u.x = vector of prognostic variables from DifferentialEquations\n    F_sfc = calculate_flux(T_sfc[1], parent(T)[1], parameters)\n    # set BCs\n    bcs_bottom = Operators.SetValue(Geometry.Cartesian3Vector(F_sfc)) # F_sfc is converted to a Cartesian vector in direction 3 (vertical)\n    bcs_top = Operators.SetValue(FT(parameters.T_top))\n\n    gradc2f = Operators.GradientC2F(top = bcs_top) # Dirichlet BC (center-to-face)\n    gradf2c = Operators.DivergenceF2C(bottom = bcs_bottom) # Neumann BC (face-to-center)\n\n    # tendency calculations\n    @. du.x[1] = gradf2c(parameters.μ * gradc2f(T)) # dT/dt\n    du.x[2] .= -F_sfc[1] # d(F_integrated)/dt\nend","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Main.##438.∑tendencies_atm!","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Model 2 (lnd) Equations","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"\"\"\"\n    ∑tendencies_lnd!(dT_sfc, T_sfc, (parameters, F_accumulated), t)\n\nSlab layer equation\n    lnd d(T_sfc)/dt = - (F_accumulated + G) / h_lnd\n    where\n        F_accumulated = F_integrated / Δt_coupler\n\"\"\"\nfunction ∑tendencies_lnd!(dT_sfc, T_sfc, (parameters, F_accumulated), t)\n    G = 0.0 # place holder for soil dynamics\n    @. dT_sfc = (-F_accumulated + G) / parameters.h_lnd\nend","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Main.##438.∑tendencies_lnd!","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Surface Flux Calculation (coarse bulk formula)","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"calculate_flux(T_sfc, T1, parameters) = -parameters.λ * (T_sfc - T1);","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Coupler Communication Functions","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"These functions export / import / transform variables These functions are now just place holders for coupler transformations (e.g. regridding, masking, etc)","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"coupler_get_(x) = x;\ncoupler_put_(x) = x;","category":"page"},{"location":"generated/run/#Model-Initialization","page":"Heat Equation + Slab Tutorial","title":"Model Initialization","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"initialize atm model domain and grid","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"domain_atm = Domains.IntervalDomain(\n    Geometry.ZPoint{FT}(parameters.zmin_atm),\n    Geometry.ZPoint{FT}(parameters.zmax_atm);\n    boundary_tags = (:bottom, :top),\n);\nmesh_atm = Meshes.IntervalMesh(domain_atm, nelems = parameters.n); # struct, allocates face boundaries to 5,6: atmos\ncenter_space_atm = Spaces.CenterFiniteDifferenceSpace(mesh_atm); # collection of the above, discretises space into FD and provides coords","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"initialize prognostic variables, either as ClimaCore's Field objects or as Arrays","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"T_atm_0 = Fields.ones(FT, center_space_atm) .* parameters.T_atm_ini; # initiates a spatially uniform atm progostic var\nT_lnd_0 = [parameters.T_lnd_ini]; # initiates lnd progostic var\nics = (; atm = T_atm_0, lnd = T_lnd_0)","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"(atm = Float64-valued Field:\n  [280.0, 280.0, 280.0, 280.0, 280.0, 280.0, 280.0, 280.0, 280.0, 280.0, 280.0, 280.0, 280.0, 280.0, 280.0], lnd = [260.0])","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"specify timestepping information","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"stepping = (;\n    Δt_min = 0.02,\n    timerange = (0.0, 6.0),\n    Δt_coupler = 1.0,\n    odesolver = SSPRK33(),\n    nsteps_atm = 8, # number of timesteps of atm per coupling cycle\n    nsteps_lnd = 1, # number of timesteps of lnd per coupling cycle\n);","category":"page"},{"location":"generated/run/#Define-the-sequential-coupling-loop","page":"Heat Equation + Slab Tutorial","title":"Define the sequential coupling loop","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"function coupler_solve!(stepping, ics, parameters)\n    t = 0.0\n    Δt_min = stepping.Δt_min\n    Δt_coupler = stepping.Δt_coupler\n    t_start = stepping.timerange[1]\n    t_end = stepping.timerange[2]\n\n    # init coupler fields\n    coupler_F_sfc = [0.0]\n    coupler_T_lnd = copy(ics.lnd)\n\n    # atmos copies of coupler variables\n    atm_T_lnd = copy(coupler_T_lnd)\n    atm_F_sfc = copy(coupler_F_sfc)\n\n    ## SETUP ATMOS\n    # put all prognostic variable arrays into a vector and ensure that solve can partition them\n    T_atm = ics.atm\n    Y_atm = ArrayPartition((T_atm, atm_F_sfc))\n    prob_atm = ODEProblem(∑tendencies_atm!, Y_atm, (t_start, t_end), (parameters, atm_T_lnd))\n    integ_atm = init(prob_atm, stepping.odesolver, dt = Δt_min, saveat = 10 * Δt_min)\n\n    # land copies of coupler variables\n    T_lnd = ics.lnd\n    lnd_F_sfc = copy(coupler_F_sfc)\n\n    ## SETUP LAND\n    prob_lnd = ODEProblem(∑tendencies_lnd!, T_lnd, (t_start, t_end), (parameters, lnd_F_sfc))\n    integ_lnd = init(prob_lnd, stepping.odesolver, dt = Δt_min, saveat = 10 * Δt_min)\n\n    # coupler stepping\n    for t in (t_start:Δt_coupler:t_end)\n\n        # STEP ATMOS\n        # pre_atmos\n        integ_atm.p[2] .= coupler_get_(coupler_T_lnd) # integ_atm.p is the parameter vector of an ODEProblem from DifferentialEquations\n        integ_atm.u.x[2] .= [0.0] # surface flux to be accumulated\n\n        # run atmos\n        # NOTE: use (t - integ_atm.t) here instead of Δt_coupler to avoid accumulating roundoff error in our timestepping.\n        OrdinaryDiffEq.step!(integ_atm, t - integ_atm.t, true)\n\n        # post_atmos\n        coupler_F_sfc .= coupler_put_(integ_atm.u.x[2]) / Δt_coupler\n\n        # STEP LAND\n        # pre_land\n        lnd_F_sfc .= coupler_get_(coupler_F_sfc)\n\n        # run land\n        OrdinaryDiffEq.step!(integ_lnd, t - integ_lnd.t, true)\n\n        # post land\n        coupler_T_lnd .= coupler_put_(integ_lnd.u) # update T_sfc\n    end\n\n    return integ_atm, integ_lnd\nend;","category":"page"},{"location":"generated/run/#Run-the-Coupler-Model-Simulation","page":"Heat Equation + Slab Tutorial","title":"Run the Coupler Model Simulation","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"integ_atm, integ_lnd = coupler_solve!(stepping, ics, parameters);\nsol_atm, sol_lnd = integ_atm.sol, integ_lnd.sol;","category":"page"},{"location":"generated/run/#Postprocessing-and-Visualization","page":"Heat Equation + Slab Tutorial","title":"Postprocessing and Visualization","text":"","category":"section"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Each integrator output (sol_atm, sol_lnd), contains the DifferentialEquations variable .u (the name is hard coded). If ArrayPartition was used for combining multiple prognostic variables, u will include an additional variable x (also hard coded) parent() accesses the Field values. So, for example, the structure of u from Model 1 is:","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"parent(sol_atm.u[<time-index>].x[<ArrayPartition-index>])[<z-index>,<variable-index>]","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"ENV[\"GKSwstype\"] = \"nul\"\nimport Plots\nPlots.GRBackend()\n\nshow_plots = isdefined(Main, :SHOWPLOTS) ? SHOWPLOTS : true\n\npath = joinpath(dirname(@__FILE__), \"images/\")\nmkpath(path);","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Vertical profile at start and end","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"t0_ = parent(sol_atm.u[1].x[1])[:, 1];\ntend_ = parent(sol_atm.u[end].x[1])[:, 1];\nz_centers = parent(Fields.coordinate_field(center_space_atm))[:, 1];\nshow_plots ?\nPlots.png(\n    Plots.plot(\n        [t0_ tend_],\n        z_centers,\n        title = \"model 1: atm\",\n        labels = [\"t=0\" \"t=end\"],\n        xlabel = \"T (K)\",\n        ylabel = \"z (m)\",\n    ),\n    joinpath(path, \"tc1_f1.png\"),\n) : nothing","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"(Image: )","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Conservation: absolute \"energy\" of both models with time","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"convert to the same units (analogous to energy conservation, assuming that is both domains density=1 and thermal capacity=1)","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"lnd_sfc_u_t = [u[1] for u in sol_lnd.u] .* parameters.h_lnd;\natm_sum_u_t = [sum(parent(u.x[1])[:]) for u in sol_atm.u] .* (parameters.zmax_atm - parameters.zmin_atm) ./ parameters.n;\nv1 = lnd_sfc_u_t .- lnd_sfc_u_t[1];\nv2 = atm_sum_u_t .- atm_sum_u_t[1];\nshow_plots ?\nPlots.png(\n    Plots.plot(\n        sol_lnd.t,\n        [v1 v2 v1 + v2],\n        labels = [\"lnd\" \"atm\" \"tot\"],\n        xlabel = \"time (s)\",\n        ylabel = \"pseudo-energy (J / m2)\",\n    ),\n    joinpath(path, \"tc1_f2.png\"),\n) : nothing","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"(Image: )","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"Conservation: relative error with time","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"total = atm_sum_u_t + lnd_sfc_u_t;\nrel_error = (total .- total[1]) / mean(total);\nshow_plots ?\nPlots.png(\n    Plots.plot(sol_lnd.t, rel_error, labels = [\"tot\"], xlabel = \"time (s)\", ylabel = \"relative error\"),\n    joinpath(path, \"tc1_f3.png\"),\n) : nothing","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"(Image: )","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"","category":"page"},{"location":"generated/run/","page":"Heat Equation + Slab Tutorial","title":"Heat Equation + Slab Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"couplerstate/#Coupler-State","page":"Coupler State","title":"Coupler State","text":"","category":"section"},{"location":"couplerstate/","page":"Coupler State","title":"Coupler State","text":"The coupler provides a space to store information being passed between coupled model components at their boundaries. During this exchange, the coupler manages ancillary operations such as regridding, unit conversions, filtering, etc.","category":"page"},{"location":"couplerstate/","page":"Coupler State","title":"Coupler State","text":"The ClimaCoupler defines a type CouplerState for a container variable that holds information about the field boundary values that are being used to couple components. Components can use a coupler_put! operation to  export a set of field values to a CouplerState variable. A coupler_get operation is used to retrieve a set of field values from a CplState variable. During this exchange, the coupler manages ancillary operations such as  regridding, unit conversions, or filtering.","category":"page"},{"location":"couplerstate/#Coupler-Object-API","page":"Coupler State","title":"Coupler Object API","text":"","category":"section"},{"location":"couplerstate/","page":"Coupler State","title":"Coupler State","text":"    ClimaCoupler.CouplerState\n    ClimaCoupler.coupler_add_field!\n    ClimaCoupler.coupler_put!\n    ClimaCoupler.coupler_get","category":"page"},{"location":"couplerstate/#ClimaCoupler.CouplerState","page":"Coupler State","title":"ClimaCoupler.CouplerState","text":"CouplerState()\n\nType for holding coupler \"state\". This is the namespace through which coupled components communicate. Its role is to provide a level of indirection so that components remain modular and so that any data communication, interpolation, reindexing/unit conversions and filtering  etc... can be embeded in the intermdediate coupling layer.\n\nA field is exported by one component and imported by one or more other components.\n\n\n\n\n\n","category":"type"},{"location":"couplerstate/#ClimaCoupler.coupler_add_field!","page":"Coupler State","title":"ClimaCoupler.coupler_add_field!","text":"coupler_add_field!(\n        coupler::CouplerState,\n        fieldname::Symbol,\n        fieldvalue,\n        grid,\n        datetime::DateTime,\n        units::Unitful.Units = Unitful.NoUnits, \n    )\n\nAdd a field to the coupler that is accessible with key fieldname. \n\nArguments\n\ncoupler: coupler object the field is added to.\nfieldname: key to access the field in the coupler.\nfieldvalue: data array of field values.\ngrid: grid the field is stored on.\ndatetime: time associated with the field state.\nunits: units associated with the field values. Dimensionless by default.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#ClimaCoupler.coupler_put!","page":"Coupler State","title":"ClimaCoupler.coupler_put!","text":"coupler_put!(coupler::CouplerState, fieldname::Symbol, fieldvalue, gridinfo, datetime::DateTime, units::Unitful.Units)\n\nUpdates coupler field fieldname with fieldvalue, the field's value at time datetime.\n\ngridinfo and units inform the coupler of the format of the inputted data allowing conversion to match the grid and units of the coupler field.\n\n\n\n\n\n","category":"function"},{"location":"couplerstate/#ClimaCoupler.coupler_get","page":"Coupler State","title":"ClimaCoupler.coupler_get","text":"coupler_get(coupler::CouplerState, fieldname::Symbol, gridinfo, datetime::DateTime, units::Unitful.Units)\n\nRetrieve data array corresponding to fieldname.\n\nReturns data on the grid specified by gridinfo and in the units of units. Checks that the coupler data field is the state at time datetime.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaCoupler.jl","page":"Home","title":"ClimaCoupler.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Coupling CliMA Models","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ClimaCoupler","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaCoupler.jl provides a means to couple CliMA  model components. It is designed to provide a flexible way to map boundary fluxes of quantities, like moisture and heat, that leave one component model (for example the atmosphere) to boundary fluxes of another component model (for example the ocean model). Functionality includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"coupled system time stepping control that integrates fluxes in time for sharing between components with differing time steps and/or time stepping schemes.\nsupport for mapping import and export boundary information between components so that fluxes of properties transferred between components are conserved.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ClimaCoupler supports coupling components that are all within the same process or coupling components (using MPI) that are running on different processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Coupler Scheme)\nClimaCoupler.jl allows for independent development of interchangeable component models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"    ClimaCoupler","category":"page"},{"location":"#ClimaCoupler.ClimaCoupler","page":"Home","title":"ClimaCoupler.ClimaCoupler","text":"ClimaCoupler\n\nCoupling module sufficient for initial atmos-ocean-land coupled simulation.\n\n\n\n\n\n","category":"module"},{"location":"timestepping/#Coupled-Simulations-and-Timestepping","page":"Coupled Simulations & Timestepping","title":"Coupled Simulations & Timestepping","text":"","category":"section"},{"location":"timestepping/","page":"Coupled Simulations & Timestepping","title":"Coupled Simulations & Timestepping","text":"ClimaCoupler.jl organizes coupled models and their execution via the CoupledSimulation interface. An implementation of a CoupledSimulation, like any CliMA simulation, must  implement a ClimaCoupler.step! method, which in this context specifies the coupling scheme details (e.g. explicit, leap-frog, concurrent, etc...).","category":"page"},{"location":"timestepping/","page":"Coupled Simulations & Timestepping","title":"Coupled Simulations & Timestepping","text":"Component models being coupled must provide three methods for use in a  CoupledSimulation's ClimaCoupler.step! method:","category":"page"},{"location":"timestepping/","page":"Coupled Simulations & Timestepping","title":"Coupled Simulations & Timestepping","text":"step!: advances the component model in time\ncoupler_push!: prepares and puts coupled fields from the model   into the coupler via coupler_put! calls\ncoupler_pull!: gets coupled fields from the coupler   via coupler_get! calls and prepares them to be ingested by the model.","category":"page"},{"location":"timestepping/","page":"Coupled Simulations & Timestepping","title":"Coupled Simulations & Timestepping","text":"ClimaCoupler.CoupledSimulation\nClimaCoupler.run!\nClimaCoupler.step!\nClimaCoupler.coupler_push!\nClimaCoupler.coupler_pull!","category":"page"},{"location":"timestepping/#ClimaCoupler.CoupledSimulation","page":"Coupled Simulations & Timestepping","title":"ClimaCoupler.CoupledSimulation","text":"CoupledSimulation\n\nAn abstract type representing a coupled simulation.\n\n\n\n\n\n","category":"type"},{"location":"timestepping/#ClimaCoupler.run!","page":"Coupled Simulations & Timestepping","title":"ClimaCoupler.run!","text":"run!(::CoupledSimulation)\n\nA simple outer timestepping loop for coupled system runs.\n\nThis will be formalized when the run! functionality for component models is implemented so to have a consistent interface.\n\n\n\n\n\n","category":"function"},{"location":"timestepping/#ClimaCoupler.step!","page":"Coupled Simulations & Timestepping","title":"ClimaCoupler.step!","text":"step!(sim, dt)\n\nAdvances a simulation by dt.\n\nNote that dt is not necessarily the simulation's timestep length; a simuation could take several shorter steps that total to dt.\n\n\n\n\n\n","category":"function"},{"location":"timestepping/#ClimaCoupler.coupler_push!","page":"Coupled Simulations & Timestepping","title":"ClimaCoupler.coupler_push!","text":"coupler_push!(coupler::CouplerState, model)\n\nUpdate coupler with fields retrieved from the coupler.\n\ncoupler_push! is an adapter function to be implemented for each model component using the coupler. It should send coupling fields via coupler_put! calls and perform any operations on these fields to prepare them for the coupler.\n\n\n\n\n\n","category":"function"},{"location":"timestepping/#ClimaCoupler.coupler_pull!","page":"Coupled Simulations & Timestepping","title":"ClimaCoupler.coupler_pull!","text":"coupler_pull!(model, coupler::CouplerState)\n\nUpdate model with fields retrieved from the coupler.\n\ncoupler_pull! is an adapter function to be implemented for each model component using the coupler. It should get coupling fields via coupler_get calls and perform any operations on these fields to prepare them for use in the component model.\n\n\n\n\n\n","category":"function"}]
}
