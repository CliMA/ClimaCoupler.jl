<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Conditions (BCs) · CouplerMachine</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="CouplerMachine logo"/></a><div class="docs-package-name"><span class="docs-autofit">CouplerMachine</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/simple_2testcomp/">Vertical Column Heat Diffusion</a></li><li><a class="tocitem" href="../generated/run_script_v2/">Advection-diffusion on a Sphere</a></li></ul></li><li><span class="tocitem">Coupler Interface</span><ul><li><a class="tocitem" href="../couplerstate/">Coupler State</a></li><li><a class="tocitem" href="../timestepping/">Coupled Timestepping</a></li><li><a class="tocitem" href="../coupledmodel/">Coupled Model Components</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Boundary Conditions (BCs)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary Conditions (BCs)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/CouplerMachine/blob/master/docs/src/boundary_conditions_doc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Boundary-Conditions-(BCs)"><a class="docs-heading-anchor" href="#Boundary-Conditions-(BCs)">Boundary Conditions (BCs)</a><a id="Boundary-Conditions-(BCs)-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions-(BCs)" title="Permalink"></a></h1><p>This section attempts to bridge mathematical considerations of BCs and their implementations in climate models.</p><h2 id="Types-of-boundary-conditions"><a class="docs-heading-anchor" href="#Types-of-boundary-conditions">Types of boundary conditions</a><a id="Types-of-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-boundary-conditions" title="Permalink"></a></h2><ol><li>Dirichlet  <span>$θ = f$</span></li><li>Neumann  <span>$\partial θ / \partial n = f$</span></li><li>Robin  <span>$c_1θ +  c_2\partial θ / \partial n = f$</span></li><li>Cauchy  <span>$θ = f_1$</span>  <span>$\partial θ / \partial n = f_2$</span></li><li>Mixed<ul><li>a mix of the above, each applied at a different section of the boundary</li></ul></li></ol><h2 id="Well-posedness-and-general-context"><a class="docs-heading-anchor" href="#Well-posedness-and-general-context">Well-posedness and general context</a><a id="Well-posedness-and-general-context-1"></a><a class="docs-heading-anchor-permalink" href="#Well-posedness-and-general-context" title="Permalink"></a></h2><ul><li><p>Well-posedness, or the availability of a unique robust solution, is easier to prove in some problems than others. For example, using the heat-diffusion equation this section demonstrates that some combinations of the above boundary conditions do not produce a unique solution. The problem of imposing boundary conditions in climate models is more complex, so well-posedness is more difficult to prove analytically, as discussed below. </p></li><li><p>Examples of imposing BCs:  </p><ol><li><p><strong>Diffusion equation in steady state</strong></p><ul><li>The prognostic heat equation rewritten in terms of potential temperature, <span>$θ$</span>, is:</li></ul><p><span>$\frac{\partial θ}{\partial t} = - ∇ \cdot (κ ∇ θ)$</span></p><ul><li>for simplicity, we assume a steady state (<span>$\partial / \partial t = 0$</span>), a diffusivity of <span>$\kappa = 1$</span> m<span>$^2$</span> s<span>$^{-1}$</span> and that we&#39;re only in 1D (i.e. <span>$∇ = \partial / \partial x$</span>). Solving this requires two BCs in space (assuming we have no constraints in time), so we have: </li></ul><p><span>$\frac{\partial^2 θ}{\partial x^2} = 0$</span></p><ul><li>upon integration in <span>$x$</span> we expect </li></ul><p><span>$\frac{\partial θ}{\partial x} = c_1$</span> and <span>$x = c_1x + c_2$</span>, where <span>$c_1$</span> and <span>$c_2$</span> are set by the boundary conditions. </p><ul><li>If we have two Neumann boundary conditions (e.g. <span>$dT/dx = 1$</span> at both <span>$x_0$</span> = 1 and <span>$x_N$</span> ), we can only obtain <span>$c_1$</span> and the solution is not unique. We therefore need one of the boundaries to be constrained using a Dirichlet BC. </li></ul></li><li><p><strong>Advection-diffusion equation with a linear flux</strong></p><ul><li>stepping up the ladder of complexity is the advection diffusion problem:   <span>$\frac{\partial θ}{\partial t} = - ∇ \cdot (\vec{u} \theta + κ ∇ θ) = - ∇ \cdot (F_{non-diffusive} + F_{diffusive})$</span></li><li><a href="https://www.scielo.br/pdf/tema/v18n2/2179-8451-tema-18-02-00253.pdf">Miyaoka et al 17</a> have shown that by taking advantage of mass conservation, it is possible to derive a general BC for the advection-diffusion problem, as long as the flux is linear in <span>$\theta$</span> (e.g. <span>$\vec{u}(x,y,z)$</span>). Evidently, this is still insufficient for climate modelling purposes.</li></ul></li><li><p><strong>Navier Stokes and climate models</strong></p><ul><li>well-posedness of the NS equations is still unknown (after all it is one of the Clay Mathematics Institute&#39;s Millennium Problems)</li><li>in climate modelling it is often considered sufficient to use the general rule of thumb and use as many BCs as we have derivatives, without explicitly proving that the problem is analytically well posed. </li><li>we implicitly assume mass conservation and the divergence theorem like in the <a href="https://www.scielo.br/pdf/tema/v18n2/2179-8451-tema-18-02-00253.pdf">Miyaoka et al 17</a> study above</li><li>in practice, for global atmospheric models there are different constraints on each of the two boundaries:<ul><li>lower boundary of the atmosphere<ul><li><strong>Impenetrable</strong>: reflective BCs are imposed by setting <span>$w=0$</span> and the tangential wind remains unchanged. This is the <code>FreeSlip()</code> BC for momentum, <code>Impenetrable()</code> for mass and <code>Insulating()</code> for energy/moisture/tracers which may be used for atmosphere-only idealized studies.  </li><li><strong>Prescribed</strong>: it is common to prescribe a constant (or variable if coupled to another model) surface temperature. This allows calculation of a surface sensible and latent heat fluxes, which are then added to any other sources of heat at the surface (e.g. radiation fluxes, etc). Once all surface fluxes are summed up, they are then passed to the atmospheric model as fluxes that enter the prognostic equations at the boundaries. E.g. see the <code>Prescribed()</code> BC, and <code>CoupledPrimary()</code>, <code>CoupledSecondary()</code> BCs for more complex setups.</li></ul></li><li>upper boundary of the atmosphere<ul><li><strong>Impenetrable</strong>: reflective BCs are imposed by setting <span>$w=0$</span> and the tangential wind remains unchanged. This is the <code>FreeSlip()</code> BC for momentum, <code>Impenetrable()</code> for mass and <code>Insulating()</code> for energy/moisture/tracers which may be used for atmosphere-only idealized studies.  </li><li><strong>Open</strong>: it is undesirable to produce reflection in the upper levels, but open BCs are more difficult to implement</li><li><strong>Sponge layer</strong>: an alternative to the above can be obtained by artificial (often linear or 2nd order) damping in the upper levels. The down side is that this sponge layer ofen takes up a substantial part of the model&#39;s depth.  </li></ul></li></ul></li></ul></li></ol></li></ul><h2 id="Implementation-in-the-ClimateMachine.jl"><a class="docs-heading-anchor" href="#Implementation-in-the-ClimateMachine.jl">Implementation in the ClimateMachine.jl</a><a id="Implementation-in-the-ClimateMachine.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-in-the-ClimateMachine.jl" title="Permalink"></a></h2><pre><code class="language-none">Boundaries in DG:
    __________-  bc +
   | element  |  |  |            - = internal state
   | in       |  |  |           bc = boundary state 
   | question |  |  |            + = ghost state
   |__________|  |  |
              \__ __/
                 V
    same location in space</code></pre><ul><li>BCs in ClimateMachine.jl are imposed separately for the different compute kernels as illustrated by the <a href="https://github.com/CliMA/ExperimentsMachine/blob/main/process_targetted_tests/hyperdiffusion/CM_flow.pdf">CMFlowChart</a>.</li><li>For the AtmosModel, the BCs that need to be considered are:</li></ul><h3 id="Mass"><a class="docs-heading-anchor" href="#Mass">Mass</a><a id="Mass-1"></a><a class="docs-heading-anchor-permalink" href="#Mass" title="Permalink"></a></h3><ul><li><p><code>Impenetrable()</code>: </p><ul><li><p>no normal component of mass flux, which means <span>$u$</span> at <span>$bc$</span>:   <span>$u_{bc} = \vec{u}^- - (\hat{n} \cdot u^-) \hat{n}$</span></p></li><li><p>In conjunction with the <em>CentralNumericalFlux</em> at the boundary, this can be imposed via the ghost state as:</p><pre><code class="language-none">  # use CentralNumericalFlux with this reflective ghost state  ​
  function atmos_momentum_boundary_state!(_...)
          ​state⁺.ρu = state⁻.ρu - 2 * dot(state⁻.ρu, n) .* SVector(n) 
  ​end</code></pre></li></ul></li><li><p><code>Penetrable()</code>: </p><ul><li><p>this means no boundary condition (free surface)</p><pre><code class="language-none">  # use the transmissive boundary flux: 
  function atmos_momentum_boundary_state!(_...)
          ​state⁺.ρu = state⁻.ρu
  ​end</code></pre></li></ul></li></ul><h3 id="Momentum"><a class="docs-heading-anchor" href="#Momentum">Momentum</a><a id="Momentum-1"></a><a class="docs-heading-anchor-permalink" href="#Momentum" title="Permalink"></a></h3><ul><li><p><code>NoSlip()</code>: </p><ul><li><p>this means <span>$u$</span> vanishes are the boundary (i.e. Dirichlet BC), so that <span>$u_{bc} = 0$</span></p></li><li><p>In conjunction with the <em>CentralNumericalFlux</em> at the boundary, this can be imposed via the ghost state as:</p><pre><code class="language-none">  function atmos_momentum_boundary_state!(nf::Union{NumericalFluxFirstOrder, NumericalFluxGradient}, _...)
      state⁺.ρu = -state⁻.ρu
  end
  
  # a stabilising penalty term can be used here:
  numerical_boundary_flux_first_order!(_...) = ... end

  atmos_momentum_normal_boundary_flux_second_order!(_...) = nothing # no contribution from nF_diffusive</code></pre></li></ul></li><li><p><code>FreeSlip()</code>: <span>$\nabla_h \cdot\vec{u} = 0$</span>, <span>$\hat{n} \cdot u = 0$</span></p><ul><li>no diffusive normal flux at the boundary and no drag on the tangential components</li><li><p class="math-container">\[u_{bc}\]</p>is determined by the mass flux BC above</li></ul></li></ul><pre><code class="language-none">        function atmos_momentum_boundary_state!(nf::NumericalFluxFirstOrder, _...)
                state⁺.ρu -= 2 * dot(state⁻.ρu, n) .* SVector(n) # reflective to impose no normal flux
        end
        function atmos_momentum_boundary_state!(nf::NumericalFluxGradient, _...)
                state⁺.ρu -= dot(state⁻.ρu, n) .* SVector(n) # non-reflective to capture the sign of the gradient
        end
        atmos_momentum_normal_boundary_flux_second_order!(_...) = nothing  # no contribution from nF_diffusive</code></pre><ul><li><p><code>DragLaw()</code>:</p><ul><li><p>use momentum constraints on <span>$u_{bc}$</span>, just like FreeSlip(), but with a non-zero second-order normal flux (nF_diffusive) </p><pre><code class="language-none">  function atmos_momentum_boundary_state!(nf::Union{NumericalFluxFirstOrder, NumericalFluxGradient}, _...)
      atmos_momentum_boundary_state!(nf, Impenetrable(FreeSlip()), _...)
  end
  function atmos_momentum_normal_boundary_flux_second_order!(_...)
      fluxᵀn.ρu += C * state⁻.ρ * |u_h| * u_h # contribution from nF_diffusive
  end</code></pre></li></ul></li></ul><h3 id="Energy-/-Moisture-/-Tracers"><a class="docs-heading-anchor" href="#Energy-/-Moisture-/-Tracers">Energy / Moisture / Tracers</a><a id="Energy-/-Moisture-/-Tracers-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-/-Moisture-/-Tracers" title="Permalink"></a></h3><ul><li><p><code>Insulating()</code>:</p><ul><li><p>no normal diffusive flux (nF<em>diffusive) across the boundary (homogeneous Neumann BC) imposed via the second order flux, with the first-order and gradient fluxes assuming u</em>{bc}$ from the mass and momentum BCs for consistency</p><pre><code class="language-none">  atmos_energy_boundary_state!(_...) 
      state⁺.ρe = state⁻.ρe
  end
  atmos_energy_normal_boundary_flux_second_order!( _...,) = nothing</code></pre></li></ul></li><li><p><code>Prescribed()</code>, <code>CoupledPrimary()</code>, <code>CoupledSecondary()</code></p><ul><li><p>same as Insulating(), but with a non-zero second-order normal flux (nF_diffusive)</p><pre><code class="language-none">  atmos_energy_boundary_state!(_...) 
      state⁺.ρe = state⁻.ρe
  end
  function atmos_energy_normal_boundary_flux_second_order!(_...)
      fluxᵀn.energy.ρe -= bc_energy.fn(state⁻, aux⁻, t)
  end</code></pre><p>where <code>bc_energy.fn</code> can be a flux value or a relaxation function to a surface temperature (e.g. see the slab land/ocean, bulk formulation, or the M-O flux-based NishizawaEnergyFlux function). NB: Dirichlet BC is not normally applied in this context.</p></li></ul></li></ul><h2 id="BC-stability-in-DG-for-idealized-problems-(probably-delete-or-expand?)"><a class="docs-heading-anchor" href="#BC-stability-in-DG-for-idealized-problems-(probably-delete-or-expand?)">BC stability in DG for idealized problems (probably delete or expand?)</a><a id="BC-stability-in-DG-for-idealized-problems-(probably-delete-or-expand?)-1"></a><a class="docs-heading-anchor-permalink" href="#BC-stability-in-DG-for-idealized-problems-(probably-delete-or-expand?)" title="Permalink"></a></h2><ul><li>boundary fluxes (numerical + physical) are implementable in DG via boundary numerical fluxes, between the interior point (<span>$x^-$</span>) and its exterior ghost equivalent (<span>$x^+$</span>). These need to be applied depending on the problem at hand. For example in the advective problem, the BCs will need to consider the flow direction, so that information is carried in the correct direction (i.e. downstream). </li><li><strong>Advection problem</strong><ul><li>Imposed BCs<ul><li>A) Impose BCs via numerical fluxes<ul><li>e.g. central boundary flux (or another numerical flux, e.g. Rusanov):</li></ul><span>$u\theta_{bc} = \frac{u\theta^- + u\theta^+}{2} = \frac{u\theta^- + f_0}{2}$</span></li><li>B) Impose the flux directly at the boundary:   <span>$u\theta_{bc} = f_0$</span>    which is implemented via the ghost point as <span>$\theta^+ = \theta^- + 2\theta_0 \rightarrow$</span>  reflection principle</li><li>For an advective problem Lyapunov function analysis shows that A) is more dissipative (and stable) but B) is closer to the analytical conservation solution </li></ul></li><li>Free endpoints / open boundaries   <span>$u\theta_{bc} = u\theta^-$</span>   which is implemented as <span>$\theta^+ = \theta^-  \rightarrow$</span> transmissive / free boundary (endpoint is just what it is)</li></ul></li><li><strong>Diffusion problem</strong><ul><li>call the diffusive flux <span>$\sigma = \kappa\partial_x \theta$</span></li><li>A) Neumann on <span>$\theta$</span><ul><li>is basically Dirichlet on <span>$\sigma$</span>, so that the boundary is transmissive <span>$\theta$</span></li></ul><span>$\sigma_{bc} = \frac{\sigma^- + \sigma^+}{2}$</span>   and <span>$\sigma^+ = \sigma^- + 2f_0$</span><ul><li><p class="math-container">\[\theta_{bc} = \theta_0\]</p>or <span>$\sigma_{bc} = 0$</span> are stable and conservative</li></ul></li><li>B) Dirichlet<ul><li>transmissive on <span>$\sigma_{bc}$</span> and explicit BCs on <span>$\theta_{bc}$</span> are stable and conservative</li></ul></li></ul></li><li><strong>Advection-diffusion problem</strong><ul><li>best choice for the numerical solution to mimic the analytical solution is  <span>$u\theta_{bc} = 0$</span> and <span>$\sigma_{bc}=\sigma^-$</span></li><li>best choice for sufficient dissipation (and thus a more stable solution) is  <span>$u\theta_{bc} = u\theta^- / 2$</span> and <span>$\theta_{bc}=0$</span> and <span>$\sigma_{bc}=\sigma^-$</span></li></ul></li></ul><h2 id="References:"><a class="docs-heading-anchor" href="#References:">References:</a><a id="References:-1"></a><a class="docs-heading-anchor-permalink" href="#References:" title="Permalink"></a></h2><ul><li>CliMA&#39;s numerics_old DesignDoc</li><li><a href="https://www.realclimate.org/index.php/archives/2009/01/faq-on-climate-models-part-ii/">useful Q&amp;As</a> </li><li><a href="https://climateextremes.org.au/wp-content/uploads/2019/06/Introduction-to-Atmospheic-Modelling-1-Todd-Lane.pdf">Todd Lane&#39;s talk for climate modelling context</a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 14 September 2021 22:59">Tuesday 14 September 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
