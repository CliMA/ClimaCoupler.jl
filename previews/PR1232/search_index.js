var documenterSearchIndex = {"docs":
[{"location":"checkpointer/#Checkpointer","page":"Checkpointer","title":"Checkpointer","text":"","category":"section"},{"location":"checkpointer/#How-to-save-and-restart-from-checkpoints","page":"Checkpointer","title":"How to save and restart from checkpoints","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"ClimaCoupler supports saving and reading simulation checkpoints. This is useful to split a long simulation into smaller, more manageable chunks.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Checkpoints are a mix of HDF5 and JLD2 files and are typically saved in a checkpoints folder in the simulation output. See Utilities.setup_output_dirs for more information.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"!!! known limitations","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"- The number of MPI processes has to remain the same across checkpoints\n- Restart files are generally not portable across machines, julia versions, and package versions\n- Adding/changing new component models will probably require adding/changing code","category":"page"},{"location":"checkpointer/#Saving-checkpoints","page":"Checkpointer","title":"Saving checkpoints","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"If you are running a model (such as AMIP), chances are that you can enable checkpointing just by setting a command-line argument; The checkpoint_dt option controls how frequently a checkpoint should be produced.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"If your model does not come with this option already, you can checkpoint the simulation by adding a callback that calls the Checkpointer.checkpoint_sims function.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"For example, to add a callback to checkpoint every hour of simulated time, assuming you have a start_date","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"import Dates\n\nimport ClimaCoupler: Checkpointer, TimeManager\nimport ClimaDiagnostics.Schedules: EveryCalendarDtSchedule \n\nschedule = EveryCalendarDtSchedule(Dates.Hour(1); start_date)\ncheckpoint_callback = TimeManager.Callback(schedule_checkpoint, Checkpointer.checkpoint_sims)\n\n# In the coupling loop:\nTimeManager.maybe_trigger_callback(checkpoint_callback, coupled_simulation, time)","category":"page"},{"location":"checkpointer/#Reading-checkpoints","page":"Checkpointer","title":"Reading checkpoints","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"There are two ways to restart a simulation from checkpoints. By default, ClimaCoupler tries finding suitable checkpoints and automatically use them. Alternatively, you can specify a directory restart_dir and a simulation time restart_t and restart from files saved in the given directory at the given time. If the model you are running supports writing checkpoints via command-line argument, it will probably also support reading them. In this case, the arguments restart_dir and restart_t identify the path of the top level directory containing all the checkpoint files and the simulated times in second.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"If the model does not support directly reading a checkpoint, the Checkpointer module provides a straightforward way to add this feature. Checkpointer.restart! takes a coupled simulation, a restart_dir, and a restart_t and overwrites the content of the coupled simulation with what is in the checkpoint. ","category":"page"},{"location":"checkpointer/#Developer-notes","page":"Checkpointer","title":"Developer notes","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"In theory, the state of the component models should fully determine the state of the coupled simulation and one should be able to restart a coupled simulation just by using the states of the component models. Unfortunately, this is currently not the case in ClimaCoupler. The main reason for this is the complex interdependencies between component models and within ClimaAtmos which make the initialization step inconsistent. For example, in a coupled simulation, the surface albedo should be determined by the surface models and used by the atmospheric model for radiation transfer, but ClimaAtmos also tries to set the surface albedo (since it has to do so when run in standalone mode). In addition to this, ClimaAtmos has a large cache that has internal interdependencies that are hard to disentangle, and changing a field might require changing some other field in a different part of the cache. As a result, it is not easy for ClimaCoupler to consistently do initialization from a cold state. To conclude, restarting a simulation exclusively using the states of the component models is currently impossible.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Given that restarting a simulation from the state is impossible, ClimaCoupler needs to save the states and the caches. Let us review how we use ClimaCore.InputOutput and JLD2 package to accomplish this.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"ClimaCore.InputOutput provides a loss-less way to save the content of certain ClimaCore objects to HDF5 files. Objects saved in this way are not tied to a particular computing device or configuration. When running with MPI, ClimaCore.InputOutput are also efficiently written in parallel.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Unfortunately, ClimaCore.InputOutput only supports certain objects, such as Fields and Spaces, but the cache in component models is more complex than this and contains complex objects with highly stateful quantities (e.g., C pointers). Because of this, model states are saved to HDF5 but caches must be saved to JLD2 files.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"JLD2 allows us to save more complex objects without writing specific serialization methods for every struct. JLD2 allows us to take a big step forward, but there are still several challenges that need to be solved:","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"JLD2 does not support CUDA natively. To go around this, we have to move","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"everything onto the CPU first. Then, when the data is read back, we have to   move it back to the GPU.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"JLD2 does not support MPI natively. To go around this, each process writes","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"its jld2 checkpoint and reads it back. This introduces the constraint that   the number of MPI processes cannot change across restarts.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Some quantities are best not saved and read (for example, anything with","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"pointers). For this, we write a recursive function that traverses the cache   and only restores quantities of a certain type (typically, ClimaCore   objects)","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Point 3. adds significant amount of code and requires component models to specify how their cache has to be restored.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"If you are adding a component model, you have to extend the","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Checkpointer.get_model_prog_state\nCheckpointer.get_model_cache\nCheckpointer.restore_cache!","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"methods. ","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"ClimaCoupler moves objects to the CPU with Adapt(Array, x). Adapt traverses the object recursively, and proper Adapt methods have to be defined for every object involved in the chain. The easiest way to do this is using the Adapt.@adapt_structure macro, which defines a recursive Adapt for the given object.","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"Types to watch for:","category":"page"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"MPI related objects (e.g., MPICommsContext)\nTimeVaryingInputs (because they contain NCDatasets, which contain pointers to files)","category":"page"},{"location":"checkpointer/#Checkpointer-API","page":"Checkpointer","title":"Checkpointer API","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"    ClimaCoupler.Checkpointer.get_model_prog_state\n    ClimaCoupler.Checkpointer.get_model_cache\n    ClimaCoupler.Checkpointer.restart!\n    ClimaCoupler.Checkpointer.checkpoint_sims\n    ClimaCoupler.Checkpointer.t_start_from_checkpoint","category":"page"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.get_model_prog_state","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.get_model_prog_state","text":"get_model_prog_state(sim::Interfacer.ComponentModelSimulation)\n\nReturns the model state of a simulation as a ClimaCore.FieldVector. This is a template function that should be implemented for each component model.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.get_model_cache","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.get_model_cache","text":"get_model_cache(sim::Interfacer.ComponentModelSimulation)\n\nReturns the model cache of a simulation. This is a template function that should be implemented for each component model.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.restart!","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.restart!","text":"restart!(cs::CoupledSimulation, checkpoint_dir, checkpoint_t)\n\nOverwrite the content of cs with checkpoints in checkpoint_dir at time checkpoint_t.\n\nReturn a true if the simulation was restarted.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.checkpoint_sims","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.checkpoint_sims","text":"checkpoint_sims(cs::CoupledSimulation)\n\nThis is a callback function that checkpoints all simulations defined in the current coupled simulation.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.t_start_from_checkpoint","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.t_start_from_checkpoint","text":"t_start_from_checkpoint(checkpoint_dir)\n\nLook for restart files in checkpoint_dir, if found, return the time of the latest. If not found, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#FieldExchanger","page":"FieldExchanger","title":"FieldExchanger","text":"","category":"section"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"This module contains general functions for the exchange of fields between the atmospheric and surface component models.","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"The FieldExchanger needs to populate the coupler with","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"atmospheric fields (mostly fluxes), via the import_atmos_fields! function\naverage surface properties of each coupler gridpoint, via the import_combined_surface_fields! function","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"The component models are updated by broadcasting the coupler fields, via the update_model_sims! function. For an update, this function requires that update_field! is defined for the particular variable and component model. Currently, we support the:","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"AtmosModelSimulation: albedo, surface_temperature\nif calculating fluxes in the atmospheric model: roughness_momentum, roughness_buoyancy, beta\nSurfaceModelSimulation: air_density, turbulent_energy_flux, turbulent_moisture_flux, radiative_energy_flux_sfc, liquid_precipitation, snow_precipitation","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"If an update_field! function is not defined for a particular component model, it will be ignored.","category":"page"},{"location":"fieldexchanger/#FieldExchanger-API","page":"FieldExchanger","title":"FieldExchanger API","text":"","category":"section"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"    ClimaCoupler.FieldExchanger.import_atmos_fields!\n    ClimaCoupler.FieldExchanger.import_combined_surface_fields!\n    ClimaCoupler.FieldExchanger.update_model_sims!\n    ClimaCoupler.FieldExchanger.update_sim!\n    ClimaCoupler.FieldExchanger.reinit_model_sims!\n    ClimaCoupler.FieldExchanger.step_model_sims!\n    ClimaCoupler.FieldExchanger.update_surface_fractions!","category":"page"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.import_atmos_fields!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.import_atmos_fields!","text":"import_atmos_fields!(csf, model_sims, boundary_space, turbulent_fluxes)\n\nUpdates the coupler with the atmospheric fluxes. The Interfacer.get_field functions (:turbulent_energy_flux, :turbulent_moisture_flux, :radiative_energy_flux_sfc, :liquid_precipitation, :snow_precipitation) have to be defined for the amtospheric component model type.\n\nArguments\n\ncsf: [NamedTuple] containing coupler fields.\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\nboundary_space: [Spaces.AbstractSpace] the space of the coupler surface.\nturbulent_fluxes: [TurbulentFluxPartition] denotes a flag for turbulent flux calculation.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.import_combined_surface_fields!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.import_combined_surface_fields!","text":"import_combined_surface_fields!(csf, model_sims, turbulent_fluxes)\n\nUpdates the coupler with the surface properties. The Interfacer.get_field functions for (:surface_temperature, :surface_direct_albedo, :surface_diffuse_albedo, :roughness_momentum, :roughness_buoyancy, :beta) need to be specified for each surface model.\n\nArguments\n\ncsf: [NamedTuple] containing coupler fields.\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\nturbulent_fluxes: [TurbulentFluxPartition] denotes a flag for turbulent flux calculation.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.update_model_sims!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.update_model_sims!","text":"update_model_sims!(model_sims, csf, turbulent_fluxes)\n\nIterates update_sim! over all component model simulations saved in cs.model_sims.\n\nArguments\n\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\ncsf: [NamedTuple] containing coupler fields.\nturbulent_fluxes: [TurbulentFluxPartition] denotes a flag for turbulent flux calculation.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.update_sim!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.update_sim!","text":"update_sim!(atmos_sim::Interfacer.AtmosModelSimulation, csf)\n\nUpdates the surface fields for temperature, roughness length, albedo, and specific humidity.\n\nArguments\n\natmos_sim: [Interfacer.AtmosModelSimulation] containing an atmospheric model simulation object.\ncsf: [NamedTuple] containing coupler fields.\n\n\n\n\n\nupdate_sim!(sim::SurfaceModelSimulation, csf, area_fraction)\n\nUpdates the surface component model cache with the current coupler fields of Fturbenergy, Fradiative, Fturbmoisture, Pliq, and ρ_sfc.\n\nArguments\n\nsim: [Interfacer.SurfaceModelSimulation] containing a surface model simulation object.\ncsf: [NamedTuple] containing coupler fields.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.reinit_model_sims!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.reinit_model_sims!","text":"reinit_model_sims!(model_sims)\n\nIterates reinit! over all component model simulations saved in cs.model_sims.\n\nArguments\n\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.step_model_sims!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.step_model_sims!","text":"step_model_sims!(model_sims, t)\n\nIterates step! over all component model simulations saved in cs.model_sims.\n\nArguments\n\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\nt: [AbstractFloat] denoting the simulation time.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.update_surface_fractions!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.update_surface_fractions!","text":"update_surface_fractions!(cs::Interfacer.CoupledSimulation)\n\nUpdates dynamically changing area fractions. Maintains the invariant that the sum of area fractions is 1 at all points.\n\nArguments\n\ncs: [Interfacer.CoupledSimulation] containing area fraction information.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#FieldExchanger-Internal-Functions","page":"FieldExchanger","title":"FieldExchanger Internal Functions","text":"","category":"section"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"    ClimaCoupler.FieldExchanger.combine_surfaces!\n    ClimaCoupler.FieldExchanger.dummmy_remap!\n    ClimaCoupler.FieldExchanger.nans_to_zero","category":"page"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.combine_surfaces!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.combine_surfaces!","text":"combine_surfaces!(combined_field::CC.Fields.Field, sims, field_name::Val)\n\nSums the fields, specified by field_name, weighted by the respective area fractions of all surface simulations. THe result is saved in combined_field.\n\nArguments\n\ncombined_field: [CC.Fields.Field] output object containing weighted values.\nsims: [NamedTuple] containing simulations .\nfield_name: [Val] containing the name Symbol of the field t be extracted by the Interfacer.get_field functions.\n\nExample\n\ncombine_surfaces!(temp_field, cs.model_sims, Val(:surface_temperature))\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.dummmy_remap!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.dummmy_remap!","text":"dummmy_remap!(target, source)\n\nSimple stand-in function for remapping. For AMIP we don't need regridding of surface model CC.Fields. When we do, we re-introduce the ClimaCoreTempestRemap remapping functions.\n\nArguments\n\ntarget: [CC.Fields.Field] destination of remapping.\nsource: [CC.Fields.Field] source of remapping.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.nans_to_zero","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.nans_to_zero","text":"nans_to_zero(v)\n\nReplaces NaNs with zeros, otherwise returns the value.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"This module contains functions, objects, and constants used by various modules in the coupler.","category":"page"},{"location":"utilities/#Utilities-API","page":"Utilities","title":"Utilities API","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"ClimaCoupler.Utilities.swap_space!\nClimaCoupler.Utilities.get_comms_context\nClimaCoupler.Utilities.get_device\nClimaCoupler.Utilities.show_memory_usage\nClimaCoupler.Utilities.setup_output_dirs\nClimaCoupler.Utilities.time_to_seconds\nClimaCoupler.Utilities.binary_mask","category":"page"},{"location":"utilities/#ClimaCoupler.Utilities.swap_space!","page":"Utilities","title":"ClimaCoupler.Utilities.swap_space!","text":"swap_space!(space_out::CC.Spaces.AbstractSpace, field_in::CC.Fields.Field)\n\nRemap the values of a field onto a new space.\n\nArguments\n\nspace_out: [CC.Spaces.AbstractSpace] The axes of the space we want to remap onto\nfield_in: [CC.Fields.Field] to be remapped to new space.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ClimaCoupler.Utilities.get_comms_context","page":"Utilities","title":"ClimaCoupler.Utilities.get_comms_context","text":"get_comms_context(config_dict)\n\nSets up the appropriate ClimaComms context for the device the model is to be run on, choosing from the following options:     - CPU single threaded     - CPU with MPI     - GPU\n\nIf no device is passed to ClimaComms.context() then ClimaComms automatically selects the device from which this code is called.\n\nArguments\n\nconfig_dict: dictionary containing a \"device\" flag which decides which device context is needed\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ClimaCoupler.Utilities.get_device","page":"Utilities","title":"ClimaCoupler.Utilities.get_device","text":"get_device(config_dict)\n\nReturns the device on which the model is being run\n\nArguments\n\nconfig_dict: dictionary containing a \"device\" flag which decides which device to run on\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ClimaCoupler.Utilities.show_memory_usage","page":"Utilities","title":"ClimaCoupler.Utilities.show_memory_usage","text":"show_memory_usage()\n\nDisplay and return the maximum resident set size (RSS) memory footprint on the CPU of this process since it began.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ClimaCoupler.Utilities.setup_output_dirs","page":"Utilities","title":"ClimaCoupler.Utilities.setup_output_dirs","text":"setup_output_dirs(output_dir = pwd(),\n    artifacts_dir = joinpath(output_dir, \"artifacts\"),\n    checkpoints_dir = joinpath(output_dir, \"checkpoints\"),\n    regrid_dir = nothing,\n    comms_ctx,\n)\n\nCreate output directories for the experiment. If comms_ctx is provided, only the root process will create the directories. By default, the artifacts and checkpoints directories are created inside the output directory with the names artifacts/ and checkpoints/. The regrid directory is by default created as a temporary directory inside the output directory and is automatically deleted when the process exits.\n\nClimaUtilities.OutputPathGenerator is used so that simulations can be re-run and re-started. The output path looks like:\n\ncoupler_output_dir_amip/\n├── checkpoints\n│       └── checkpoints for the various models\n├── artifacts\n│       └── plots produced by the postporcessing step\n├── regrid_tmp_<random_tempdir>/\n│       └── temporary files used for regridding\n├── output_0000/\n│   ├── atmos/\n│   │   └── output of the atmos model\n│   └── ocean/\n│       └── output of the ocean model\n├── output_0001/\n│   └── ... component model outputs in their folders ...\n├── output_0002/\n│   └── ... component model outputs in their folders ...\n└── output_active -> output_0002/\n\nArguments\n\noutput_dir::String: The directory where the output files will be stored. Default is the current directory.\nregrid_dir::String: The directory where the regridded files will be stored. Default is output_dir/regrid_tmp_<random_tempdir>/.\ncheckpoint_dir::String: The directory where the checkpoint files will be stored. Default is output_dir/checkpoints/.\nartifacts_dir::String: The directory where the artifacts will be stored. Default is output_dir/artifacts/.\ncomms_ctx::Union{Nothing, ClimaComms.AbstractCommsContext}: The communicator context. If provided, only the root process will create the directories.\n\nReturns\n\nA tuple with the paths to the output, artifacts, regrid, and checkpoints directories.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ClimaCoupler.Utilities.time_to_seconds","page":"Utilities","title":"ClimaCoupler.Utilities.time_to_seconds","text":"time_to_seconds(s::String)\n\nConvert a string to seconds. The string should be in the format numberunit, where unit is one of secs, mins, hours, or days.\n\nArguments\n\ns::String: The string to convert to seconds.\n\nReturns\n\nThe number of seconds represented by the string.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ClimaCoupler.Utilities.binary_mask","page":"Utilities","title":"ClimaCoupler.Utilities.binary_mask","text":"binary_mask(var, threshold)\n\nConverts a number var to 1, if var is greater or equal than a given threshold value, or 0 otherwise, keeping the same type.\n\nArguments\n\nvar: [FT] value to be converted.\nthreshold: [FT] cutoff value for conversions.\n\n\n\n\n\nbinary_mask(var)\n\nConverts a number var to 1, if var is greater or equal than eps(FT), or 0 otherwise, keeping the same type.\n\nArguments\n\nvar: [FT] value to be converted.\n\n\n\n\n\n","category":"function"},{"location":"generated/sea_breeze/land_rhs/#Land-Model","page":"Land Model","title":"Land Model","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"import DiffEqCallbacks\nimport SciMLBase\nimport ClimaCore as CC\nimport ClimaTimeSteppers as CTS","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"Load coupled simulation code","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"include(\"../CoupledSims/coupled_sim.jl\")","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Slab-Land-ODE","page":"Land Model","title":"Slab Land ODE","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"For our land component, we solve a simple slab land ODE:","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"rho_l c_l H_l partial_t T_lnd = - F_integ  Delta t_coupler","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"where rho_l = 1500 kg m ^-3, c_l=800 J K ^-1 kg ^-1, H_l=1 m are the density, specific heat and depth of the land slab,\nand F_integ is the integrated surface fluxes in time.","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Model-Code","page":"Land Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"function lnd_rhs!(du, u, (parameters, F_accumulated), t)\n    \"\"\"\n    Slab layer equation\n        d(T_lnd)/dt = - (F_accumulated + G) / (h_lnd * ρ_lnd * c_lnd)\n        where\n            F_accumulated = F_integrated / Δt_coupler\n    \"\"\"\n    (; lnd_h, lnd_ρ, lnd_c) = parameters\n    (; T_sfc) = du\n\n    @. T_sfc = (-F_accumulated) / (lnd_h * lnd_ρ * lnd_c)\nend\n\n# set up domain\nfunction hspace_1D(xlim = (-π, π), npoly = 0, helem = 10)\n    FT = Float64\n\n    domain =\n        CC.Domains.IntervalDomain(CC.Geometry.XPoint{FT}(xlim[1]), CC.Geometry.XPoint{FT}(xlim[2]), periodic = true)\n    mesh = CC.Meshes.IntervalMesh(domain; nelems = helem)\n    topology = CC.Topologies.IntervalTopology(mesh)\n\n    # Finite Volume Approximation: Gauss-Lobatto with 1pt per element\n    quad = CC.Spaces.Quadratures.GL{npoly + 1}()\n    space = CC.Spaces.SpectralElementSpace1D(topology, quad)\n\n    return space\nend\n\n# init simulation\nfunction lnd_init(; xmin = -1000, xmax = 1000, helem = 20, npoly = 0)\n\n    # construct domain spaces - get only surface layer (NB: z should be zero, not z = first central height)\n    space = hspace_1D((xmin, xmax), npoly, helem)\n    coords = CC.Fields.coordinate_field(space)\n    domain = space\n\n    # initial condition\n    T_sfc = map(coords) do coord\n        T_sfc = 283.0\n    end\n\n    # prognostic variable\n    Y = CC.Fields.FieldVector(T_sfc = T_sfc)\n\n    return Y, domain\nend","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Coupled-Land-Wrappers","page":"Land Model","title":"Coupled Land Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"# Land Simulation - later to live in ClimaLand\nstruct LandSim <: AbstractLandSim\n    integrator::Any\nend\n\nfunction LandSim(Y_init, t_start, dt, t_end, timestepper, p, saveat, callbacks = DiffEqCallbacks.CallbackSet())\n    ode_algo = CTS.ExplicitAlgorithm(timestepper)\n    ode_function = CTS.ClimaODEFunction(T_exp! = lnd_rhs!)\n\n    problem = SciMLBase.ODEProblem(ode_function, Y_init, (t_start, t_end), p)\n    lnd_integ = SciMLBase.init(problem, ode_algo, dt = dt, saveat = saveat, adaptive = false, callback = callbacks)\n\n    return LandSim(lnd_integ)\nend\n\nfunction coupler_push!(coupler::CouplerState, land::LandSim)\n    coupler_put!(coupler, :T_sfc_land, land.integrator.u.T_sfc, land)\nend\n\nfunction coupler_pull!(land::LandSim, coupler::CouplerState)\n    coupler_get!(land.integrator.p.F_sfc, coupler, :F_sfc, land)\n    land.integrator.p.F_sfc ./= coupler.Δt_coupled\nend","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"performance/#Performance-Analysis-Tools","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"","category":"section"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"Until commit 7a7e98, ClimaCoupler provided included performance jobs. You can find them by following the link above.","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"Below is a short description.","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"ClimaCoupler.jl provides basic tools for analyzing performance:","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"Flame graphs: the perf/flame.jl script is run by Buildkite to produce flame graphs using ProfileCanvas.jl in the perf/output/ directory.\nJob walltime and allocation history: use Buildkite to trigger the build_history script to output an interactive plot with the history of memory usage and time elapsed for each tracked job (default: current build and past builds of the staging branch over the past year). Use key to select which jobs to track. More documentation can be found in the SLURM-Buildkite Wiki.","category":"page"},{"location":"performance/#Flame-Graph-Interpretation","page":"Performance Analysis Tools","title":"Flame Graph Interpretation","text":"","category":"section"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"use for single-process (un)threaded performance CPU profiling of individual stack traces. It provides a tree representation of a set of backtraces, showing the dependence and CPU cost of each function.\nhere is an example of a flame graph of ClimaCoupler's AMIP run, produced by Buildkite running the perf/flame.jl script:","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"(Image: canvas)","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"each row along the y-axis represents a level of backtraces. In this case the lowermost level is at the top, and the top level represents what is directly being run on the CPU. The stacks in each level are sorted alphabetically (not chronologically, like flame charts). The column width is proportional to the presence in samples (related to allocations). The colors are grouped into runtime-dispatch, gc, compilation and default. The intensity is random.\nwe also have a local beta version of flame graphs (in perf/ProfileCanvasDiff.jl and perf/ProfileViewerDiff.js), triggered by the perf/flame_diff.jl script, which plots the same flame graphs as above but with the color corresponding to whether the stack allocation has been reduced (blue) or increased (red) compared to the last staged runs. The color intensity is proportional to the fractional change, and black signifies untracked traces. The default is to show the cumulative allocation (current function + all its children functions). By setting self_count to true, we can also count only the allocations of the current function itself, allowing us to isolate allocation changes within our software from changes in the upstream packages.","category":"page"},{"location":"performance/#References","page":"Performance Analysis Tools","title":"References","text":"","category":"section"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"Description of flame graphs and their interpretation\nClimaCore tips for writing performant code\nGeneral Julia-specific performance tips\nLogging performance history using Buildkite and SLURM\nNSight Systems for MPI profiling using Buildkite and SLURM","category":"page"},{"location":"diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"ClimaCoupler.jl utilizes other packages in the CliMA ecosystem to generate and visualize diagnostics, namely ClimaDiagnostics.jl and ClimaAnalysis.jl.","category":"page"},{"location":"diagnostics/#Default-AMIP-diagnostics","page":"Diagnostics","title":"Default AMIP diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"We output a set of default diagnostics for all AMIP runs. These currently include the following fields:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Atmospheric quantiies:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"air temperature at the bottom of the atmosphere (3D)\neastward near-surface wind (3D)\nspecific humidity (3D)\nmass fraction of cloud liquid water (3D)\nnet top-of-atmosphere fluxes (3D)\nprecipitation (2D)\nsurface temperature (2D)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Coupler quantities","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"turbulent energy fluxes (2D)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"These diagnostics are all averaged over a period of time that depends on the length of the overall simulation according to the following rule:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"simulation length >= 90 days: 30-day mean\nsimulation length >= 30 days and < 90 days: 10-day mean\nsimulation length >= 1 day and < 30 days: 1-day mean\nsimulation length < 1 day: 1-hour mean","category":"page"},{"location":"diagnostics/#How-to-add-a-new-diagnostic-variable","page":"Diagnostics","title":"How to add a new diagnostic variable","text":"","category":"section"},{"location":"diagnostics/#Adding-a-diagnostic-for-a-ClimaCoupler-quantity","page":"Diagnostics","title":"Adding a diagnostic for a ClimaCoupler quantity","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For diagnostics that come from coupler fields or that are computed using input from multiple component models, we set up the diagnostics by directly creating ClimaDiagnostics.jl objects.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Specifically, we first create a DiagnosticVariable object containing the variable's name, units, any comments, and the function to compute it. This is then used to create a ScheduledDiagnostic variable, which includes saving and output time information. Once we have created a ScheduledDiagnostic for each variable we're interested in, we collect them in a vector and pass this to our DiagnosticsHandler object.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"An example of this process for the variable F_turb_energy can be found in experiments/ClimaEarth/user_io/coupler_diagnostics.jl.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For more information about this process, please see the ClimaDiagnostics.jl documentation.","category":"page"},{"location":"diagnostics/#Adding-a-diagnostic-for-a-CliMA-component-model-quantity","page":"Diagnostics","title":"Adding a diagnostic for a CliMA component model quantity","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Many of our current diagnostics are values that we access directly from a component model. To add a new diagnostic of this kind, you can add a new method add_diagnostic_variable! extending this function from the component model package's Diagnostics module.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For more information about this function and the form it takes, please see the ClimaDiagnostics.jl documentation.","category":"page"},{"location":"diagnostics/#ClimaAtmos.jl","page":"Diagnostics","title":"ClimaAtmos.jl","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"To add a new diagnostic for the ClimaAtmos.jl atmosphere model, you can add this new method for ClimaAtmos.Diagnostics.add_diagnostic_variable! in components/atmosphere/climaatmos_extra_diags.jl. The existing diagnostics in that file can be used as templates.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For more information about ClimaAtmos diagnostics, and to see the default atmospheric diagnostics, please see that package's documentation.","category":"page"},{"location":"diagnostics/#ClimaLand.jl","page":"Diagnostics","title":"ClimaLand.jl","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"To add a new diagnostic for the ClimaLand.jl bucket model, you can add this new method for ClimaLand.Diagnostics.add_diagnostic_variable! in components/land/climaland_bucket_extra_diags.jl (which doesn't exist at the time of writing).","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For more information about ClimaLand diagnostics, and to see the default land diagnostics, please see that package's documentation.","category":"page"},{"location":"diagnostics/#Visualizing-diagnostics","page":"Diagnostics","title":"Visualizing diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"ClimaCoupler.jl uses ClimaAnalysis.jl to parse and visualize the outputs saved using ClimaDiagnostics.jl.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"For more information about ClimaAnalysis.jl, please see that package's documentation.","category":"page"},{"location":"interfacer/#Interfacer","page":"Interfacer","title":"Interfacer","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"This module contains functions that define the interface for coupling component models, as well as stub objects that contain prescribed fields. Here we explain each type of component model, and the functions that must be implemented to use a component model with ClimaCoupler.jl","category":"page"},{"location":"interfacer/#Coupled-simulation","page":"Interfacer","title":"Coupled simulation","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A CoupledSimulation stores info for ESM run and contains each of the component model simulations. We currently require that each CoupledSimulation contains four components: atmos_sim, land_sim, ocean_sim and ice_sim. If a simulation surface type is not needed for a given run, it should be initialized with SurfaceStub with a zero area_fracion. The atmos_sim should always be specified.","category":"page"},{"location":"interfacer/#Component-simulations","page":"Interfacer","title":"Component simulations","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Individual component model simulations fall under ComponentModelSimulation, which together combine to make the CoupledSimulation. We have two types of ComponentModelSimulations: AtmosModelSimulation and SurfaceModelSimulation. The two have different requirements, which are detailed below. SurfaceModelSimulation is further divided into SeaIceModelSimulation, LandModelSimulation, and OceanModelSimulation, representing the 3 currently-supported options for surface models.","category":"page"},{"location":"interfacer/#ComponentModelSimulation-required-functions","page":"Interfacer","title":"ComponentModelSimulation - required functions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A component model simulation should be implemented as a struct that is a concrete subtype of a ComponentModelSimulation. This struct should contain all of the information needed to run that simulation.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Each ComponentModelSimulation must extend the following functions to be able to use our coupler. For some existing models, these are defined within ClimaCoupler.jl in that model’s file in experiments/ClimaEarth/components/, but it is preferable for these to be defined in a model’s own repository. Note that the dispatch ::ComponentModelSimulation in the function definitions given below should be replaced with the particular component model extending these functions.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"init: construct and return an instance of the ComponentModelSimulation,","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"and perform all initialization. This function should return a simulation that is ready to be stepped in the coupled simulation. The interface for this function varies across component models.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"name(::ComponentModelSimulation): return a string containing the name of","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"this ComponentModelSimulation, which is used for printing information about component models and writing to checkpoint files.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"step!(::ComponentModelSimulation, t): A function to update the","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"simulation in-place with values calculate for time t. For the models we currently have implemented, this is a simple wrapper around the step! function implemented in SciMLBase.jl.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"reinit!(::ComponentModelSimulation): A function to restart a simulation","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"after solving of the simulation has been paused or interrupted. Like step!, this is currently a simple wrapper around the reinit! function of SciMLBase.jl.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_model_prog_state(::ComponentModelSimulation): A function that","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"returns the state vector of the simulation at its current state. This is used for checkpointing the simulation.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"add_coupler_fields!(coupler_field_names::Set, ::ComponentModelSimulation):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A function that adds names of quantities the coupler must exchange to support this component model. These will be added for each model in addition to the existing defaults: z0m_sfc, z0b_sfc, beta, F_turb_energy, F_turb_moisture, F_turb_ρτxz, F_turb_ρτyz, temp1, and temp2.","category":"page"},{"location":"interfacer/#ComponentModelSimulation-optional-functions","page":"Interfacer","title":"ComponentModelSimulation - optional functions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"update_sim!(::ComponentModelSimulation, csf, turbulent_fluxes): A","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"function to update each of the fields of the component model simulation that are updated by the coupler. ClimaCoupler.jl provides defaults of this function for both AtmosModelSimulation and SurfaceModelSimulation that update each of the fields expected by the coupler. This function can optionally be extended to include additional field updates as desired.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(::ComponentModelSimulation, ::Val{property}):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Default get_field functions are provided for energy and water fields, described in the table below. These quantities are used to track conservation, and the defaults return nothing. To check conservation throughout a simulation, these functions must be extended for all models being run.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units Default value\nenergy globally integrated energy J nothing\nwater globally integrated water kg nothing","category":"page"},{"location":"interfacer/#AtmosModelSimulation-required-functions","page":"Interfacer","title":"AtmosModelSimulation - required functions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"In addition to the functions required for a general ComponentModelSimulation, an AtmosModelSimulation requires the following functions to retrieve and update its fields.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(::AtmosModelSimulation. ::Val{property}): This getter","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"function returns the value of the field property for the simulation in its current state. For an AtmosModelSimulation, it must be extended for the following properties:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\nair_density air density of the atmosphere kg m^-3\nheight_int height at the first internal model level m\nheight_sfc height at the surface (only required when using PartitionedStateFluxes) m\nliquid_precipitation liquid precipitation at the surface kg m^-2 s^-1\nradiative_energy_flux_sfc net radiative flux at the surface W m^-2\nradiative_energy_flux_toa net radiative flux at the top of the atmosphere W m^-2\nsnow_precipitation snow precipitation at the surface kg m^-2 s^-1\nturbulent_energy_flux aerodynamic turbulent surface fluxes of energy (sensible and latent heat) W m^-2\nturbulent_moisture_flux aerodynamic turbulent surface fluxes of energy (evaporation) kg m^-2 s^-1\nthermo_state_int thermodynamic state at the first internal model level \nuv_int horizontal wind velocity vector at the first internal model level m s^-1","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"update_field!(::AtmosModelSimulation. ::Val{property}, field):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A function to update the value of property in the component model simulation, using the values in field. This update should be done in place. If this function isn't extended for a property, that property will remain constant throughout the simulation and a warning will be raised. This function is expected to be extended for the following properties, and may also be extended for any additional properties needed by a component model.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\nemissivity surface emissivity \nsurface_direct_albedo bulk direct surface albedo over the whole surface space \nsurface_diffuse_albedo bulk diffuse surface albedo over the whole surface space \nsurface_temperature temperature over the combined surface space K\nturbulent_fluxes turbulent fluxes (note: only required when using PartitionedStateFluxes option - see our FluxCalculator module docs for more information) W m^-2","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"calculate_surface_air_density(atmos_sim::Interfacer.AtmosModelSimulation, T_sfc::ClimaCore.Fields.Field):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A function to return the air density of the atmosphere simulation extrapolated to the surface, with units of [kg m^-3].","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"<!– replace  \"full ClimaLand model\" with name of coupler sim struct–>","category":"page"},{"location":"interfacer/#AtmosModelSimulation-required-functions-to-run-with-the-full-ClimaLand-model","page":"Interfacer","title":"AtmosModelSimulation - required functions to run with the full ClimaLand model","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupling with full ClimaLand model requires the following functions, in addition to the functions required for coupling with a general SurfaceModelSimulation.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(::AtmosModelSimulation. ::Val{property}):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"This getter function must be extended for the following properties:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\nair_pressure air pressure at the bottom cell centers of the atmosphere Pa\nair_temperature air temperature at the bottom cell centers of the atmosphere K\ncos_zenith cosine of the zenith angle \nco2 global mean co2 ppm\ndiffuse_fraction fraction of downwards shortwave flux that is direct \nspecific_humidity specific humidity at the bottom cell centers of the atmosphere kg kg^-1\nLW_d downwards longwave flux W m^-2\nSW_d downwards shortwave flux W m^-2","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Note that air_temperature, air_pressure, cos_zenith, co2, diffuse_fraction, LW_d and SW_d will not be present in a ClimaAtmosSimulation if the model is setup with no radiation. Because of this, a ClimaAtmosSimulation must have radiation if running with the full ClimaLand model.","category":"page"},{"location":"interfacer/#SurfaceModelSimulation-required-functions","page":"Interfacer","title":"SurfaceModelSimulation - required functions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Analogously to the AtmosModelSimulation, a SurfaceModelSimulation requires additional functions to those required for a general ComponentModelSimulation.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(::SurfaceModelSimulation, ::Val{property}): This getter","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"function returns the value of the field property for the simulation at the current time. For a SurfaceModelSimulation, it must be extended for the following properties:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\narea_fraction fraction of the simulation grid surface area this model covers \nroughness_buoyancy aerodynamic roughness length for buoyancy m\nroughness_momentum aerodynamic roughness length for momentum m\nsurface_direct albedo bulk direct surface albedo \nsurface_diffuse albedo bulk diffuse surface albedo \nsurface_humidity surface humidity kg kg^-1\nsurface_temperature surface temperature K","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"update_field!(::SurfaceModelSimulation, ::Val{property}, field):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"A function to update the value of property in the component model simulation, using the values in field passed from the coupler This update should be done in place. If this function isn't extended for a property, that property will remain constant throughout the simulation and a warning will be raised. This function is expected to be extended for the following properties, and may also be extended for any additional properties needed by a component model.","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units\nair_density surface air density kg m^-3\narea_fraction fraction of the simulation grid surface area this model covers \nliquid_precipitation liquid precipitation at the surface kg m^-2 s^-1\nradiative_energy_flux_sfc net radiative flux at the surface W m^-2\nsnow_precipitation snow precipitation at the surface kg m^-2 s^-1\nturbulent_energy_flux aerodynamic turbulent surface fluxes of energy (sensible and latent heat); only required when using CombinedStateFluxes option - see our FluxCalculator module docs for more information W m^-2\nturbulent_moisture_flux aerodynamic turbulent surface fluxes of energy (evaporation); only required when using CombinedStateFluxes option - see our FluxCalculator module docs for more information kg m^-2 s^-1\nsurface_direct_albedo bulk direct surface albedo; needed if calculated externally of the surface model (e.g. ocean albedo from the atmospheric state) \nsurface_diffuse_albedo bulk diffuse surface albedo; needed if calculated externally of the surface model (e.g. ocean albedo from the atmospheric state) ","category":"page"},{"location":"interfacer/#SurfaceModelSimulation-optional-functions","page":"Interfacer","title":"SurfaceModelSimulation - optional functions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(::SurfaceModelSimulation, ::Val{property}):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"For some quantities, default get_field functions are provided, which may be overwritten or used as-is. These currently include the following:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"Coupler name Description Units Default value\nbeta factor that scales evaporation based on its estimated level of saturation  1\nemissivity measure of how much energy a surface radiates  1\nheight_disp displacement height relative to the surface m 0","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"update_turbulent_fluxes!(::ComponentModelSimulation, fields::NamedTuple):","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"This function updates the turbulent fluxes of the component model simulation at this point in horizontal space. The values are updated using the energy and moisture turbulent fluxes stored in fields which are calculated by the coupler. Note that this function is only required when using the PartitionedStateFluxes option of ClimaCoupler.jl. See our FluxCalculator module docs for more information.","category":"page"},{"location":"interfacer/#Prescribed-surface-conditions-SurfaceStub","page":"Interfacer","title":"Prescribed surface conditions - SurfaceStub","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"SurfaceStub is a SurfaceModelSimulation, but it only contains","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"required data in <surface_stub>.cache, e.g., for the calculation of surface fluxes through a prescribed surface state. The above adapter functions are already predefined for AbstractSurfaceStub, which is extended by SurfaceStub in the surface_stub.jl file, with the cache variables specified as:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(sim::AbstractSurfaceStub, ::Val{:area_fraction}) = sim.cache.area_fraction\nget_field(sim::AbstractSurfaceStub, ::Val{:beta}) = sim.cache.beta\nget_field(sim::AbstractSurfaceStub, ::Val{:roughness_buoyancy}) = sim.cache.z0b\nget_field(sim::AbstractSurfaceStub, ::Val{:roughness_momentum}) = sim.cache.z0m\nget_field(sim::AbstractSurfaceStub, ::Union{Val{:surface_direct_albedo}, Val{:surface_diffuse_albedo}}) = sim.cache.α\nget_field(sim::AbstractSurfaceStub, ::Val{:surface_humidity}) = TD.q_vap_saturation_generic.(sim.cache.thermo_params, sim.cache.T_sfc, sim.cache.ρ_sfc, sim.cache.phase)\nget_field(sim::AbstractSurfaceStub, ::Val{:surface_temperature}) = sim.cache.T_sfc","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"and with the corresponding update_field! functions","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"function update_field!(sim::AbstractSurfaceStub, ::Val{:air_density}, field)\n    sim.cache.ρ_sfc .= field\nend\nfunction update_field!(sim::AbstractSurfaceStub, ::Val{:area_fraction}, field::ClimaCore.Fields.Field)\n    sim.cache.area_fraction .= field\nend\nfunction update_field!(sim::AbstractSurfaceStub, ::Val{:surface_temperature}, field::ClimaCore.Fields.Field)\n    sim.cache.T_sfc .= field\nend","category":"page"},{"location":"interfacer/#Interfacer-API","page":"Interfacer","title":"Interfacer API","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"    ClimaCoupler.Interfacer.CoupledSimulation\n    ClimaCoupler.Interfacer.AtmosModelSimulation\n    ClimaCoupler.Interfacer.SurfaceModelSimulation\n    ClimaCoupler.Interfacer.ComponentModelSimulation\n    ClimaCoupler.Interfacer.AbstractSurfaceStub\n    ClimaCoupler.Interfacer.SurfaceStub\n    ClimaCoupler.Interfacer.float_type\n    ClimaCoupler.Interfacer.name\n    ClimaCoupler.Interfacer.get_field\n    ClimaCoupler.Interfacer.update_field!\n    ClimaCoupler.Interfacer.AbstractSlabplanetSimulationMode\n    ClimaCoupler.Interfacer.AMIPMode\n    ClimaCoupler.Interfacer.SlabplanetMode\n    ClimaCoupler.Interfacer.SlabplanetAquaMode\n    ClimaCoupler.Interfacer.SlabplanetTerraMode\n    ClimaCoupler.Interfacer.SlabplanetEisenmanMode","category":"page"},{"location":"interfacer/#ClimaCoupler.Interfacer.CoupledSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.CoupledSimulation","text":"CoupledSimulation\n\nStores information needed to run a simulation with the coupler.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AtmosModelSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.AtmosModelSimulation","text":"AtmosModelSimulation\n\nAn abstract type for an atmospheric model simulation.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SurfaceModelSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.SurfaceModelSimulation","text":"SurfaceModelSimulation\n\nAn abstract type for surface model simulations.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.ComponentModelSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.ComponentModelSimulation","text":"ComponentModelSimulation\n\nAn abstract type encompassing all component model (and model stub) simulations.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractSurfaceStub","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractSurfaceStub","text":"AbstractSurfaceStub\n\nAn abstract type representing a simple stand-in surface model. Any concrete type extending this abstract type should have a cache field that contains the necessary fields for the simulation, at minimum the following:     - T_sfc (surface temperature [K])     - ρ_sfc (surface air density [kg / m3])     - z0m (roughness length for momentum [m])     - z0b (roughness length for tracers [m])     - beta (evaporation scaling factor)     - α_direct (direct albedo)     - α_diffuse (diffuse albedo)     - area_fraction (fraction of the grid cell covered by the ocean)     - phase (phase of the water used to calculate surface humidity)     - thermo_params (thermodynamic parameters)\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SurfaceStub","page":"Interfacer","title":"ClimaCoupler.Interfacer.SurfaceStub","text":"SurfaceStub\n\nOn object containing simulation-like info, used as a stub or for prescribed data.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.float_type","page":"Interfacer","title":"ClimaCoupler.Interfacer.float_type","text":"float_type(::CoupledSimulation)\n\nReturn the floating point type backing T: T can either be an object or a type.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.name","page":"Interfacer","title":"ClimaCoupler.Interfacer.name","text":"name(::ComponentModelSimulation)\n\nReturns simulation name, if defined, or Unnamed if not.\n\n\n\n\n\nname(::ComponentModelSimulation)\n\nReturns simulation name, if defined, or Unnamed if not.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.get_field","page":"Interfacer","title":"ClimaCoupler.Interfacer.get_field","text":"get_field(sim::AtmosModelSimulation, val::Val)\n\nA getter function that should not allocate. Here we implement a default that will raise an error if get_field isn't defined for all required fields of an atmosphere component model.\n\n\n\n\n\nget_field(sim::SurfaceModelSimulation, val::Val)\n\nA getter function that should not allocate. Here we implement a default that will raise an error if get_field isn't defined for all required fields of a surface component model.\n\n\n\n\n\nget_field(sim::ComponentModelSimulation, val::Val)\n\nGeneric fallback for get_field that raises an error.\n\n\n\n\n\nget_field(::AbstractSurfaceStub, ::Val)\n\nA getter function, that should not allocate. If undefined, it returns a descriptive error.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.update_field!","page":"Interfacer","title":"ClimaCoupler.Interfacer.update_field!","text":"update_field!(::AtmosModelSimulation, ::Val, _...)\n\nDefault functions for updating fields at each timestep in an atmosphere component model simulation. This should be extended by component models. If it isn't extended, the field won't be updated and a warning will be raised.\n\n\n\n\n\nupdate_field!(::SurfaceModelSimulation, ::Val, _...)\n\nDefault functions for updating fields at each timestep in an atmosphere component model simulation. This should be extended by component models. If it isn't extended, the field won't be updated and a warning will be raised.\n\n\n\n\n\nupdate_field!(sim::AbstractSurfaceStub, ::Val{:area_fraction}, field::CC.Fields.Field)\n\nUpdates the specified value in the cache of SurfaceStub.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractSlabplanetSimulationMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractSlabplanetSimulationMode","text":"AbstractSlabplanetSimulationMode\n\nAn abstract type representing a simulation mode for slabplanet models. Slabplanet simulations are more idealized than the AMIP configuration, but provide valuable insight about conservation and individual model behavior.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AMIPMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.AMIPMode","text":"AMIPMode\n\nAn abstract type representing the AMIP simulation mode. AMIP is currently the most complex configuration of the ClimaEarth model. It runs a ClimaAtmos.jl atmosphere model, ClimaLand.jl bucket land model, a prescribed ocean model, and a simple thermal sea ice model.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SlabplanetMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.SlabplanetMode","text":"SlabplanetMode\n\nAn abstract type represeting the slabplanet simulation mode with a ClimaAtmos.jl atmosphere model, a ClimaLand.jl bucket land model, a thermal slab ocean model, and no sea ice model. Instead of using a sea ice model, the ocean is evaluated in areas that would be covered in ice.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SlabplanetAquaMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.SlabplanetAquaMode","text":"SlabplanetAquaMode\n\nAn abstract type representing the slabplanet simulation mode with a ClimaAtmos.jl atmosphere model, and only once surface model, a thermal slab ocean model, which is evaluated over the entire surface. There are no land or sea ice models.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SlabplanetTerraMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.SlabplanetTerraMode","text":"SlabplanetTerraMode\n\nAn abstract type representing the slabplanet simulation mode with a ClimaAtmos.jl atmosphere model, and only once surface model, a ClimaLand.jl bucket land model, which is evaluated over the entire surface. There are no ocean or sea ice models.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SlabplanetEisenmanMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.SlabplanetEisenmanMode","text":"SlabplanetEisenmanMode\n\nAn abstract type representing the slabplanet simulation mode with a ClimaAtmos.jl atmosphere model, a ClimaLand.jl bucket land model, and Eisenman sea ice model. The ocean model is included in the Eisenman sea ice model.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#Interfacer-Internal-Functions-and-Types","page":"Interfacer","title":"Interfacer Internal Functions and Types","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"    ClimaCoupler.Interfacer.AbstractSimulation\n    ClimaCoupler.Interfacer.AbstractSimulationMode","category":"page"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractSimulation","text":"AbstractSimulation\n\nAn abstract super-type representing a simulation.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AbstractSimulationMode","page":"Interfacer","title":"ClimaCoupler.Interfacer.AbstractSimulationMode","text":"AbstractSimulationMode\n\nAn abstract type representing a simulation mode.\n\n\n\n\n\n","category":"type"},{"location":"generated/sea_breeze/run/#Coupled-Sea-Breeze","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"","category":"section"},{"location":"generated/sea_breeze/run/#Overview","page":"Coupled Sea Breeze","title":"Overview","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"This sea breeze simulation consists of an atmosphere above ocean and land thermal slabs. The difference in heating between the land and ocean components drives circulation: cool ocean air flows towards the land at the surface while warm air over land rises and flows over the ocean.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"In this tutorial we demonstrate the coupling of three component models (atmosphere, ocean, and land) to drive the sea breeze. The primary parts of the ClimaCoupler interface are used and discussed.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Load utilities for running coupled simulation","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"include(\"../CoupledSims/coupled_sim.jl\")\n\n\n\n\n","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Set random seed for reproducibility, rand is called in initseabreeze2d in atmosrhs","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Random.seed!(1234)","category":"page"},{"location":"generated/sea_breeze/run/#Model-Initialization","page":"Coupled Sea Breeze","title":"Model Initialization","text":"","category":"section"},{"location":"generated/sea_breeze/run/#Component-Models","page":"Coupled Sea Breeze","title":"Component Models","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Component models are the building blocks of coupled models. They are often developed independently from one another and can be executed by themselves as \"standalone\" simulations. The coupler is used to combine these components into coupled simulations. Importantly, coupled simulations can re-use tendency methods developed for standalone simulations, maximizing code reuse and minimizing the necessary code that must be specialized for a coupled run–only special boundary conditions must be written. This is achieved by multiple dispatch, where methods that deal with boundaries dispatch off of a coupled boundary type. Here, the atmosphere has special boundary conditions for coupling while the ocean and land tendencies are unaltered. See the atmospheric model page for more details.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"In a more mature CliMA ecosystem, the following include statements would be replaced by using statements for the relevant component packages.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"include(\"atmos_rhs.jl\")\ninclude(\"ocean_rhs.jl\")\ninclude(\"land_rhs.jl\")\n\n# model parameters\nconst atm_T_ini = FT(270.0)\nconst MSLP = FT(1e5)\nconst grav = FT(9.8)\nconst R_d = FT(287.058)\nconst γ = FT(1.4)\nconst C_p = FT(R_d * γ / (γ - 1))\nconst C_v = FT(R_d / (γ - 1))\nconst R_m = R_d\ncpl_parameters = (\n    # atmos parameters\n    atm_μ = FT(0.0001), # diffusion coefficient\n    atm_T_top = FT(280.0), # fixed temperature at the top of the domain_atm\n    atm_T_ini = atm_T_ini, # initial condition of at temperature (isothermal) [K]\n    MSLP = MSLP, # mean sea level pressure\n    grav = grav, # gravitational constant\n    R_d = R_d, # R dry (gas constant / mol mass dry air)\n    γ = γ, # heat capacity ratio\n    C_p = C_p, # heat capacity at constant pressure\n    C_v = C_v, # heat capacity at constant volume\n    R_m = R_m, # moist R, assumed to be dry\n    # land slab parameters\n    lnd_h = FT(0.5), # depth of slab layer [m]\n    lnd_ρ = FT(1500), # density [kg m^-3]\n    lnd_c = FT(800), # specific heat [J K^-1 kg^-1]\n    lnd_T_ini = FT(260.0), # initial condition of at temperature (isothermal) [K]\n    # ocean slab parameters\n    ocn_h = FT(0.5), # depth of slab layer [m]\n    ocn_ρ = FT(1025), # density [kg m^-3]\n    ocn_c = FT(3850), # specific heat [J K^-1 kg^-1]\n    ocn_T_ini = FT(260.0), # initial condition of at temperature (isothermal) [K]\n    # coupling parameters\n    C_H = FT(0.0015),\n)\n\n# DSS callback\nfunction make_dss_func()\n    function _dss!(x::CC.Fields.Field)\n        CC.Spaces.weighted_dss!(x)\n    end\n    function _dss!(::Any)\n        nothing\n    end\n    dss_func(Y, t, integrator) = foreach(_dss!, CC.Fields._values(Y))\n    return dss_func\nend\ndss_func = make_dss_func()\ndss_callback = DiffEqCallbacks.FunctionCallingCallback(dss_func, func_start = true)","category":"page"},{"location":"generated/sea_breeze/run/#Initialization","page":"Coupled Sea Breeze","title":"Initialization","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"The coupled simulation synchronizes the component models at a coupling time step, Δt_cpl. Within that step, components may substep - each component specifies a number of substeps to take within Δt_cpl: atm_nsteps, ocn_nsteps, lnd_nsteps.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Component model states are initialized via the initialization methods each component would use in standalone mode. These states will be modified to reflect the full coupled system before executing the simulation.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"@info \"Init Models and Maps\"\n\nt_start, t_end = (0.0, 1e4)\nΔt_coupled = 0.1\nsaveat = collect(t_start:10.0:t_end)\natm_nsteps, ocn_nsteps, lnd_nsteps = (5, 1, 1)\n\n# Initialize Models\natm_Y_default, atm_bc, atm_domain = atm_init(\n    xmin = -500,\n    xmax = 500,\n    zmin = 0,\n    zmax = 1000,\n    npoly = 4,\n    helem = 20,\n    velem = 20,\n    bc = (ρθ = (bottom = CoupledFlux(), top = ZeroFlux()),),\n)\n\nocn_Y_default, ocn_domain = ocn_init(xmin = -500, xmax = 0, helem = 10, npoly = 0)\n\nlnd_Y_default, lnd_domain = lnd_init(xmin = 0, xmax = 500, helem = 10, npoly = 0)","category":"page"},{"location":"generated/sea_breeze/run/#Remapping","page":"Coupled Sea Breeze","title":"Remapping","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Because models may live on different grids, remapping is necessary at the boundaries. Maps between coupled components must be constructed for each interacting pair. Remapping utilities are imported from ClimaCore.Operators.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"atm_boundary = CC.Spaces.level(atm_domain.hv_face_space, CC.Utilities.PlusHalf(0))\n\nmaps = (\n    atmos_to_ocean = CC.Operators.LinearRemap(ocn_domain, atm_boundary),\n    atmos_to_land = CC.Operators.LinearRemap(lnd_domain, atm_boundary),\n    ocean_to_atmos = CC.Operators.LinearRemap(atm_boundary, ocn_domain),\n    land_to_atmos = CC.Operators.LinearRemap(atm_boundary, lnd_domain),\n)\n\n# initialize coupling fields\natm_T_sfc =\n    CC.Operators.remap(maps.ocean_to_atmos, ocn_Y_default.T_sfc) .+\n    CC.Operators.remap(maps.land_to_atmos, lnd_Y_default.T_sfc) # masked arrays; regrid to atm grid\natm_F_sfc = CC.Fields.zeros(atm_boundary)\nocn_F_sfc = CC.Fields.zeros(ocn_domain)\nlnd_F_sfc = CC.Fields.zeros(lnd_domain)","category":"page"},{"location":"generated/sea_breeze/run/#Simulations","page":"Coupled Sea Breeze","title":"Simulations","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Each component is wrapped as a Sim, which contains both the model (tendency) and the time-stepping information (solver, step size, etc). Sims are the standard structures that the coupler works with, enabling dispatch of coupler methods. Here, we create three simulations: AtmosSim, OceanSim, and LandSim.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"atm_Y = CC.Fields.FieldVector(Yc = atm_Y_default.Yc, ρw = atm_Y_default.ρw, F_sfc = atm_F_sfc)\natm_p = (cpl_p = cpl_parameters, T_sfc = atm_T_sfc, bc = atm_bc)\natmos = AtmosSim(atm_Y, t_start, Δt_coupled / atm_nsteps, t_end, CTS.RK4(), atm_p, saveat, dss_callback)\n\nocn_Y = CC.Fields.FieldVector(T_sfc = ocn_Y_default.T_sfc)\nocn_p = (cpl_parameters, F_sfc = ocn_F_sfc)\nocean = OceanSim(ocn_Y, t_start, Δt_coupled / ocn_nsteps, t_end, CTS.RK4(), ocn_p, saveat)\n\nlnd_Y = CC.Fields.FieldVector(T_sfc = lnd_Y_default.T_sfc)\nlnd_p = (cpl_parameters, F_sfc = lnd_F_sfc)\nland = LandSim(lnd_Y, t_start, Δt_coupled / lnd_nsteps, t_end, CTS.RK4(), lnd_p, saveat)","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Additionally, we create a coupled simulation that contains the component simulations and the coupled time-stepping information.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"struct AOLCoupledSim{A <: AtmosSim, O <: OceanSim, L <: LandSim, C <: CouplerState} <: AbstractCoupledSim\n    # Atmosphere Simulation\n    atmos::A\n    # Ocean Simulation\n    ocean::O\n    # Land Simulation\n    land::L\n    # Coupler storage\n    coupler::C\nend","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"step! is a key method within the Sims interface. It advances a simulation to the specified t_stop, with that simulation advancing by its own internal step size to reach the specified time. Each simulation type should specify its own step method, allowing components to have different time integration backends. Here, all components are using SciMLBase integrators and can share the same step! method.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"function step!(sim::AbstractSim, t_stop)\n    Δt = t_stop - sim.integrator.t\n    SciMLBase.step!(sim.integrator)\nend","category":"page"},{"location":"generated/sea_breeze/run/#The-Coupler","page":"Coupled Sea Breeze","title":"The Coupler","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"The CouplerState is a coupling struct used to store pointers or copies of the shared boundary information. All components are coupled by updating or accessing data in this CouplerState; component models do not directly interface with one another, only through the coupler.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"After creating the CouplerState object, coupled fields can be registered index the coupler via the coupler_add_field! method. This field is then accessible by coupler_get methods and can be updated via the coupler_put! methods.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Similarly, the coupler_add_map! method registers remapping operators in the coupler. To provide automatic remapping, there is a strict name convention for remap operators: a map from SimA to SimB (where ClimaCoupler.name returns :simA and :simB, respectively) must be named simA_to_simB so that the correct operator can be used.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Here, the models are coupled through heat transfer at the surface. This heat flux is computed by a bulk formula:","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"F_sfc = c_p rho_1 C_H u_1 (theta_sfc - theta_atm1)","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"where theta_sfc is the potential temperature at the land or ocean surface, theta_atm1 is the potential temperature at the lowest atmospheric level, c_p is the specific heat, C_H = 00015 is the bulk transfer coefficient for sensible heat, and u_1 is the near-surface atmospheric wind speed. We assume that the potential temperature is defined with respect to the surface pressure, so that theta_sfc = T_sfc.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"coupler = CouplerState(Δt_coupled)\ncoupler_add_field!(coupler, :T_sfc_ocean, ocean.integrator.u.T_sfc; write_sim = ocean)\ncoupler_add_field!(coupler, :T_sfc_land, land.integrator.u.T_sfc; write_sim = land)\ncoupler_add_field!(coupler, :F_sfc, atmos.integrator.u.F_sfc; write_sim = atmos)\nfor (name, map) in pairs(maps)\n    coupler_add_map!(coupler, name, map)\nend\n\nsim = AOLCoupledSim(atmos, ocean, land, coupler)","category":"page"},{"location":"generated/sea_breeze/run/#Coupled-Time-Integration","page":"Coupled Sea Breeze","title":"Coupled Time Integration","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Finally, the execution sequence of the component models must be specified. This is currently done explicitly with a combination of step!, coupler_pull!, and coupler_push! methods. The coupler_pull! and coupler_push! methods receive and send coupled field info from the coupler, respectively. They must be written for each component simulation, and are simply collections of coupler_get and coupler_put! methods for each component.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Here, the atmosphere steps forward first and then sends updated fields to the coupler. The ocean and land (which are not coupled to each other) then retreive the updated coupled information, advance and send their own updates to the coupler.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Because the models exchange fluxes only at the coupled timestep, the surface flux is accumulated over the coupled time-step coupling time step, Δt_cpl","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"F_integ = int_Delta t_coupler F_sfc  dt","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"where  F_integ has units of J m^-2.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"function cpl_run(simulation::AOLCoupledSim)\n    @info \"Run model\"\n    (; atmos, ocean, land, coupler) = simulation\n    Δt_coupled = coupler.Δt_coupled\n    # coupler stepping\n    for t in ((t_start + Δt_coupled):Δt_coupled:t_end)\n        # Atmos\n        coupler_pull!(atmos, coupler)\n        step!(atmos, t)\n        coupler_push!(coupler, atmos)\n\n        # Ocean\n        coupler_pull!(ocean, coupler)\n        step!(ocean, t)\n        coupler_push!(coupler, ocean)\n\n        # Land\n        coupler_pull!(land, coupler)\n        step!(land, t)\n        coupler_push!(coupler, land)\n    end\n    @info \"Simulation Complete\"\nend\n\n# Run simulation\ncpl_run(sim)","category":"page"},{"location":"generated/sea_breeze/run/#References","page":"Coupled Sea Breeze","title":"References","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Antonelli & Rotunno 2007","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"# Post-processing\n","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"JLD2.save(joinpath(path, \"lastsim.jld2\"), \"coupledsim\", sim) #hide","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Plot atmospheric potential temperature [K] throughout the simulation","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"theta_fig = Makie.Figure();\ntheta_ax = Makie.Axis(theta_fig[1, 1])","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"initial plot to setup axis and make consistent levels","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"theta_plot = ClimaCoreMakie.fieldcontourf!(theta_ax, sol.u[end].Yc.ρθ ./ sol.u[end].Yc.ρ)\ntheta_cb = Makie.Colorbar(theta_fig[1, 2], theta_plot)\ntheta_levels = [k for k in range(theta_cb.limits[][1], theta_cb.limits[][2], theta_plot.levels[])]\nMakie.record(theta_fig, joinpath(path, \"theta.mp4\"), 1:length(sol.u); framerate = 20) do i\n    ClimaCoreMakie.fieldcontourf!(theta_ax, sol.u[i].Yc.ρθ ./ sol.u[i].Yc.ρ, levels = theta_levels)\nend\n","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Plot atmospheric vertical velocity [m/s] throughout the simulation","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"vel_w_fig = Makie.Figure();\nvel_w_ax = Makie.Axis(vel_w_fig[1, 1])","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"initial plot to setup axis and make consistent levels","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"vel_w_plot = ClimaCoreMakie.fieldcontourf!(vel_w_ax, If2c.(sol.u[end].ρw) ./ sol.u[end].Yc.ρ)\nvel_w_cb = Makie.Colorbar(vel_w_fig[1, 2], vel_w_plot)\nvel_w_levels = [k for k in range(vel_w_cb.limits[][1], vel_w_cb.limits[][2], vel_w_plot.levels[])]\nMakie.record(vel_w_fig, joinpath(path, \"vel_w.mp4\"), 1:length(sol.u); framerate = 20) do i\n    ClimaCoreMakie.fieldcontourf!(vel_w_ax, If2c.(sol.u[i].ρw) ./ sol.u[i].Yc.ρ, levels = vel_w_levels)\nend","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Plot atmospheric longitudinal velocity [m/s] throughout the simulation","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"vel_u_fig = Makie.Figure();\nvel_u_ax = Makie.Axis(vel_u_fig[1, 1])","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"initial plot to setup axis and make consistent levels","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"vel_u_plot = ClimaCoreMakie.fieldcontourf!(vel_u_ax, sol.u[end].Yc.ρuₕ ./ sol.u[end].Yc.ρ)\nvel_u_cb = Makie.Colorbar(vel_u_fig[1, 2], vel_u_plot)\nvel_u_levels = [k for k in range(vel_u_cb.limits[][1], vel_u_cb.limits[][2], vel_u_plot.levels[])]\nMakie.record(vel_u_fig, joinpath(path, \"vel_u.mp4\"), 1:length(sol.u); framerate = 20) do i\n    ClimaCoreMakie.fieldcontourf!(vel_u_ax, sol.u[i].Yc.ρuₕ ./ sol.u[i].Yc.ρ, levels = vel_u_levels)\nend","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"This page was generated using Literate.jl.","category":"page"},{"location":"leaderboard/#Leaderboard","page":"Leaderboard","title":"Leaderboard","text":"","category":"section"},{"location":"leaderboard/#AMIP-Driver","page":"Leaderboard","title":"AMIP Driver","text":"","category":"section"},{"location":"leaderboard/#Add-a-new-variable-to-compare-against-observations","page":"Leaderboard","title":"Add a new variable to compare against observations","text":"","category":"section"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"Computing errors against observations are all contained in the leaderboard folder. The files in the leaderboard folder are data_sources.jl and leaderboard.jl. Loading and preprocessing variables of interest are done in data_sources.jl and computing the errors and plotting are done in leaderboard.jl. To add a new variable, you ideally only need to modify data_sources.jl.","category":"page"},{"location":"leaderboard/#Add-a-new-3D-variable-to-the-bias-plots","page":"Leaderboard","title":"Add a new 3D variable to the bias plots","text":"","category":"section"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"If you want to add a new 3D variable defined over latitude, longitude, and time to the bias plots, you add the variable to sim_var_dict, obs_var_dict, compare_vars_biases_groups, and optionally compare_vars_biases_plot_extrema. The variables sim_var_dict, obs_var_dict, compare_vars_biases_groups, compare_vars_biases_plot_extrema are in the function get_sim_var_dict, get_obs_var_dict, get_compare_vars_biases_groups, and get_compare_vars_biases_plot_extrema respectively.","category":"page"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"The dictionaries sim_var_dict and obs_var_dict map short names to an anonymous function that returns a OutputVar. Both dictionaries must use the same short names as the keys so that the right simulation and observational data are compared.","category":"page"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"tip: Preprocessing\nObservational and simulational data should be preprocessed for dates and units. For simulation data, monthly averages correspond to the first day following the month. For instance, the monthly average corresponding to January 2010 is on the date 2/1/2010. Preprocessing is done to shift this date to 1/1/2010. When preprocessing data, we follow the convention that the first day corresponds to the monthly average for that month. For observational data, you should check the convention being followed and preprocess the dates if necessary.For obs_var_dict, the anonymous function must take in a start date. The start date is used in leaderboard.jl to adjust the seconds in the OutputVar to match between start date in the simulation data.Units should be the same between the simulation and observational data.","category":"page"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"The variable compare_vars_biases_groups is an array of arrays of short names that control which variables are plotted together. You can add the variable to an existing array or make a new array. The dictionary compare_vars_biases_plot_extrema maps short names to tuples. The dictionary sets the lower and upper bounds of the bias plots.","category":"page"},{"location":"leaderboard/#Add-a-new-variable-to-the-leaderboard","page":"Leaderboard","title":"Add a new variable to the leaderboard","text":"","category":"section"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"If you want to add a new variable to the leaderboard, you add the variable to rmse_var_names and rmse_var_dict. The array rmse_var_names is a list of short names. The dictionary rmse_var_dict maps short name to RMSEVariable. A RMSEVariable must be initialized for each variable of interest. The CliMA model is added with units to the RMSEVariable. It is assumed that the RMSEVariable contains only the columns \"DJF\", \"MAM\", \"JJA\", \"SON\", and \"ANN\" in that order. The file leaderboard.jl will load the appropriate data into the RMSEVariable.","category":"page"},{"location":"leaderboard/#Add-a-new-variable-to-compare-against-observations-in-pressure-coordinates","page":"Leaderboard","title":"Add a new variable to compare against observations in pressure coordinates","text":"","category":"section"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"To add a new variable, you only need to modify the variable sim_var_pfull_dict in the function get_sim_var_in_pfull_dict, the variable obs_var_dict in the function get_obs_var_in_pfull_dict, and the variable compare_vars_biases_plot_extrema in the function get_compare_vars_biases_plot_extrema_pfull. The variables and functions are defined exactly the same as their analogous versions in the section above.","category":"page"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"It is expected that the dimensions of the variables are time, latitude, longitude, and pressure in no particular order and the units for the pressure dimension is expected to be hPa.","category":"page"},{"location":"fluxcalculator/#FluxCalculator","page":"FluxCalculator","title":"FluxCalculator","text":"","category":"section"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"This modules contains abstract types and functions to calculate surface fluxes in the coupler, or to call flux calculating functions from the component models.","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"Fluxes over a heterogeneous surface (e.g., from a gridpoint where atmospheric cell is overlying both land and ocean) can be handled in two different ways:","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"Combined fluxes (called with CombinedStateFluxesMOST())","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"these are calculated by averaging the surface properties for each gridpoint (e.g., land and ocean temperatures, albedos and roughness lengths are averaged, based on their respective area fractions), so the flux is calculated only once per gridpoint of the grid where we calculate fluxes. This is computationally faster, but it makes the fluxes on surface boundaries more diffuse. Currently, we use this method for calculating radiative fluxes in the atmosphere, and turbulent fluxes in the coupler (on the atmospheric grid). The fluxes are calculated in the atmospheric (host) model's cache, which can be setup to avoid allocating coupler fields.","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"Partitioned fluxes (called with PartitionedStateFluxes())","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"these are calculated separately for each surface type. It is then the fluxes (rather than the surface states) that are combined and passed to the atmospheric model as a boundary condition. This method ensures that each surface model receives fluxes that correspond to its state properties, resulting in a more accurate model evolution. However, it is more computationally expensive, and requires more communication between the component models.","category":"page"},{"location":"fluxcalculator/#FluxCalculator-API","page":"FluxCalculator","title":"FluxCalculator API","text":"","category":"section"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"    ClimaCoupler.FluxCalculator.TurbulentFluxPartition\n    ClimaCoupler.FluxCalculator.PartitionedStateFluxes\n    ClimaCoupler.FluxCalculator.CombinedStateFluxesMOST\n    ClimaCoupler.FluxCalculator.combined_turbulent_fluxes!\n    ClimaCoupler.FluxCalculator.atmos_turbulent_fluxes_bulk!\n    ClimaCoupler.FluxCalculator.atmos_turbulent_fluxes_most!\n    ClimaCoupler.FluxCalculator.surface_inputs\n    ClimaCoupler.FluxCalculator.calculate_surface_air_density\n    ClimaCoupler.FluxCalculator.get_surface_params\n    ClimaCoupler.FluxCalculator.partitioned_turbulent_fluxes!\n    ClimaCoupler.FluxCalculator.differentiate_turbulent_fluxes!\n    ClimaCoupler.FluxCalculator.get_surface_fluxes!\n    ClimaCoupler.FluxCalculator.update_turbulent_fluxes!\n    ClimaCoupler.FluxCalculator.extrapolate_ρ_to_sfc\n    ClimaCoupler.FluxCalculator.surface_thermo_state\n    ClimaCoupler.FluxCalculator.water_albedo_from_atmosphere!","category":"page"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.TurbulentFluxPartition","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.TurbulentFluxPartition","text":"TurbulentFluxPartition\n\nAbstract type for flags that denote where and how to calculate tubulent fluxes.\n\n\n\n\n\n","category":"type"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.PartitionedStateFluxes","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.PartitionedStateFluxes","text":"PartitionedStateFluxes <: TurbulentFluxPartition\n\nA flag indicating that the turbulent fluxes should be partitioned and calculated over each surface model and then combined. This is calculated on the coupler grid.\n\n\n\n\n\n","category":"type"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.CombinedStateFluxesMOST","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.CombinedStateFluxesMOST","text":"CombinedStateFluxesMOST <: TurbulentFluxPartition\n\nA flag indicating that the turbulent fluxes (e.g. sensible and latent heat fluxes, drag and moisture fluxes) are to be  calculated on the Atmos grid, and saved in Atmos cache.\n\n\n\n\n\n","category":"type"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.combined_turbulent_fluxes!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.combined_turbulent_fluxes!","text":"combined_turbulent_fluxes!(model_sims, csf, turbulent_fluxes::TurbulentFluxPartition)\n\nCalls the method(s) which calculate turbulent surface fluxes from combined surface states in coupler fields, csf.\n\nArguments\n\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\ncsf: [NamedTuple] containing coupler fields.\nturbulent_fluxes: [TurbulentFluxPartition] denotes a flag for turbulent flux calculation.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.atmos_turbulent_fluxes_most!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.atmos_turbulent_fluxes_most!","text":"atmos_turbulent_fluxes_most!(sim::Interfacer.ComponentModelSimulation, csf)\n\nA function to calculate turbulent surface fluxes using the combined surface states and the Monin Obukhov Similarity Theory. It is required that a method is defined for the given sim and that the fluxes are saved in that sim's cache. csf refers to the coupler fields.\n\nArguments\n\nsim: [Interfacer.ComponentModelSimulation] object containing the component model simulation.\ncsf: [NamedTuple] containing coupler fields.\n\nExample:\n\nfunction atmos_turbulent_fluxes_most!(atmos_sim::ClimaAtmosSimulation, csf)\n    atmos_sim.cache.flux .= atmos_sim.c .* (csf.T_sfc .- atmos_sim.temperature)\nend\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.surface_inputs","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.surface_inputs","text":"surface_inputs(scheme::AbstractSurfaceFluxScheme, thermo_state_sfc, thermo_state_int, uₕ_int, z_int, z_sfc, z0b, z0m, Ch, Cd, beta, gustiness)\n\nReturns the inputs for the surface model simulation sim.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.calculate_surface_air_density","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.calculate_surface_air_density","text":"calculate_surface_air_density(atmos_sim::ClimaAtmosSimulation, T_sfc::CC.Fields.Field)\n\nExtension for this  to to calculate surface density.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.get_surface_params","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.get_surface_params","text":"get_surface_params(atmos_sim::Interfacer.AtmosModelSimulation)\n\nReturns the surface parameters of type SF.Parameters.SurfaceFluxesParameters.\n\nTODO: in the future this may not need to depend on the atmos sim, but here retaining the dependency until we know how EDMF boundary conditions will be handled (for consistency of parameters).\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.partitioned_turbulent_fluxes!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.partitioned_turbulent_fluxes!","text":"partitioned_turbulent_fluxes!(model_sims::NamedTuple, fields::CC.Fields.Field, boundary_space::CC.Spaces.AbstractSpace, surface_scheme, thermo_params::TD.Parameters.ThermodynamicsParameters)\n\nThe current setup calculates the aerodynamic fluxes in the coupler (assuming no regridding is needed) using adapter function get_surface_fluxes!, which calls SurfaceFluxes.jl. The coupler saves the area-weighted sums of the fluxes.\n\nArgs:\n\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\nfields: [NamedTuple] containing coupler fields.\nboundary_space: [CC.Spaces.AbstractSpace] the space of the coupler surface.\nsurface_scheme: [AbstractSurfaceFluxScheme] the surface flux scheme.\nthermo_params: [TD.Parameters.ThermodynamicsParameters] the thermodynamic parameters.\n\nTODO:\n\ngeneralize interface for regridding and take land state out of atmos's integrator.p\nadd flux accumulation\nadd flux bounds\n\n(NB: Radiation surface fluxes are calculated by the atmosphere.)\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.differentiate_turbulent_fluxes!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.differentiate_turbulent_fluxes!","text":"differentiate_turbulent_fluxes!(sim::Interfacer.SurfaceModelSimulation, args)\n\nThis function provides a placeholder for differentiating fluxes with respect to surface temperature in surface energy balance calculations.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.get_surface_fluxes!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.get_surface_fluxes!","text":"get_surface_fluxes!(inputs, surface_params::SF.Parameters.SurfaceFluxesParameters)\n\nUses SurfaceFluxes.jl to calculate turbulent surface fluxes. It should be atmos model agnostic, and columnwise.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.update_turbulent_fluxes!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.update_turbulent_fluxes!","text":"update_turbulent_fluxes!(sim::Interfacer.SurfaceModelSimulation, fields::NamedTuple)\n\nUpdates the fluxes in the surface model simulation sim with the fluxes in fields.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.extrapolate_ρ_to_sfc","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.extrapolate_ρ_to_sfc","text":"extrapolate_ρ_to_sfc(thermo_params, ts_int, T_sfc)\n\nUses the ideal gas law and hydrostatic balance to extrapolate for surface density.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.surface_thermo_state","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.surface_thermo_state","text":"surface_thermo_state(sim::Interfacer.SurfaceModelSimulation, thermo_params::TD.Parameters.ThermodynamicsParameters, thermo_state_int)\n\nReturns the surface parameters for the surface model simulation sim. The default is assuming saturated surfaces, unless an extension is defined for the given SurfaceModelSimulation.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.water_albedo_from_atmosphere!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.water_albedo_from_atmosphere!","text":"water_albedo_from_atmosphere!(cs::Interfacer.CoupledSimulation)\n\nCallback to calculate the water albedo from atmospheric state. This is a placeholder for the full radiation callback.\n\n\n\n\n\nwater_albedo_from_atmosphere!(atmos_sim::Interfacer.AtmosModelSimulation, ::CC.Fields.Field, ::CC.Fields.Field)\n\nPlaceholder for the water albedo calculation from the atmosphere. It returns an error if not extended.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#FieldExchanger-Internal-Functions","page":"FluxCalculator","title":"FieldExchanger Internal Functions","text":"","category":"section"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"    ClimaCoupler.FluxCalculator.get_scheme_properties","category":"page"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.get_scheme_properties","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.get_scheme_properties","text":"get_scheme_properties(scheme::AbstractSurfaceFluxScheme, sim::Interfacer.SurfaceModelSimulation)\n\nReturns the scheme-specific properties for the surface model simulation sim.\n\n\n\n\n\n","category":"function"},{"location":"generated/amip/run_amip/#AMIP-Driver","page":"AMIP Driver","title":"AMIP Driver","text":"","category":"section"},{"location":"generated/amip/run_amip/#Overview","page":"AMIP Driver","title":"Overview","text":"","category":"section"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"AMIP is a standard experimental protocol of the Program for Climate Model Diagnosis & Intercomparison (PCMDI). It is used as a model benchmark for the atmospheric and land model components, while sea-surface temperatures (SST) and sea-ice concentration (SIC) are prescribed using time-interpolations between monthly observed data. We use standard data files with original sources:","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"SST and SIC: https://gdex.ucar.edu/dataset/158_asphilli.html\nland-sea mask: https://www.ncl.ucar.edu/Applications/Data/#cdf","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"For more information, see the PCMDI's specifications for AMIP I and AMIP II.","category":"page"},{"location":"generated/amip/run_amip/#Running-the-AMIP-configuration","page":"AMIP Driver","title":"Running the AMIP configuration","text":"","category":"section"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"To run a coupled simulation in the default AMIP configuration, run the following command from the root directory of the repository:","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"julia --project=experiments/ClimaEarth experiments/ClimaEarth/run_amip.jl","category":"page"},{"location":"generated/amip/run_amip/#Configuration","page":"AMIP Driver","title":"Configuration","text":"","category":"section"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"You can also specify a custom configuration file to run the coupled simulation in a different setup. The configuration file should be a TOML file that overwrites the input fields specified in experiments/ClimaEarth/cli_options.jl. A set of example configuration files can be found in the config/ci_configs/ directory.","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"For example, to run the coupled simulation with a different configuration file:","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"julia --project=experiments/ClimaEarth experiments/ClimaEarth/run_amip.jl --config_file=\"path/to/config.toml\"","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"To run the coupled simulation interactively with a different configuration file, set the config_file variable in this script to be the path to that file.","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"For more details about running a coupled simulation, including how to run in a Slabplanet configuration, please see our README.md.","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"Load the necessary modules and code to run the coupled simulation","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"include(\"setup_run.jl\")","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"Get the configuration file from the command line (or manually set it here)","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"config_file = parse_commandline(argparse_settings())[\"config_file\"]","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"Set up and run the coupled simulation","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"cs = setup_and_run(config_file)","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"","category":"page"},{"location":"generated/amip/run_amip/","page":"AMIP Driver","title":"AMIP Driver","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Ocean-Model","page":"Ocean Model","title":"Ocean Model","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"import DiffEqCallbacks\nimport SciMLBase\nimport ClimaCore as CC\nimport ClimaTimeSteppers as CTS","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"Load coupled simulation code","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"include(\"../CoupledSims/coupled_sim.jl\")","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Slab-Ocean-ODE","page":"Ocean Model","title":"Slab Ocean ODE","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"For our ocean component, we solve a simple slab ocean ODE just as we did for the land:","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"rho_o c_o H_o partial_t T_ocn = - F_integ  Delta t_coupler","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"where rho_o = 1025 kg m ^-3, c_o=3850 J K ^-1 kg ^-1, H_o = 100 m are the density, specific heat and depth of the ocean,\nand F_integ is the integrated surface fluxes in time.","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Model-Code","page":"Ocean Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"function ocn_rhs!(du, u, (parameters, F_accumulated), t)\n    \"\"\"\n    Slab layer equation\n        d(T_sfc)/dt = - (F_accumulated) / (h_ocn * ρ_ocn * c_ocn)\n        where\n            F_accumulated = F_integrated / Δt_coupler\n    \"\"\"\n    (; ocn_h, ocn_ρ, ocn_c) = parameters\n    (; T_sfc) = du\n\n    @. T_sfc = (-F_accumulated) / (ocn_h * ocn_ρ * ocn_c)\nend\n\n# set up domain\nfunction hspace_1D(xlim = (-π, π), npoly = 0, helem = 10)\n    FT = Float64\n\n    domain =\n        CC.Domains.IntervalDomain(CC.Geometry.XPoint{FT}(xlim[1]) .. CC.Geometry.XPoint{FT}(xlim[2]), periodic = true)\n    mesh = CC.Meshes.IntervalMesh(domain; nelems = helem)\n    topology = CC.Topologies.IntervalTopology(mesh)\n\n    # Finite Volume Approximation: Gauss-Lobatto with 1pt per element\n    quad = CC.Spaces.Quadratures.GL{npoly + 1}()\n    space = CC.Spaces.SpectralElementSpace1D(topology, quad)\n\n    return space\nend\n\n# init simulation\nfunction ocn_init(; xmin = -1000, xmax = 1000, helem = 20, npoly = 0)\n\n    # construct domain spaces - get only surface layer (NB: z should be zero, not z = first central height)\n    space = hspace_1D((xmin, xmax), npoly, helem)\n    coords = CC.Fields.coordinate_field(space)\n    domain = space\n\n    # initial condition\n    T_sfc = map(coords) do coord\n        T_sfc = 257.0\n    end\n\n    # prognostic variable\n    Y = CC.Fields.FieldVector(T_sfc = T_sfc)\n\n    return Y, domain\nend","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Coupled-Ocean-Wrappers","page":"Ocean Model","title":"Coupled Ocean Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"# Ocean Simulation - Later to live in Oceananigans\nstruct OceanSim <: AbstractOceanSim\n    integrator::Any\nend\n\nfunction OceanSim(Y_init, t_start, dt, t_end, timestepper, p, saveat, callbacks = DiffEqCallbacks.CallbackSet())\n    ode_algo = CTS.ExplicitAlgorithm(timestepper)\n    ode_function = CTS.ClimaODEFunction(T_exp! = ocn_rhs!)\n\n    problem = SciMLBase.ODEProblem(ode_function, Y_init, (t_start, t_end), p)\n    ocn_integ = SciMLBase.init(problem, ode_algo, dt = dt, saveat = saveat, adaptive = false, callback = callbacks)\n\n    return OceanSim(ocn_integ)\nend\n\nfunction coupler_push!(coupler::CouplerState, ocean::OceanSim)\n    coupler_put!(coupler, :T_sfc_ocean, ocean.integrator.u.T_sfc, ocean)\nend\n\nfunction coupler_pull!(ocean::OceanSim, coupler::CouplerState)\n    coupler_get!(ocean.integrator.p.F_sfc, coupler, :F_sfc, ocean)\n    ocean.integrator.p.F_sfc ./= coupler.Δt_coupled\nend","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"conservation/#Conservation-Checks","page":"Conservation Checks","title":"Conservation Checks","text":"","category":"section"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"If the model is a physically closed system (e.g., in the slabplanet configuration with free slip conditions), it should conserve mass (including water), energy and momentum. The conservation checker logs global conservation.","category":"page"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"Only energy and water are currently implemented.","category":"page"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"Note that kinetic energy is not included in the calculation of the global energy, reflecting the formulation on ClimaAtmos, which assumes that kinetic energy is negligible in comparison with the moist static energy components.","category":"page"},{"location":"conservation/#ConservationChecker-API","page":"Conservation Checks","title":"ConservationChecker API","text":"","category":"section"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"ClimaCoupler.ConservationChecker.EnergyConservationCheck\nClimaCoupler.ConservationChecker.WaterConservationCheck\nClimaCoupler.ConservationChecker.check_conservation!","category":"page"},{"location":"conservation/#ClimaCoupler.ConservationChecker.EnergyConservationCheck","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.EnergyConservationCheck","text":"EnergyConservationCheck{A} <: AbstractConservationCheck\n\nStruct of type AbstractConservationCheck containing global energy conservation logs.\n\n\n\n\n\n","category":"type"},{"location":"conservation/#ClimaCoupler.ConservationChecker.WaterConservationCheck","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.WaterConservationCheck","text":"WaterConservationCheck{A} <: AbstractConservationCheck\n\nStruct of type AbstractConservationCheck containing global water mass conservation logs.\n\n\n\n\n\n","category":"type"},{"location":"conservation/#ClimaCoupler.ConservationChecker.check_conservation!","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.check_conservation!","text":"check_conservation!(coupler_sim::Interfacer.CoupledSimulation; runtime_check = false)\n\nitertes over all specified conservation checks.\n\n\n\n\n\n    check_conservation!(\n    cc::EnergyConservationCheck,\n    coupler_sim::Interfacer.CoupledSimulation,\n    runtime_check = false,\n    )\n\ncomputes the total energy, ∫ ρe dV, of the model components of the coupled simulations and the TOA radiation, and updates cc with these values.\n\n\n\n\n\ncheck_conservation!(\ncc::WaterConservationCheck,\ncoupler_sim::Interfacer.CoupledSimulation,\nruntime_check = false,\n)\n\ncomputes the total water, ∫ ρq_tot dV, of the various components of the coupled simulations, and updates cc with the values.\n\nNote: in the future this should not use push!.\n\n\n\n\n\n","category":"function"},{"location":"conservation/#ConservationChecker-Internal-Functions","page":"Conservation Checks","title":"ConservationChecker Internal Functions","text":"","category":"section"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"ClimaCoupler.ConservationChecker.surface_water_gain_from_rates","category":"page"},{"location":"conservation/#ClimaCoupler.ConservationChecker.surface_water_gain_from_rates","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.surface_water_gain_from_rates","text":"surface_water_gain_from_rates(cs::Interfacer.CoupledSimulation)\n\nDetermines the total water content gain/loss of a surface from the begining of the simulation based on evaporation and precipitation rates.\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#TimeManager","page":"TimeManager","title":"TimeManager","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"This module contains functions that handle dates and times in simulations. The functions in this module often call functions from Julia's Dates module.","category":"page"},{"location":"timemanager/#TimeManager-API","page":"TimeManager","title":"TimeManager API","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"ClimaCoupler.TimeManager.current_date\nClimaCoupler.TimeManager.strdate_to_datetime\nClimaCoupler.TimeManager.datetime_to_strdate\nClimaCoupler.TimeManager.maybe_trigger_callback","category":"page"},{"location":"timemanager/#ClimaCoupler.TimeManager.current_date","page":"TimeManager","title":"ClimaCoupler.TimeManager.current_date","text":"current_date(cs::Interfacer.CoupledSimulation, t::Int)\n\nReturn the model date at the current timestep.\n\nArguments\n\ncs: [CoupledSimulation] containing info about the simulation\nt: [Real] number of seconds since simulation began\n\n\n\n\n\ncurrent_date(cs::Interfacer.CoupledSimulation, t::ITime)\n\nReturn the model date at the current timestep.\n\nArguments\n\ncs: [CoupledSimulation] containing info about the simulation\nt: [ITime] containing all the information needed to produce a date\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ClimaCoupler.TimeManager.strdate_to_datetime","page":"TimeManager","title":"ClimaCoupler.TimeManager.strdate_to_datetime","text":"strdate_to_datetime(strdate::String)\n\nConvert from String (\"YYYYMMDD\") to Date format, required by the official AMIP input files.\n\nArguments\n\nstrdate: [String] to be converted to Date type\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ClimaCoupler.TimeManager.datetime_to_strdate","page":"TimeManager","title":"ClimaCoupler.TimeManager.datetime_to_strdate","text":"datetime_to_strdate(datetime::DateTime)\n\nConvert from Date to String (\"YYYYMMDD\") format.\n\nArguments\n\ndatetime: [Dates.DateTime] object to be converted to string\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ClimaCoupler.TimeManager.maybe_trigger_callback","page":"TimeManager","title":"ClimaCoupler.TimeManager.maybe_trigger_callback","text":"maybe_trigger_callback(callback, cs, t)\n\nCheck if it time to call callback, if yes, call its function on cs.\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ITime","page":"TimeManager","title":"ITime","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"ITime, or integer time, is a time type used by CliMA simulations to keep track of simulation time. For more information, refer to the TimeManager section in ClimaUtilities and the ITime section in ClimaAtmos.","category":"page"},{"location":"timemanager/#How-do-I-use-ITime?","page":"TimeManager","title":"How do I use ITime?","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"If you are running a simulation from a YAML file, you can simply set use_itime to true to enable ITime. If you do not want to use ITime and want to use floating point numbers, then set use_itime to false to not use ITime.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Atmospheric-Model","page":"Atmospheric Model","title":"Atmospheric Model","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/#Atmosphere-Conservation-Equations","page":"Atmospheric Model","title":"Atmosphere Conservation Equations","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Density:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rhopartial t + nabla cdot (rho vecu)= S(chi )","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Momentum (flux form):","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho vecupartial t + nabla cdot (rho vecu otimes vecu + pI)= nabla cdot (rho tau) - rho g + F_B()","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Potential temperature:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho thetapartial t + nabla cdot (rho theta vecu) = nabla cdot (kappa rho nabla theta)","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Total Energy (possibly replace potential temperature equation with total energy conservation):","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho e_totpartial t + nabla cdot ((rho e_tot + p )vecu) = nabla cdot (kappa rho nabla h_tot)","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"where h_tot is the total specific enthalpy given by internal and potential energy contributions.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Tracer transport:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho chipartial t + nabla cdot (rho chi vecu) = nabla cdot (kappa rho nabla chi) + S(chi )","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Diffusion (Constant Viscosity): The simplest model to represent diffusive processes is a constant-viscosity model, with prescribed kinematic viscosity nu such that the stress tensor can be modelled by","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"rhotau = -2rhonunabla u","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Smagorinsky Closure: The Smagorinsky closure is an eddy-viscosity model that captures the effect of energy transfer to the smallest scales of motion in the flow.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\nrhotau = -2rhonuvecS \nvecS = frac12((nabla u) + (nabla u)^T) \nnu = (C_sDelta_xyz)^2sqrt2S_ijS_ij\nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"with Delta_xyz the grid lengthscale (sometimes approximated as a geometric average Delta = (Delta_xDelta_yDelta_z)^13), nu is a spatially varying kinematic viscosity that depends on the local shear, vecS the symmetric rate-of-strain tensor, tau the diffusive momentum flux tensor. In stratified flows, we can apply a correction to the eddy viscosity to account for buoyancy effects. Thermal diffusivities are related to the modelled eddy-viscosity through the turbulent Prandtl number which takes a typical value of Pr_t= 13 such that kappa_2 = nuPr_t.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Tendencies for fourth-order hyperdiffusion are included in the rhs! construction, but the coefficient kappa_4 is 0 in this demonstrative case. Hyperdiffusive tendencies are typically included as a scale-selective diffusion mechanism for high-frequency noise (e.g. stabilization in GCMs).","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Consider components of the viscous stress tensor in three dimensions:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\ntau_xx = 2nu fracpartial upartial x \n\ntau_yy = 2nu fracpartial vpartial y \n\ntau_zz = 2nu fracpartial wpartial z \n\ntau_xy = nu Big(fracpartial upartial y +  fracpartial vpartial xBig) \n\ntau_xz = nu Big(fracpartial upartial z +  fracpartial wpartial xBig) \n\ntau_yz = nu Big(fracpartial vpartial z +  fracpartial wpartial yBig)\nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Assume terms in the y-direction are neglected (2-dimensional simplicfication). The contributions to the momentum equation are then given by:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\n(rho u)  partial_x (rho tau_xx) + partial_z(rhotau_xz)  = partial_x  Big(2nu fracpartial upartial xBig) + partial_zBig(nu fracpartial upartial zBig) + partial_zBig(nu fracpartial wpartial xBig) \n(rho w) partial_x (rho tau_zx)+ partial_z(rhotau_zz)  = partial_xBig(nu fracpartial upartial zBig) +  partial_xBig(nu fracpartial wpartial xBig) + partial_zBig(2nufracpartial wpartial z Big) \nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Which can be interpreted as, for horizontal-momentum:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Horizontal divergence of vertical gradients of cell-centered variables u\nVertical divergence of vertical gradients of cell-centered variables u\nVertical divergence of horizontal gradients of cell-face variables w","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"and for vertical-momentum, as:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Horizontal divergence of vertical gradients of cell-centered variables u\nHorizontal divergence of horizontal gradients of cell-face variables w\nVertical divergence of vertical gradients of cell-face variables w.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Model-Code","page":"Atmospheric Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"push!(LOAD_PATH, joinpath(@__DIR__, \"..\", \"..\", \"..\"))\n\nimport LinearAlgebra\nimport SciMLBase\nimport StaticArrays\n\nimport ClimaCore as CC\nimport ClimaCore.Geometry: ⊗\nimport ClimaComms","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Load coupled simulation code","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"include(\"../CoupledSims/coupled_sim.jl\")\n\n# set up function space\nfunction hvspace_2D(xlim = (-π, π), zlim = (0, 4π), helem = 20, velem = 20, npoly = 1)\n    FT = Float64\n    vertdomain = CC.Domains.IntervalDomain(\n        CC.Geometry.ZPoint{FT}(zlim[1]),\n        CC.Geometry.ZPoint{FT}(zlim[2]);\n        boundary_names = (:bottom, :top),\n    )\n    context = ClimaComms.context()\n    vertmesh = CC.Meshes.IntervalMesh(vertdomain, nelems = velem)\n    if pkgversion(CC) >= v\"0.14.10\"\n        device = ClimaComms.device(context)\n        vert_center_space = CC.Spaces.CenterFiniteDifferenceSpace(device, vertmesh)\n    else\n        vert_center_space = CC.Spaces.CenterFiniteDifferenceSpace(vertmesh)\n    end\n\n    horzdomain =\n        CC.Domains.IntervalDomain(CC.Geometry.XPoint{FT}(xlim[1]), CC.Geometry.XPoint{FT}(xlim[2]), periodic = true)\n    horzmesh = CC.Meshes.IntervalMesh(horzdomain; nelems = helem)\n    horztopology = CC.Topologies.IntervalTopology(horzmesh)\n\n    quad = CC.Spaces.Quadratures.GLL{npoly + 1}()\n    horzspace = CC.Spaces.SpectralElementSpace1D(horztopology, quad)\n\n    hv_center_space = CC.Spaces.ExtrudedFiniteDifferenceSpace(horzspace, vert_center_space)\n    hv_face_space = CC.Spaces.FaceExtrudedFiniteDifferenceSpace(hv_center_space)\n    return (hv_center_space, hv_face_space)\nend\n\nfunction pressure(ρθ)\n    if ρθ >= 0\n        return MSLP * (R_d * ρθ / MSLP)^γ\n    else\n        return NaN\n    end\nend\n\nΦ(z) = grav * z\n\nabstract type BCtag end\nstruct ZeroFlux <: BCtag end\n\nbc_divF2C_bottom!(::ZeroFlux, dY, Y, p, t) = CC.Operators.SetValue(CC.Geometry.WVector(0.0))\nbc_divF2C_top!(::ZeroFlux, dY, Y, p, t) = CC.Operators.SetValue(CC.Geometry.WVector(0.0))\n\nfunction init_sea_breeze_2d(x, z)\n    θ₀ = atm_T_ini\n    cp_d = C_p\n    cv_d = C_v\n    p₀ = MSLP\n    g = grav\n    γ = cp_d / cv_d\n    z_c = 100.0\n    θ_b = atm_T_ini\n    θ_p = z < z_c ? rand() - 0.5 : 0.0 # potential temperature perturbation\n    θ = θ_b + θ_p # potential temperature\n    π_exn = 1.0 - g * z / cp_d / θ # exner function\n    T = π_exn * θ # temperature\n    p = p₀ * π_exn^(cp_d / R_d) # pressure\n    ρ = p / R_d / T # density\n    ρθ = ρ * θ # potential temperature density\n    return (ρ = ρ, ρθ = ρθ, ρuₕ = ρ * CC.Geometry.UVector(0.0))\nend\n\nfunction atm_rhs!(dY, Y, params, t)\n    ρw = Y.ρw\n    Yc = Y.Yc\n    dYc = dY.Yc\n    dρw = dY.ρw\n\n    center_coords = CC.Fields.coordinate_field(axes(Yc))\n\n    # spectral horizontal operators\n    hdiv = CC.Operators.Divergence()\n    hgrad = CC.Operators.Gradient()\n    hwdiv = CC.Operators.WeakDivergence()\n    hwgrad = CC.Operators.WeakGradient()\n\n    # vertical FD operators with BC's\n    vdivf2c = CC.Operators.DivergenceF2C(\n        bottom = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n        top = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n    )\n    vvdivc2f = CC.Operators.DivergenceC2F(\n        bottom = CC.Operators.SetDivergence(CC.Geometry.WVector(0.0)),\n        top = CC.Operators.SetDivergence(CC.Geometry.WVector(0.0)),\n    )\n    uvdivf2c = CC.Operators.DivergenceF2C(\n        bottom = CC.Operators.SetValue(CC.Geometry.WVector(0.0) ⊗ CC.Geometry.UVector(0.0)),\n        top = CC.Operators.SetValue(CC.Geometry.WVector(0.0) ⊗ CC.Geometry.UVector(0.0)),\n    )\n    If = CC.Operators.InterpolateC2F(bottom = CC.Operators.Extrapolate(), top = CC.Operators.Extrapolate())\n    Ic = CC.Operators.InterpolateF2C()\n    ∂ = CC.Operators.DivergenceF2C(\n        bottom = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n        top = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n    )\n    ∂f = CC.Operators.GradientC2F()\n    ∂c = CC.Operators.GradientF2C()\n    B = CC.Operators.SetBoundaryOperator(\n        bottom = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n        top = CC.Operators.SetValue(CC.Geometry.WVector(0.0)),\n    )\n\n    ∇_z_ρθ = CC.Operators.DivergenceF2C(\n        bottom = bc_divF2C_bottom!(params.bc.ρθ.bottom, dY, Y, params, t),\n        top = bc_divF2C_top!(params.bc.ρθ.top, dY, Y, params, t),\n    )\n\n    uₕ = @. Yc.ρuₕ / Yc.ρ\n    w = @. ρw / If(Yc.ρ)\n    wc = @. Ic(ρw) / Yc.ρ\n    p = @. pressure(Yc.ρθ)\n    θ = @. Yc.ρθ / Yc.ρ\n    Yfρ = @. If(Yc.ρ)\n\n    ### HYPERVISCOSITY\n    # 1) compute hyperviscosity coefficients\n    @. dYc.ρθ = hwdiv(hgrad(θ))\n    @. dYc.ρuₕ = hwdiv(hgrad(uₕ))\n    @. dρw = hwdiv(hgrad(w))\n    CC.Spaces.weighted_dss!(dYc)\n    CC.Spaces.weighted_dss!(dρw)\n\n    κ₄ = 0.0 # m^4/s\n    @. dYc.ρθ = -κ₄ * hwdiv(Yc.ρ * hgrad(dYc.ρθ))\n    @. dYc.ρuₕ = -κ₄ * hwdiv(Yc.ρ * hgrad(dYc.ρuₕ))\n    @. dρw = -κ₄ * hwdiv(Yfρ * hgrad(dρw))\n\n    # density\n    @. dYc.ρ = -∂(ρw)\n    @. dYc.ρ -= hdiv(Yc.ρuₕ)\n\n    # potential temperature\n    @. dYc.ρθ += -(∇_z_ρθ(ρw * If(Yc.ρθ / Yc.ρ)))\n    @. dYc.ρθ -= hdiv(uₕ * Yc.ρθ)\n\n    # horizontal momentum\n    Ih = Ref(CC.Geometry.Axis2Tensor((CC.Geometry.UAxis(), CC.Geometry.UAxis()), StaticArrays.@SMatrix [1.0]))\n    @. dYc.ρuₕ += -uvdivf2c(ρw ⊗ If(uₕ))\n    @. dYc.ρuₕ -= hdiv(Yc.ρuₕ ⊗ uₕ + p * Ih)\n\n    # vertical momentum\n    @. dρw += B(\n        CC.Geometry.transform(CC.Geometry.WAxis(), -(∂f(p)) - If(Yc.ρ) * ∂f(Φ(center_coords.z))) - vvdivc2f(Ic(ρw ⊗ w)),\n    )\n    uₕf = @. If(Yc.ρuₕ / Yc.ρ) # requires boundary conditions\n    @. dρw -= hdiv(uₕf ⊗ ρw)\n\n    # DIFFUSION\n    κ₂ = 5.0 # m^2/s\n    #  1a) horizontal div of horizontal grad of horiz momentun\n    @. dYc.ρuₕ += hwdiv(κ₂ * (Yc.ρ * hgrad(Yc.ρuₕ / Yc.ρ)))\n    #  1b) vertical div of vertical grad of horiz momentun\n    @. dYc.ρuₕ += uvdivf2c(κ₂ * (Yfρ * ∂f(Yc.ρuₕ / Yc.ρ)))\n\n    #  1c) horizontal div of horizontal grad of vert momentum\n    @. dρw += hwdiv(κ₂ * (Yfρ * hgrad(ρw / Yfρ)))\n    #  1d) vertical div of vertical grad of vert momentun\n    @. dρw += vvdivc2f(κ₂ * (Yc.ρ * ∂c(ρw / Yfρ)))\n\n    #  2a) horizontal div of horizontal grad of potential temperature\n    @. dYc.ρθ += hwdiv(κ₂ * (Yc.ρ * hgrad(Yc.ρθ / Yc.ρ)))\n    #  2b) vertical div of vertial grad of potential temperature\n    @. dYc.ρθ += ∇_z_ρθ(κ₂ * (Yfρ * ∂f(Yc.ρθ / Yc.ρ)))\n\n    CC.Spaces.weighted_dss!(dYc)\n    CC.Spaces.weighted_dss!(dρw)\n    return dY\nend\n\n# init simulation\nfunction atm_init(; xmin = -500, xmax = 500, zmin = 0, zmax = 1000, npoly = 3, helem = 20, velem = 20, bc = nothing)\n\n    # construct domain spaces\n    hv_center_space, hv_face_space = hvspace_2D((xmin, xmax), (zmin, zmax), helem, velem, npoly) # [m]\n    center_coords = CC.Fields.coordinate_field(hv_center_space)\n    face_coords = CC.Fields.coordinate_field(hv_face_space)\n    domain = (hv_center_space = hv_center_space, hv_face_space = hv_face_space)\n\n    # initialize prognostic variables\n    Yc = map(center_coords) do coord\n        sea_breeze = init_sea_breeze_2d(coord.x, coord.z)\n        sea_breeze\n    end\n\n    ρw = map(face_coords) do coord\n        CC.Geometry.WVector(0.0)\n    end\n\n    Y = CC.Fields.FieldVector(Yc = Yc, ρw = ρw)\n\n    # select boundary conditions\n    if bc === nothing\n        bc = (\n            ρθ = (bottom = CoupledFlux(), top = ZeroFlux()),\n            ρu = nothing, # for now BCs are hard coded, except for ρθ\n        )\n    end\n\n    return Y, bc, domain\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Coupled-Atmos-Wrappers","page":"Atmospheric Model","title":"Coupled Atmos Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"# Atmos Simulation - later to live in ClimaAtmos\nstruct AtmosSim{T} <: AbstractAtmosSim\n    integrator::T\nend\n\nfunction AtmosSim(Y_init, t_start, dt, t_end, timestepper, p, saveat, callbacks = CallbackSet())\n    ode_algo = CTS.ExplicitAlgorithm(timestepper)\n    ode_function = CTS.ClimaODEFunction(T_exp! = atm_rhs!)\n\n    problem = SciMLBase.ODEProblem(ode_function, Y_init, (t_start, t_end), p)\n    atm_integ = SciMLBase.init(\n        problem,\n        ode_algo,\n        dt = dt,\n        saveat = saveat,\n        adaptive = false,\n        progress = true,\n        progress_message = (dt, u, params, t) -> t,\n        callback = callbacks,\n    )\n\n    return AtmosSim(atm_integ)\nend\n\nfunction coupler_push!(coupler::CouplerState, atmos::AtmosSim)\n    coupler_put!(coupler, :F_sfc, atmos.integrator.u.F_sfc, atmos)\nend\n\nfunction coupler_pull!(atmos::AtmosSim, coupler::CouplerState)\n    # reset flux accumulator\n    atmos.integrator.u.F_sfc .= 0.0 # reset surface flux to be accumulated\n\n    T_sfc_ocean = coupler_get(coupler, :T_sfc_ocean, atmos)\n    T_sfc_land = coupler_get(coupler, :T_sfc_land, atmos)\n    atmos.integrator.p.T_sfc .= T_sfc_land .+ T_sfc_ocean\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Coupled-Boundary-Conditions","page":"Atmospheric Model","title":"Coupled Boundary Conditions","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"The standalone atmosphere model uses two boundary condition methods in its tendency: bc_divF2C_bottom! and bc_divF2C_top!. Since the bottom boundary is coupled, bc_divF2C_bottom! must be altered when running in coupled mode to properly calculate and accumulate the boundary flux from the ocean and land components.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"To solve this, a CoupledFlux boundary tag is set for the bottom boundary during initialization. Then, a new method of bc_divF2C_bottom! is written to dispatch on the CoupledFlux boundary tag. This method can then compute the flux appropriately.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"struct CoupledFlux <: BCtag end\nfunction bc_divF2C_bottom!(::CoupledFlux, dY, Y, p, t)\n    # flux calculation\n    Yc = Y.Yc\n    uₕ = Yc.ρuₕ ./ Yc.ρ\n    ρw = Y.ρw\n    If2c = CC.Operators.InterpolateF2C()\n    Ic2f = CC.Operators.InterpolateC2F(bottom = CC.Operators.Extrapolate(), top = CC.Operators.Extrapolate())\n    w = If2c.(ρw) ./ Yc.ρ\n    cuv = @. CC.Geometry.UWVector(uₕ)\n    windspeed = @. LinearAlgebra.norm(cuv)\n    windspeed_boundary = CC.Fields.level(windspeed, 1)\n    θ_boundary = CC.Fields.level(Yc.ρθ ./ Yc.ρ, 1)\n    ρ_boundary = CC.Fields.level(Yc.ρ, 1)\n\n    # build atmos face fields on surface boundary space to enable broadcasting\n    windspeed_boundary = CC.Fields.Field(CC.Fields.field_values(windspeed_boundary), axes(p.T_sfc))\n    θ_boundary = CC.Fields.Field(CC.Fields.field_values(θ_boundary), axes(p.T_sfc))\n    ρ_boundary = CC.Fields.Field(CC.Fields.field_values(ρ_boundary), axes(p.T_sfc))\n\n    λ = @. p.cpl_p.C_p * p.cpl_p.C_H * ρ_boundary * windspeed_boundary\n    dθ = @. θ_boundary - p.T_sfc\n    heat_flux = @. -λ * dθ\n    @. dY.F_sfc += heat_flux # accumulation\n\n    return CC.Operators.SetValue(CC.Geometry.WVector.(heat_flux))\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ClimaCoupler.jl","page":"Home","title":"ClimaCoupler.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Coupling CliMA Models","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ClimaCoupler","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaCoupler.jl provides a means to couple CliMA  model components. It is designed to provide a flexible way to map boundary fluxes of quantities, like moisture and heat, that leave one component model (for example the atmosphere) to boundary fluxes of another component model (for example the ocean model). Functionality includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"coupled system time stepping control that integrates fluxes in time for sharing between components with differing time steps and/or time stepping schemes.\nsupport for mapping import and export boundary information between components so that fluxes of properties transferred between components are conserved.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ClimaCoupler supports coupling components that are all within the same process or coupling components (using MPI) that are running on different processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Coupler Scheme)\nClimaCoupler.jl allows for independent development of interchangeable component models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaCoupler","category":"page"},{"location":"#ClimaCoupler.ClimaCoupler","page":"Home","title":"ClimaCoupler.ClimaCoupler","text":"ClimaCoupler\n\nModule for atmos-ocean-land coupled simulations.\n\n\n\n\n\n","category":"module"}]
}
