var documenterSearchIndex = {"docs":
[{"location":"checkpointer/#Checkpointer","page":"Checkpointer","title":"Checkpointer","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"This module contains general functions for logging the model states and restarting simulations. The Checkpointer uses ClimaCore.InputOutput infrastructure, which allows it to handle arbitrarily distributed logging and restart setups.","category":"page"},{"location":"checkpointer/#Checkpointer-API","page":"Checkpointer","title":"Checkpointer API","text":"","category":"section"},{"location":"checkpointer/","page":"Checkpointer","title":"Checkpointer","text":"    ClimaCoupler.Checkpointer.get_model_state_vector\n    ClimaCoupler.Checkpointer.restart_model_state!\n    ClimaCoupler.Checkpointer.checkpoint_model_state","category":"page"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.get_model_state_vector","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.get_model_state_vector","text":"get_model_state_vector(sim::Interfacer.ComponentModelSimulation)\n\nReturns the model state of a simulation as a ClimaCore.FieldVector. This is a template function that should be implemented for each component model.\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.restart_model_state!","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.restart_model_state!","text":"restart_model_state!(sim::Interfacer.ComponentModelSimulation, comms_ctx::ClimaComms.AbstractCommsContext, t::Int; input_dir = \"input\")\n\nSets the model state of a simulation from a HDF5 file from a given time, t (in seconds).\n\n\n\n\n\n","category":"function"},{"location":"checkpointer/#ClimaCoupler.Checkpointer.checkpoint_model_state","page":"Checkpointer","title":"ClimaCoupler.Checkpointer.checkpoint_model_state","text":"checkpoint_model_state(sim::Interfacer.ComponentModelSimulation, comms_ctx::ClimaComms.AbstractCommsContext, t::Int; output_dir = \"output\")\n\nCheckpoints the model state of a simulation to a HDF5 file at a given time, t (in seconds).\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#FieldExchanger","page":"FieldExchanger","title":"FieldExchanger","text":"","category":"section"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"This module contains general functions for the exchange of fields between the atmospheric and surface component models.","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"The FieldExchanger needs to populate the coupler with","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"atmospheric fields (mostly fluxes), via the import_atmos_fields! function\naverage surface properties of each coupler gridpoint, via the import_combined_surface_fields! function","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"The component models are updated by broadcasting the coupler fields, via the update_model_sims! function. For an update, this function requires that update_field! is defined for the particular variable and component model. Currently, we support the:","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"AtmosModelSimulation: albedo, surface_temperature\nif calculating fluxes in the atmospheric model: roughness_momentum, roughness_buoyancy, beta\nSurfaceModelSimulation: air_density, turbulent_energy_flux, turbulent_moisture_flux, radiative_energy_flux, liquid_precipitation, snow_precipitation","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"If an update_field! function is not defined for a particular component model, it will be ignored.","category":"page"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"Each component model is also required to define its own step! and reinit! functions, otherwise this will be ignored.","category":"page"},{"location":"fieldexchanger/#FieldExchanger-API","page":"FieldExchanger","title":"FieldExchanger API","text":"","category":"section"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"    ClimaCoupler.FieldExchanger.import_atmos_fields!\n    ClimaCoupler.FieldExchanger.import_combined_surface_fields!\n    ClimaCoupler.FieldExchanger.update_model_sims!\n    ClimaCoupler.FieldExchanger.update_sim!\n    ClimaCoupler.FieldExchanger.reinit_model_sims!\n    ClimaCoupler.FieldExchanger.step_model_sims!","category":"page"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.import_atmos_fields!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.import_atmos_fields!","text":"import_atmos_fields!(csf, model_sims, boundary_space, turbulent_fluxes)\n\nUpdates the coupler with the atmospheric fluxes. The Interfacer.get_field functions (:turbulent_energy_flux, :turbulent_moisture_flux, :radiative_energy_flux, :liquid_precipitation, :snow_precipitation) have to be defined for the amtospheric component model type.\n\nArguments\n\ncsf: [NamedTuple] containing coupler fields.\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\nboundary_space: [Spaces.AbstractSpace] the space of the coupler surface.\nturbulent_fluxes: [TurbulentFluxPartition] denotes a flag for turbulent flux calculation.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.import_combined_surface_fields!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.import_combined_surface_fields!","text":"import_combined_surface_fields!(csf, model_sims, boundary_space, turbulent_fluxes)\n\nUpdates the coupler with the surface properties. The Interfacer.get_field functions for (:surface_temperature, :albedo, :roughness_momentum, :roughness_buoyancy, :beta) need to be specified for each surface model.\n\nArguments\n\ncsf: [NamedTuple] containing coupler fields.\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\nboundary_space: [Spaces.AbstractSpace] the space of the coupler surface.\nturbulent_fluxes: [TurbulentFluxPartition] denotes a flag for turbulent flux calculation.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.update_model_sims!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.update_model_sims!","text":"update_model_sims!(model_sims, csf, turbulent_fluxes)\n\nIterates update_sim! over all component model simulations saved in cs.model_sims.\n\nArguments\n\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\ncsf: [NamedTuple] containing coupler fields.\nturbulent_fluxes: [TurbulentFluxPartition] denotes a flag for turbulent flux calculation.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.update_sim!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.update_sim!","text":"update_sim!(atmos_sim::Interfacer.AtmosModelSimulation, csf)\n\nUpdates the surface fields for temperature, roughness length, albedo, and specific humidity.\n\nArguments\n\natmos_sim: [Interfacer.AtmosModelSimulation] containing an atmospheric model simulation object.\ncsf: [NamedTuple] containing coupler fields.\n\n\n\n\n\nupdate_sim!(sim::SurfaceModelSimulation, csf, area_fraction = nothing)\n\nUpdates the surface component model cache with the current coupler fields of Fturbenergy, Fradiative, Fturbmoisture, Pliq, and ρ_sfc.\n\nArguments\n\nsim: [Interfacer.SurfaceModelSimulation] containing a surface model simulation object.\ncsf: [NamedTuple] containing coupler fields.\n\n\n\n\n\nupdate_sim!(::SurfaceStub, csf, area_fraction)\n\nThe stub surface simulation only updates the air density (needed for the turbulent flux calculation).\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.reinit_model_sims!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.reinit_model_sims!","text":"reinit_model_sims!(model_sims)\n\nIterates reinit! over all component model simulations saved in cs.model_sims.\n\nArguments\n\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#ClimaCoupler.FieldExchanger.step_model_sims!","page":"FieldExchanger","title":"ClimaCoupler.FieldExchanger.step_model_sims!","text":"step_model_sims!(model_sims, t)\n\nIterates step! over all component model simulations saved in cs.model_sims.\n\nArguments\n\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\nt: [AbstractFloat] denoting the simulation time.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#FieldExchanger-Internal-Functions","page":"FieldExchanger","title":"FieldExchanger Internal Functions","text":"","category":"section"},{"location":"fieldexchanger/","page":"FieldExchanger","title":"FieldExchanger","text":"    ClimaCoupler.FieldExchanger.step!\n    ClimaCoupler.FieldExchanger.reinit!","category":"page"},{"location":"fieldexchanger/#CommonSolve.step!","page":"FieldExchanger","title":"CommonSolve.step!","text":"step!(::SurfaceStub, t)\n\nThe stub surface simulation is not updated by this function. Extends SciMLBase.step!.\n\n\n\n\n\n","category":"function"},{"location":"fieldexchanger/#SciMLBase.reinit!","page":"FieldExchanger","title":"SciMLBase.reinit!","text":"reinit!(cs::SurfaceStub)\n\nThe stub surface simulation is not updated by this function. Extends SciMLBase.reinit!.\n\n\n\n\n\n","category":"function"},{"location":"postprocessor/#PostProcessor","page":"PostProcessor","title":"PostProcessor","text":"","category":"section"},{"location":"postprocessor/","page":"PostProcessor","title":"PostProcessor","text":"This module contains functions for postprocessing model data that was saved during the simulation  by ClimaCoupler.Diagnostics. This module is used for offline regridding, slicing and spatial  averages. It can also handle data from other sources (e.g., NCEP reanalysis). ","category":"page"},{"location":"postprocessor/#Diagnostics-API","page":"PostProcessor","title":"Diagnostics API","text":"","category":"section"},{"location":"postprocessor/","page":"PostProcessor","title":"PostProcessor","text":"ClimaCoupler.PostProcessor.postprocess\nClimaCoupler.PostProcessor.PostProcessedData\nClimaCoupler.PostProcessor.ZLatLonData\nClimaCoupler.PostProcessor.ZLatData\nClimaCoupler.PostProcessor.LatLonData\nClimaCoupler.PostProcessor.LatData\nClimaCoupler.PostProcessor.RawData\nClimaCoupler.PostProcessor.DataPackage\n","category":"page"},{"location":"postprocessor/#ClimaCoupler.PostProcessor.postprocess","page":"PostProcessor","title":"ClimaCoupler.PostProcessor.postprocess","text":"postprocess(\n    name::Symbol,\n    raw_data::Union{Fields.Field, Array},\n    p_methods::Tuple;\n    lev_slice = 1,\n    datafile_latlon = nothing,\n    nlat = 90,\n    nlon = 180,\n)\n\nCoordinates regridding, averaging or slicing of variable name corresponding to raw_data. Postprocessing methods are specified in p_methods. raw_data is assumed to be a Field (dimensions corresponding to the model's CGLL grid), a 2D Array with [longitude, latitude] or a 3D Array [longitude, latitude, level].\n\nArguments:\n\nname: [Symbol] variable name\nraw_data: [Union{Fields.Field, Array}] variable data\np_methods: [Tuple] postproessing methods (:regrid, :horizontal_slice, :zonal_mean)\nlev_slice: [Int] level index along which the :horizontal_slice is applied\ndatafile_latlon: [String] name of the regrid file\nnlat: [Int] number of latitudes of the regridded array\nnlon: [Symbol] number of longitudes of the regridded array\n\n\n\n\n\n","category":"function"},{"location":"postprocessor/#ClimaCoupler.PostProcessor.DataPackage","page":"PostProcessor","title":"ClimaCoupler.PostProcessor.DataPackage","text":"DataPackage(tag::PostProcessedData, name::Symbol, data::Union{Array, Field}; coords = coords)\n\nA container for storing the tyoe, name, data and coordinates of a variable.\n\n\n\n\n\n","category":"type"},{"location":"postprocessor/#Diagnostics-Internal-Functions","page":"PostProcessor","title":"Diagnostics Internal Functions","text":"","category":"section"},{"location":"postprocessor/","page":"PostProcessor","title":"PostProcessor","text":"ClimaCoupler.PostProcessor.read_remapped_field","category":"page"},{"location":"postprocessor/#ClimaCoupler.PostProcessor.read_remapped_field","page":"PostProcessor","title":"ClimaCoupler.PostProcessor.read_remapped_field","text":"read_remapped_field(name::Symbol, datafile_latlon::String, lev_name = \"z\")\n\nExtract data and coordinates from datafile_latlon.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"This module contains functions, objects, and constants used by various modules in the coupler.","category":"page"},{"location":"utilities/#Utilities-API","page":"Utilities","title":"Utilities API","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"ClimaCoupler.Utilities.CouplerSimulation\nClimaCoupler.Utilities.float_type\nClimaCoupler.Utilities.swap_space!","category":"page"},{"location":"utilities/#ClimaCoupler.Utilities.swap_space!","page":"Utilities","title":"ClimaCoupler.Utilities.swap_space!","text":"swap_space!(field_out::Fields.Field, field_in::Fields.Field)\n\nRemap the values of a field onto a new space.\n\nArguments\n\nfield_in: [Fields.Field] to be remapped to new space.\nfield_out: [Fields.Field] to remap field_in to.\n\n\n\n\n\n","category":"function"},{"location":"generated/sea_breeze/land_rhs/#Land-Model","page":"Land Model","title":"Land Model","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"Load coupled simulation code","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"include(\"../CoupledSims/coupled_sim.jl\")","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Slab-Land-ODE","page":"Land Model","title":"Slab Land ODE","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"For our land component, we solve a simple slab land ODE:","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"rho_l c_l H_l partial_t T_lnd = - F_integ  Delta t_coupler","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"where rho_l = 1500 kg m ^-3, c_l=800 J K ^-1 kg ^-1, H_l=1 m are the density, specific heat and depth of the land slab,\nand F_integ is the integrated surface fluxes in time.","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Model-Code","page":"Land Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"function lnd_rhs!(du, u, (parameters, F_accumulated), t)\n    \"\"\"\n    Slab layer equation\n        d(T_lnd)/dt = - (F_accumulated + G) / (h_lnd * ρ_lnd * c_lnd)\n        where\n            F_accumulated = F_integrated / Δt_coupler\n    \"\"\"\n    @unpack lnd_h, lnd_ρ, lnd_c = parameters\n    @unpack T_sfc = du\n\n    @. T_sfc = (-F_accumulated) / (lnd_h * lnd_ρ * lnd_c)\nend\n\n# set up domain\nfunction hspace_1D(xlim = (-π, π), npoly = 0, helem = 10)\n    FT = Float64\n\n    domain = Domains.IntervalDomain(Geometry.XPoint{FT}(xlim[1]) .. Geometry.XPoint{FT}(xlim[2]), periodic = true)\n    mesh = Meshes.IntervalMesh(domain; nelems = helem)\n    topology = Topologies.IntervalTopology(mesh)\n\n    # Finite Volume Approximation: Gauss-Lobatto with 1pt per element\n    quad = Spaces.Quadratures.GL{npoly + 1}()\n    space = Spaces.SpectralElementSpace1D(topology, quad)\n\n    return space\nend\n\n# init simulation\nfunction lnd_init(; xmin = -1000, xmax = 1000, helem = 20, npoly = 0)\n\n    # construct domain spaces - get only surface layer (NB: z should be zero, not z = first central height)\n    space = hspace_1D((xmin, xmax), npoly, helem)\n    coords = Fields.coordinate_field(space)\n    domain = space\n\n    # initial condition\n    T_sfc = map(coords) do coord\n        T_sfc = 273.0\n    end\n\n    # prognostic variable\n    Y = Fields.FieldVector(T_sfc = T_sfc)\n\n    return Y, domain\nend","category":"page"},{"location":"generated/sea_breeze/land_rhs/#Coupled-Land-Wrappers","page":"Land Model","title":"Coupled Land Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"# Land Simulation - later to live in ClimaLSM\nstruct LandSim <: AbstractLandSim\n    integrator::Any\nend\n\nfunction LandSim(Y_init, t_start, dt, t_end, timestepper, p, saveat, callbacks = CallbackSet())\n    lnd_prob = ODEProblem(lnd_rhs!, Y_init, (t_start, t_end), p)\n    lnd_integ = init(lnd_prob, timestepper, dt = dt, saveat = saveat, callback = callbacks)\n    return LandSim(lnd_integ)\nend\n\nfunction coupler_push!(coupler::CouplerState, land::LandSim)\n    coupler_put!(coupler, :T_sfc_land, land.integrator.u.T_sfc, land)\nend\n\nfunction coupler_pull!(land::LandSim, coupler::CouplerState)\n    coupler_get!(land.integrator.p.F_sfc, coupler, :F_sfc, land)\n    land.integrator.p.F_sfc ./= coupler.Δt_coupled\nend","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"","category":"page"},{"location":"generated/sea_breeze/land_rhs/","page":"Land Model","title":"Land Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"performance/#Performance-Analysis-Tools","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"","category":"section"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"ClimaCoupler.jl provides basic tools for analyzing performance:","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"Flame graphs: the perf/flame.jl script is run by Buildkite to produce flame graphs using ProfileCanvas.jl in the perf/output/ directory.\nJob walltime and allocation history: use Buildkite to trigger the build_history script to output an interactive plot with the history of memory usage and time elapsed for each tracked job (default: current build and past builds of the staging branch over the past year). Use key to select which jobs to track. More documentation can be found in the SLURM-Buildkite Wiki.","category":"page"},{"location":"performance/#Flame-Graph-Interpretation","page":"Performance Analysis Tools","title":"Flame Graph Interpretation","text":"","category":"section"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"use for single-process (un)threaded performance CPU profiling of individual stack traces. It provides a tree representation of a set of backtraces, showing the dependence and CPU cost of each function.\nhere is an example of a flame graph of ClimaCoupler's AMIP run, produced by Buildkite running the perf/flame.jl script:","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"(Image: canvas)","category":"page"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"each row along the y-axis represents a level of backtraces. In this case the lowermost level is at the top, and the top level represents what is directly being run on the CPU. The stacks in each level are sorted alphabetically (not chronologically, like flame charts). The column width is proportional to the presence in samples (related to allocations). The colors are grouped into runtime-dispatch, gc, compilation and default. The intensity is random.\nwe also have a local beta version of flame graphs (in perf/ProfileCanvasDiff.jl and perf/ProfileViewerDiff.js), triggered by the perf/flame_diff.jl script, which plots the same flame graphs as above but with the color corresponding to whether the stack allocation has been reduced (blue) or increased (red) compared to the last staged runs. The color intensity is proportional to the fractional change, and black signifies untracked traces. The default is to show the cumulative allocation (current function + all its children functions). By setting self_count to true, we can also count only the allocations of the current function itself, allowing us to isolate allocation changes within our software from changes in the upstream packages.","category":"page"},{"location":"performance/#References","page":"Performance Analysis Tools","title":"References","text":"","category":"section"},{"location":"performance/","page":"Performance Analysis Tools","title":"Performance Analysis Tools","text":"Description of flame graphs and their interpretation\nClimaCore tips for writing performant code\nGeneral Julia-specific performance tips\nLogging performance history using Buildkite and SLURM\nNSight Systems for MPI profiling using Buildkite and SLURM","category":"page"},{"location":"diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"This module contains functions for defining, gathering and outputting model diagnostics from the Coupler. ","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Note that ClimaCoupler.Diagnostics is deployed online (i.e., as the model runs), working with cached model data (usually) on the model grid. This does not include offline post-processing (i.e., manipulating saved model output after the model is run, such as regridding data to the latitude-longitude grid). See ClimaCoupler.PostProcessor for offline model data treatment. ","category":"page"},{"location":"diagnostics/#Diagnostics-API","page":"Diagnostics","title":"Diagnostics API","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"    ClimaCoupler.Diagnostics.AbstractOutputGroup\n    ClimaCoupler.Diagnostics.DiagnosticsGroup\n    ClimaCoupler.Diagnostics.AbstractDiagnosticsOperations\n    ClimaCoupler.Diagnostics.TimeMean\n    ClimaCoupler.Diagnostics.get_var\n    ClimaCoupler.Diagnostics.accumulate_diagnostics!\n    ClimaCoupler.Diagnostics.save_diagnostics","category":"page"},{"location":"diagnostics/#ClimaCoupler.Diagnostics.get_var","page":"Diagnostics","title":"ClimaCoupler.Diagnostics.get_var","text":"get_var(cs::CoupledSimulation, x)\n\nDefines variable extraction from the coupler simulation. User specific diagnostics should extend this function in the experiments folder.\n\nExample:\n\ngetvar(cs, ::Val{:Tsfc}) = cs.fields.T_S\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#ClimaCoupler.Diagnostics.accumulate_diagnostics!","page":"Diagnostics","title":"ClimaCoupler.Diagnostics.accumulate_diagnostics!","text":"accumulate_diagnostics!(cs::CoupledSimulation)\n\nAccumulates user-defined diagnostics listed in the in the field_vector of each dg.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#ClimaCoupler.Diagnostics.save_diagnostics","page":"Diagnostics","title":"ClimaCoupler.Diagnostics.save_diagnostics","text":"save_diagnostics(cs::CoupledSimulation)\n\nsave_diagnostics(cs::CoupledSimulation, dg::DiagnosticsGroup, output_dir::String)\n\nSaves all entries in dg in separate HDF5 files per variable in output_dir.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#Diagnostics-Internal-Functions","page":"Diagnostics","title":"Diagnostics Internal Functions","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"    ClimaCoupler.Diagnostics.collect_diags\n    ClimaCoupler.Diagnostics.iterate_operations\n    ClimaCoupler.Diagnostics.operation\n    ClimaCoupler.Diagnostics.pre_save\n    ClimaCoupler.Diagnostics.post_save\n    ClimaCoupler.Diagnostics.save_time_format","category":"page"},{"location":"diagnostics/#ClimaCoupler.Diagnostics.collect_diags","page":"Diagnostics","title":"ClimaCoupler.Diagnostics.collect_diags","text":"collect_diags(cs::CoupledSimulation, dg::DiagnosticsGroup)\n\nCollects diagnostics in diags names.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#ClimaCoupler.Diagnostics.operation","page":"Diagnostics","title":"ClimaCoupler.Diagnostics.operation","text":"operation(cs::CoupledSimulation, dg::DiagnosticsGroup, new_diags::Fields.FieldVector, ::TimeMean)\n\nAccumulates in time all entries in new_diags and saves the result in dg.field_vector, while increasing the dg.ct counter.\n\n\n\n\n\noperation(cs::CoupledSimulation, dg::DiagnosticsGroup, new_diags::Fields.FieldVector, ::Nothing)\n\nAccumulates in time all entries in new_diags and saves the result in dg.field_vector, while increasing the dg.ct counter.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#ClimaCoupler.Diagnostics.pre_save","page":"Diagnostics","title":"ClimaCoupler.Diagnostics.pre_save","text":"pre_save(::TimeMean, cs::CoupledSimulation, dg::DiagnosticsGroup)\n\nDivides the accumulated sum by 'ct' to form the mean, before saving the diagnostics.\n\n\n\n\n\npre_save(::Nothing, cs::CoupledSimulation, dg::DiagnosticsGroup\n\nCollects variables and performs all specified operations before saving the snapshot diagnostics.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#ClimaCoupler.Diagnostics.post_save","page":"Diagnostics","title":"ClimaCoupler.Diagnostics.post_save","text":"post_save(::TimeMean, cs::CoupledSimulation, dg::DiagnosticsGroup)\n\nResets accumulating fields and counts after saving the diagnostics.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#ClimaCoupler.Diagnostics.save_time_format","page":"Diagnostics","title":"ClimaCoupler.Diagnostics.save_time_format","text":"save_time_format(date::Dates.DateTime, ::Monthly)\n\nConverts the DateTime date to the conventional Unix format (seconds elapsed since 00:00:00 UTC on 1 January 1970).\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#Interfacer","page":"Interfacer","title":"Interfacer","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"This module contains functions for defining the interface for coupling component models, as well as stub objects that contain prescribed fields.","category":"page"},{"location":"interfacer/#Coupled-Simulation","page":"Interfacer","title":"Coupled Simulation","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"CoupledSimulation (cs) stores info for ESM run. We require that each cs contains four (atmos_sim, land_sim, ocean_sim and ice_sim) components. While this requirement will not be eventually needed, for the time being, if a simulation surface type is not needed for a given run, it should be initialized with SurfaceStub with a zero area_fracion. The atmos_sim should always be specified.","category":"page"},{"location":"interfacer/#Component-model-simulations","page":"Interfacer","title":"Component model simulations","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"all Simulations that are not the CoupledSimulation fall under ComponentModelSimulation\nthe current version requires that there is:\none AtmosModelSimulation\none or more SurfaceModelSimulations, which require the following adapter functions:   get_field(sim::SurfaceModelSimulation, ::Val{:area_fraction}) = ...   get_field(sim::SurfaceModelSimulation, ::Val{:surface_temperature}) = ...   get_field(sim::SurfaceModelSimulation, ::Val{:albedo}) = ...   get_field(sim::SurfaceModelSimulation, ::Val{:roughness_momentum}) = ...   get_field(sim::SurfaceModelSimulation, ::Val{:roughness_buoyancy}) = ...   get_field(sim::SurfaceModelSimulation, ::Val{:beta}) = ...   update_field!(sim::SurfaceModelSimulation, ::Val{:area_fraction}, field::Fields.Field) = ...   update_field!(sim::SurfaceModelSimulation, ::Val{:surface_temperature}, field::Fields.Field) = ...\nthese adapter functions, to be defined in the component models' init files (preferably in their own repositories), allow the coupler to operate without having to assume particular data structures of the underlying component models. This allows easy swapping of model components, as well as a stable source code with coupler-specific unit tests.","category":"page"},{"location":"interfacer/#Prescribed-conditions","page":"Interfacer","title":"Prescribed conditions","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"SurfaceStub is a SurfaceModelSimulation, but it only contains required data in <surface_stub>.cache, e.g., for the calculation of surface fluxes through a prescribed surface state.  The above adapter functions are already predefined for SurfaceStub, with the cache variables specified as:","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"get_field(sim::SurfaceStub, ::Val{:area_fraction}) = sim.cache.area_fraction\nget_field(sim::SurfaceStub, ::Val{:surface_temperature}) = sim.cache.T_sfc\nget_field(sim::SurfaceStub, ::Val{:albedo}) = sim.cache.α\nget_field(sim::SurfaceStub, ::Val{:roughness_momentum}) = sim.cache.z0m\nget_field(sim::SurfaceStub, ::Val{:roughness_buoyancy}) = sim.cache.z0b\nget_field(sim::SurfaceStub, ::Val{:beta}) = sim.cache.beta","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"with the corresponding update_field! functions","category":"page"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"function update_field!(sim::SurfaceStub, ::Val{:area_fraction}, field::Fields.Field)\n    sim.cache.area_fraction .= field\nend\nfunction update_field!(sim::SurfaceStub, ::Val{:surface_temperature}, field::Fields.Field)\n    sim.cache.T_sfc .= field\nend","category":"page"},{"location":"interfacer/#Interfacer-API","page":"Interfacer","title":"Interfacer API","text":"","category":"section"},{"location":"interfacer/","page":"Interfacer","title":"Interfacer","text":"    ClimaCoupler.Interfacer.ComponentModelSimulation\n    ClimaCoupler.Interfacer.AtmosModelSimulation\n    ClimaCoupler.Interfacer.SurfaceModelSimulation\n    ClimaCoupler.Interfacer.SurfaceStub\n    ClimaCoupler.Interfacer.name\n    ClimaCoupler.Interfacer.get_field\n    ClimaCoupler.Interfacer.update_field!","category":"page"},{"location":"interfacer/#ClimaCoupler.Interfacer.ComponentModelSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.ComponentModelSimulation","text":"ComponentModelSimulation\n\nAn abstract type encompassing all component model (and model stub) simulations.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.AtmosModelSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.AtmosModelSimulation","text":"AtmosModelSimulation\n\nAn abstract type for an atmospheric model simulation.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SurfaceModelSimulation","page":"Interfacer","title":"ClimaCoupler.Interfacer.SurfaceModelSimulation","text":"SurfaceModelSimulation\n\nAn abstract type for surface model simulations.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.SurfaceStub","page":"Interfacer","title":"ClimaCoupler.Interfacer.SurfaceStub","text":"SurfaceStub\n\nOn object containing simulation-like info, used as a stub or for prescribed data.\n\n\n\n\n\n","category":"type"},{"location":"interfacer/#ClimaCoupler.Interfacer.name","page":"Interfacer","title":"ClimaCoupler.Interfacer.name","text":"name(::ComponentModelSimulation)\n\nReturns simulation name, if defined, or Unnamed if not.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.get_field","page":"Interfacer","title":"ClimaCoupler.Interfacer.get_field","text":"get_field(::SurfaceStub, ::Val)\n\nA getter function, that should not allocate. If undefined, it returns a descriptive error.\n\n\n\n\n\nget_field(::ComponentModelSimulation, ::Val, colidx::Fields.ColumnIndex)\n\nExtension of get_field(::ComponentModelSimulation, ::Val), indexing into the specified colum index.\n\n\n\n\n\n","category":"function"},{"location":"interfacer/#ClimaCoupler.Interfacer.update_field!","page":"Interfacer","title":"ClimaCoupler.Interfacer.update_field!","text":"update_field!(::ComponentModelSimulation, ::Val, _...)\n\nNo update in unspecified in the particular component model simulation.\n\n\n\n\n\nupdate_field!(sim::SurfaceStub, ::Val{:area_fraction}, field::Fields.Field)\n\nUpdates the specified value in the cache of SurfaceStub.\n\n\n\n\n\n","category":"function"},{"location":"generated/amip/coupler_driver_modular/#AMIP-Driver","page":"AMIP Driver","title":"AMIP Driver","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/#Overview","page":"AMIP Driver","title":"Overview","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"AMIP is a standard experimental protocol of the Program for Climate Model Diagnosis & Intercomparison (PCMDI). It is used as a model benchmark for the atmospheric and land model components, while sea-surface temperatures (SST) and sea-ice concentration (SIC) are prescribed using time-interpolations between monthly observed data. We use standard data files with original sources:","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"SST and SIC: https://gdex.ucar.edu/dataset/158_asphilli.html\nland-sea mask: https://www.ncl.ucar.edu/Applications/Data/#cdf","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"For more information, see the PCMDI's specifications for AMIP I and AMIP II.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"This driver contains two modes. The full AMIP mode and a SlabPlanet (all surfaces are thermal slabs) mode. Since AMIP is not a closed system, the SlabPlanet mode is useful for checking conservation properties of the coupling.","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Start-Up","page":"AMIP Driver","title":"Start Up","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"Before starting Julia, ensure your environment is properly set up:","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"module purge\nmodule load julia/1.9.3 openmpi/4.1.1 hdf5/1.12.1-ompi411 #netcdf-c/4.6.1\n\nexport CLIMACORE_DISTRIBUTED=\"MPI\" #include if using MPI, otherwise leave empty\nexport JUlIA_MPI_BINARY=\"system\"\nexport JULIA_HDF5_PATH=\"\"","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"Next instantiate/build all packages listed in Manifest.toml:","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"julia --project -e 'using Pkg; Pkg.instantiate(); Pkg.build()'\njulia --project -e 'using Pkg; Pkg.build(\"MPI\"); Pkg.build(\"HDF5\")'","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"The coupler_driver.jl is now ready to be run. You can run a SLURM job (e.g., run sbatch sbatch_job.sh from the terminal), or you can run directly from the Julia REPL. The latter is recommended for debugging of lightweight simulations, and should be run with threading enabled:","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"julia --project --threads 8","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Initialization","page":"AMIP Driver","title":"Initialization","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"Here we import standard Julia packages, ClimaESM packages, parse in command-line arguments (if none are specified then the defaults in cli_options.jl apply). We then specify the input data file names. If these are not already downloaded, include artifacts/download_artifacts.jl.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"import SciMLBase: step!, reinit!\nusing OrdinaryDiffEq\nusing OrdinaryDiffEq: ODEProblem, solve, SSPRK33, savevalues!, Euler\nusing LinearAlgebra\nimport Test: @test\nusing Dates\nusing UnPack\nusing Plots\nusing Statistics: mean\nimport ClimaAtmos as CA\nimport YAML\n\nusing ClimaCore.Utilities: half, PlusHalf\nusing ClimaCore: InputOutput, Fields\nimport ClimaCore.Spaces as Spaces\n\n# coupler specific imports\nimport ClimaCoupler\nimport ClimaCoupler.Regridder\nimport ClimaCoupler.Regridder:\n    update_surface_fractions!, combine_surfaces!, combine_surfaces_from_sol!, dummmy_remap!, binary_mask\nimport ClimaCoupler.ConservationChecker:\n    EnergyConservationCheck, WaterConservationCheck, check_conservation!, plot_global_conservation\nimport ClimaCoupler.Utilities: swap_space!\nimport ClimaCoupler.BCReader:\n    bcfile_info_init, float_type_bcf, update_midmonth_data!, next_date_in_file, interpolate_midmonth_to_daily\nimport ClimaCoupler.TimeManager: current_date, datetime_to_strdate, trigger_callback, Monthly, EveryTimestep\nimport ClimaCoupler.Diagnostics: get_var, init_diagnostics, accumulate_diagnostics!, save_diagnostics, TimeMean\nimport ClimaCoupler.PostProcessor: postprocess\n\nimport ClimaCoupler.Interfacer:\n    CoupledSimulation,\n    float_type,\n    AtmosModelSimulation,\n    SurfaceModelSimulation,\n    SurfaceStub,\n    SeaIceModelSimulation,\n    LandModelSimulation,\n    OceanModelSimulation,\n    get_field,\n    update_field!,\n    update_sim!\nimport ClimaCoupler.FluxCalculator:\n    PartitionedStateFluxes,\n    CombinedStateFluxes,\n    combined_turbulent_fluxes!,\n    MoninObukhovScheme,\n    partitioned_turbulent_fluxes!\nimport ClimaCoupler.FieldExchanger:\n    import_atmos_fields!,\n    import_combined_surface_fields!,\n    update_sim!,\n    update_model_sims!,\n    reinit_model_sims!,\n    step_model_sims!\nimport ClimaCoupler.Checkpointer: checkpoint_model_state, get_model_state_vector, restart_model_state!\n\n# helpers for component models\ninclude(\"components/atmosphere/climaatmos_init.jl\")\ninclude(\"components/land/bucket_init.jl\")\ninclude(\"components/land/bucket_utils.jl\")\ninclude(\"components/ocean/slab_ocean_init.jl\")\ninclude(\"components/ocean/prescr_seaice_init.jl\")\ninclude(\"components/ocean/eisenman_seaice_init.jl\")\n\n# helpers for user-specified IO\ninclude(\"user_io/user_diagnostics.jl\")\ninclude(\"user_io/user_logging.jl\")\n\n# coupler defaults\ninclude(\"cli_options.jl\")\nparsed_args = parse_commandline(argparse_settings())\n\n# setup coupler and model configurations","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"modify parsed args for fast testing from REPL #hide","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"pkg_dir = pkgdir(ClimaCoupler)\nif isinteractive()\n    include(\"user_io/debug_plots.jl\")\n    parsed_args[\"config_file\"] =\n        isnothing(parsed_args[\"config_file\"]) ? joinpath(pkg_dir, \"config/model_configs/interactive_debug.yml\") :\n        parsed_args[\"config_file\"]\nend","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"read in config dictionary from file, overriding the coupler defaults","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"config_dict = YAML.load_file(parsed_args[\"config_file\"])\nconfig_dict = merge(parsed_args, config_dict)","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"get component model dictionaries","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"config_dict_atmos = get_atmos_config(config_dict)","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"merge dictionaries of command line arguments, coupler dictionary and component model dictionaries (if there are common keys, the last dictorionary in the merge arguments takes precedence)","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"config_dict = merge(config_dict_atmos, config_dict)\n\n# read in some parsed command line arguments\nmode_name = config_dict[\"mode_name\"]\nrun_name = config_dict[\"run_name\"]\nenergy_check = config_dict[\"energy_check\"]\nconst FT = config_dict[\"FLOAT_TYPE\"] == \"Float64\" ? Float64 : Float32\nland_sim_name = \"bucket\"\nt_end = Int(time_to_seconds(config_dict[\"t_end\"]))\ntspan = (Int(0), t_end)\nΔt_cpl = Int(config_dict[\"dt_cpl\"])\nsaveat = time_to_seconds(config_dict[\"dt_save_to_sol\"])\ndate0 = date = DateTime(config_dict[\"start_date\"], dateformat\"yyyymmdd\")\nmono_surface = config_dict[\"mono_surface\"]\nmonthly_checkpoint = config_dict[\"monthly_checkpoint\"]\nrestart_dir = config_dict[\"restart_dir\"]\nrestart_t = Int(config_dict[\"restart_t\"])\n\n# I/O directory setup\nif isinteractive()\n    COUPLER_OUTPUT_DIR = joinpath(\"output\", joinpath(mode_name, run_name)) # TempestRemap fails if interactive and paths are too long\nelse\n    COUPLER_OUTPUT_DIR = joinpath(pkg_dir, \"experiments/AMIP/modular/output\", joinpath(mode_name, run_name))\nend\nmkpath(COUPLER_OUTPUT_DIR)\n\nREGRID_DIR = joinpath(COUPLER_OUTPUT_DIR, \"regrid_tmp/\")\nmkpath(REGRID_DIR)\n\nCOUPLER_ARTIFACTS_DIR = COUPLER_OUTPUT_DIR * \"_artifacts\"\nisdir(COUPLER_ARTIFACTS_DIR) ? nothing : mkpath(COUPLER_ARTIFACTS_DIR)\n\n@info COUPLER_OUTPUT_DIR\nconfig_dict[\"print_config_dict\"] ? @info(config_dict) : nothing","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"get the paths to the necessary data files: land-sea mask, sst map, sea ice concentration","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"include(joinpath(pkgdir(ClimaCoupler), \"artifacts\", \"artifact_funcs.jl\"))\nsst_data = joinpath(sst_dataset_path(), \"sst.nc\")\nsic_data = joinpath(sic_dataset_path(), \"sic.nc\")\nco2_data = joinpath(co2_dataset_path(), \"mauna_loa_co2.nc\")\nland_mask_data = joinpath(mask_dataset_path(), \"seamask.nc\")","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Component-Model-Initialization","page":"AMIP Driver","title":"Component Model Initialization","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"Here we set initial and boundary conditions for each component model.","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Atmosphere","page":"AMIP Driver","title":"Atmosphere","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"This uses the ClimaAtmos.jl driver, with parameterization options specified in the command line arguments.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"# init atmos model component\natmos_sim = atmos_init(FT, config_dict_atmos);\nthermo_params = get_thermo_params(atmos_sim) # TODO: this should be shared by all models","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"We use a common Space for all global surfaces. This enables the MPI processes to operate on the same columns in both the atmospheric and surface components, so exchanges are parallelized. Note this is only possible when the atmosphere and surface are of the same horizontal resolution.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"# init a 2D boundary space at the surface\nboundary_space = atmos_sim.domain.face_space.horizontal_space","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"init land-sea fraction","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"land_fraction =\n    Regridder.land_fraction(FT, REGRID_DIR, comms_ctx, land_mask_data, \"LSMASK\", boundary_space, mono = mono_surface)","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Land","page":"AMIP Driver","title":"Land","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"We use ClimaLSM.jl's bucket model.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"land_sim = bucket_init(\n    FT,\n    FT.(tspan),\n    config_dict[\"land_domain_type\"],\n    config_dict[\"land_albedo_type\"],\n    comms_ctx,\n    REGRID_DIR;\n    dt = FT(Δt_cpl),\n    space = boundary_space,\n    saveat = FT(saveat),\n    area_fraction = land_fraction,\n    date_ref = date0,\n    t_start = FT(0),\n)","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Ocean-and-Sea-Ice","page":"AMIP Driver","title":"Ocean and Sea Ice","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"In the AMIP mode, all ocean properties are prescribed from a file, while sea-ice temperatures are calculated using observed SIC and assuming a 2m thickness of the ice.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"In the SlabPlanet mode, all ocean and sea ice are dynamical models, namely thermal slabs, with different parameters.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"@info mode_name\nif mode_name == \"amip\"\n    @info \"AMIP boundary conditions - do not expect energy conservation\"\n\n    # ocean\n    SST_info = bcfile_info_init(\n        FT,\n        REGRID_DIR,\n        sst_data,\n        \"SST\",\n        boundary_space,\n        comms_ctx,\n        interpolate_daily = true,\n        scaling_function = clean_sst, ## convert to Kelvin\n        land_fraction = land_fraction,\n        date0 = date0,\n        mono = mono_surface,\n    )\n\n    update_midmonth_data!(date0, SST_info)\n    SST_init = interpolate_midmonth_to_daily(date0, SST_info)\n    ocean_sim = SurfaceStub((;\n        T_sfc = SST_init,\n        ρ_sfc = ClimaCore.Fields.zeros(boundary_space),\n        z0m = FT(1e-3),\n        z0b = FT(1e-3),\n        beta = FT(1),\n        α = FT(0.06),\n        area_fraction = (FT(1) .- land_fraction),\n        phase = TD.Liquid(),\n        thermo_params = thermo_params,\n    ))\n    # sea ice\n    SIC_info = bcfile_info_init(\n        FT,\n        REGRID_DIR,\n        sic_data,\n        \"SEAICE\",\n        boundary_space,\n        comms_ctx,\n        interpolate_daily = true,\n        scaling_function = clean_sic, ## convert to fraction\n        land_fraction = land_fraction,\n        date0 = date0,\n        mono = mono_surface,\n    )\n    update_midmonth_data!(date0, SIC_info)\n    SIC_init = interpolate_midmonth_to_daily(date0, SIC_info)\n    ice_fraction = get_ice_fraction.(SIC_init, mono_surface)\n    ice_sim = ice_init(\n        FT;\n        tspan = tspan,\n        dt = Δt_cpl,\n        space = boundary_space,\n        saveat = saveat,\n        area_fraction = ice_fraction,\n        thermo_params = thermo_params,\n    )\n\n    # CO2 concentration\n    CO2_info = bcfile_info_init(\n        FT,\n        REGRID_DIR,\n        co2_data,\n        \"co2\",\n        boundary_space,\n        comms_ctx,\n        interpolate_daily = true,\n        land_fraction = ones(boundary_space),\n        date0 = date0,\n        mono = mono_surface,\n    )\n\n    update_midmonth_data!(date0, CO2_info)\n    CO2_init = interpolate_midmonth_to_daily(date0, CO2_info)\n    update_field!(atmos_sim, Val(:co2_gm), CO2_init)\n\n    mode_specifics = (; name = mode_name, SST_info = SST_info, SIC_info = SIC_info, CO2_info = CO2_info)\n\nelseif mode_name == \"slabplanet\"\n    # ocean\n    ocean_sim = ocean_init(\n        FT;\n        tspan = tspan,\n        dt = Δt_cpl,\n        space = boundary_space,\n        saveat = saveat,\n        area_fraction = (FT(1) .- land_fraction), ## NB: this ocean fraction includes areas covered by sea ice (unlike the one contained in the cs)\n        thermo_params = thermo_params,\n    )\n\n    # sea ice (here set to zero area coverage)\n    ice_sim = SurfaceStub((;\n        T_sfc = ClimaCore.Fields.ones(boundary_space),\n        ρ_sfc = ClimaCore.Fields.zeros(boundary_space),\n        z0m = FT(0),\n        z0b = FT(0),\n        beta = FT(1),\n        α = FT(1),\n        area_fraction = ClimaCore.Fields.zeros(boundary_space),\n        phase = TD.Ice(),\n        thermo_params = thermo_params,\n    ))\n\n    mode_specifics = (; name = mode_name, SST_info = nothing, SIC_info = nothing)\n\nelseif mode_name == \"slabplanet_eisenman\"\n    # ocean\n    ocean_sim = ocean_init(\n        FT;\n        tspan = tspan,\n        dt = Δt_cpl,\n        space = boundary_space,\n        saveat = saveat,\n        area_fraction = ClimaCore.Fields.zeros(boundary_space), # zero, since ML is calculated below\n        thermo_params = thermo_params,\n    )\n\n    # sea ice (here set to zero area coverage)\n    ice_sim = eisenman_seaice_init(\n        FT,\n        tspan,\n        space = boundary_space,\n        area_fraction = (FT(1) .- land_fraction),\n        dt = Δt_cpl,\n        saveat = saveat,\n        thermo_params = thermo_params,\n    )\n\n    mode_specifics = (; name = mode_name, SST_info = nothing, SIC_info = nothing)\nend","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Coupler-Initialization","page":"AMIP Driver","title":"Coupler Initialization","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"The coupler needs to contain exchange information, manage the calendar and be able to access all component models. It can also optionally save online diagnostics. These are all initialized here and saved in a global CouplerSimulation struct, cs.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"# coupler exchange fields\ncoupler_field_names = (\n    :T_S,\n    :z0m_S,\n    :z0b_S,\n    :ρ_sfc,\n    :q_sfc,\n    :albedo,\n    :beta,\n    :F_turb_energy,\n    :F_turb_moisture,\n    :F_turb_ρτxz,\n    :F_turb_ρτyz,\n    :F_radiative,\n    :P_liq,\n    :P_snow,\n    :F_radiative_TOA,\n    :P_net,\n)\ncoupler_fields =\n    NamedTuple{coupler_field_names}(ntuple(i -> ClimaCore.Fields.zeros(boundary_space), length(coupler_field_names)))\n\n# model simulations\nmodel_sims = (atmos_sim = atmos_sim, ice_sim = ice_sim, land_sim = land_sim, ocean_sim = ocean_sim);\n\n# dates\ndates = (; date = [date], date0 = [date0], date1 = [Dates.firstdayofmonth(date0)], new_month = [false])","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Online-Diagnostics","page":"AMIP Driver","title":"Online Diagnostics","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"User can write custom diagnostics in the user_diagnostics.jl.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"monthly_3d_diags = init_diagnostics(\n    (:T, :u, :q_tot, :q_liq_ice),\n    atmos_sim.domain.center_space;\n    save = Monthly(),\n    operations = (; accumulate = TimeMean([Int(0)])),\n    output_dir = COUPLER_OUTPUT_DIR,\n    name_tag = \"monthly_mean_3d_\",\n)\n\nmonthly_2d_diags = init_diagnostics(\n    (:precipitation_rate, :toa_fluxes, :T_sfc, :tubulent_energy_fluxes),\n    boundary_space;\n    save = Monthly(),\n    operations = (; accumulate = TimeMean([Int(0)])),\n    output_dir = COUPLER_OUTPUT_DIR,\n    name_tag = \"monthly_mean_2d_\",\n)\n\ndiagnostics = (monthly_3d_diags, monthly_2d_diags)","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Initialize-Conservation-Checks","page":"AMIP Driver","title":"Initialize Conservation Checks","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"# init conservation info collector\nconservation_checks = nothing\nif energy_check\n    @assert(\n        mode_name[1:10] == \"slabplanet\" && !CA.is_distributed(ClimaComms.context(boundary_space)),\n        \"Only non-distributed slabplanet allowable for energy_check\"\n    )\n    conservation_checks = (; energy = EnergyConservationCheck(model_sims), water = WaterConservationCheck(model_sims))\nend\n\n# coupler simulation\ncs = CoupledSimulation{FT}(\n    comms_ctx,\n    dates,\n    boundary_space,\n    coupler_fields,\n    config_dict,\n    conservation_checks,\n    [tspan[1], tspan[2]],\n    atmos_sim.integrator.t,\n    Δt_cpl,\n    (; land = land_fraction, ocean = zeros(boundary_space), ice = zeros(boundary_space)),\n    model_sims,\n    mode_specifics,\n    diagnostics,\n);","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Restart-component-model-states-if-specified","page":"AMIP Driver","title":"Restart component model states if specified","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"if restart_dir !== \"unspecified\"\n    for sim in cs.model_sims\n        if get_model_state_vector(sim) !== nothing\n            restart_model_state!(sim, comms_ctx, restart_t; input_dir = restart_dir)\n        end\n    end\nend","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Initialize-Component-Model-Exchange","page":"AMIP Driver","title":"Initialize Component Model Exchange","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"turbulent_fluxes = nothing\nif config_dict[\"turb_flux_partition\"] == \"PartitionedStateFluxes\"\n    turbulent_fluxes = PartitionedStateFluxes()\nelseif config_dict[\"turb_flux_partition\"] == \"CombinedStateFluxes\"\n    turbulent_fluxes = CombinedStateFluxes()\nelse\n    error(\"turb_flux_partition must be either PartitionedStateFluxes or CombinedStateFluxes\")\nend","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"coupler combines surface states and calculates rho_sfc using surface and atmos variables","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"update_surface_fractions!(cs)\nimport_combined_surface_fields!(cs.fields, cs.model_sims, cs.boundary_space, turbulent_fluxes)\nimport_atmos_fields!(cs.fields, cs.model_sims, cs.boundary_space, turbulent_fluxes)\nupdate_model_sims!(cs.model_sims, cs.fields, turbulent_fluxes)","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"each surface component model calculates its own vapor specific humidity (q_sfc)","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"TODO: the qsfc calculation follows the design of the bucket qsfc, but it would be neater to abstract this from step!","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"step!(land_sim, Δt_cpl)\nstep!(ocean_sim, Δt_cpl)\nstep!(ice_sim, Δt_cpl)","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"coupler re-imports updated surface fields and calculates turbulent fluxes, while updating atmos sfc_conditions","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"if turbulent_fluxes isa CombinedStateFluxes","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"calculate fluxes using combined surface states on the atmos grid","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"    import_combined_surface_fields!(cs.fields, cs.model_sims, cs.boundary_space, turbulent_fluxes) # i.e. T_sfc, albedo, z0, beta, q_sfc\n    combined_turbulent_fluxes!(cs.model_sims, cs.fields, turbulent_fluxes) # this updates the atmos thermo state, sfc_ts\nelseif turbulent_fluxes isa PartitionedStateFluxes","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"calculate turbulent fluxes in surface models and save the weighted average in coupler fields","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"    partitioned_turbulent_fluxes!(cs.model_sims, cs.fields, cs.boundary_space, MoninObukhovScheme(), thermo_params)","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"update atmos sfc_conditions for surface temperature TODO: this is hard coded and needs to be simplified (need CA modification)","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"    new_p = get_new_cache(atmos_sim, cs.fields)\n    CA.SurfaceConditions.update_surface_conditions!(atmos_sim.integrator.u, new_p, atmos_sim.integrator.t) # sets T_sfc (but SF calculation not necessary - CA)\n    atmos_sim.integrator.p.sfc_conditions .= new_p.sfc_conditions\nend","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"given the new sfc_conditions, atmos calls the radiative flux callback","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"reinit_model_sims!(cs.model_sims) # NB: for atmos this sets a nonzero radiation flux","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"coupler re-imports updated atmos fluxes (radiative fluxes for both turbulent_fluxes types","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"and also turbulent fluxes if turbulent_fluxes isa CombinedStateFluxes, and sends them to the surface component models. If turbulent_fluxes isa PartitionedStateFluxes atmos receives the turbulent fluxes from the coupler.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"import_atmos_fields!(cs.fields, cs.model_sims, cs.boundary_space, turbulent_fluxes)\nupdate_model_sims!(cs.model_sims, cs.fields, turbulent_fluxes)","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Coupling-Loop","page":"AMIP Driver","title":"Coupling Loop","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"function solve_coupler!(cs)\n    @info \"Starting coupling loop\"\n\n    @unpack model_sims, Δt_cpl, tspan = cs\n    @unpack atmos_sim, land_sim, ocean_sim, ice_sim = model_sims\n\n    # step in time\n    walltime = @elapsed for t in ((tspan[1] + Δt_cpl):Δt_cpl:tspan[end])\n\n        cs.dates.date[1] = current_date(cs, t) # if not global, `date` is not updated.\n\n        # print date on the first of month\n        if cs.dates.date[1] >= cs.dates.date1[1]\n            @show(cs.dates.date[1])\n        end\n\n        if cs.mode.name == \"amip\"\n\n            # monthly read of boundary condition data for SST and SIC and CO2\n            if cs.dates.date[1] >= next_date_in_file(cs.mode.SST_info)\n                update_midmonth_data!(cs.dates.date[1], cs.mode.SST_info)\n            end\n            SST_current = interpolate_midmonth_to_daily(cs.dates.date[1], cs.mode.SST_info)\n            update_field!(ocean_sim, Val(:surface_temperature), SST_current)\n\n            if cs.dates.date[1] >= next_date_in_file(cs.mode.SIC_info)\n                update_midmonth_data!(cs.dates.date[1], cs.mode.SIC_info)\n            end\n            SIC_current =\n                get_ice_fraction.(interpolate_midmonth_to_daily(cs.dates.date[1], cs.mode.SIC_info), mono_surface)\n            update_field!(ice_sim, Val(:area_fraction), SIC_current)\n\n            if cs.dates.date[1] >= next_date_in_file(cs.mode.CO2_info)\n                update_midmonth_data!(cs.dates.date[1], cs.mode.CO2_info)\n            end\n            CO2_current = interpolate_midmonth_to_daily(cs.dates.date[1], cs.mode.CO2_info)\n            update_field!(atmos_sim, Val(:co2_gm), CO2_current)\n\n            # calculate and accumulate diagnostics at each timestep\n            ClimaComms.barrier(comms_ctx)\n            accumulate_diagnostics!(cs)\n\n            # save and reset monthly averages\n            save_diagnostics(cs)\n\n        end\n\n        # compute global energy\n        !isnothing(cs.conservation_checks) ? check_conservation!(cs) : nothing\n\n        # run component models sequentially for one coupling timestep (Δt_cpl)\n        ClimaComms.barrier(comms_ctx)\n        update_model_sims!(cs.model_sims, cs.fields, turbulent_fluxes)\n\n        # step sims\n        step_model_sims!(cs.model_sims, t)\n\n        # exchange combined fields and (if specified) calculate fluxes using combined states\n        update_surface_fractions!(cs)\n        import_combined_surface_fields!(cs.fields, cs.model_sims, cs.boundary_space, turbulent_fluxes) # i.e. T_sfc, albedo, z0, beta\n        if turbulent_fluxes isa CombinedStateFluxes\n            combined_turbulent_fluxes!(cs.model_sims, cs.fields, turbulent_fluxes) # this updates the surface thermo state, sfc_ts, in ClimaAtmos (but also unnecessarily calculates fluxes)\n        elseif turbulent_fluxes isa PartitionedStateFluxes","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"calculate turbulent fluxes in surfaces and save the weighted average in coupler fields","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"            partitioned_turbulent_fluxes!(cs.model_sims, cs.fields, cs.boundary_space, MoninObukhovScheme(), thermo_params)","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"update atmos sfc_conditions for surface temperature - TODO: this needs to be simplified (need CA modification)","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"            new_p = get_new_cache(atmos_sim, cs.fields)\n            CA.SurfaceConditions.update_surface_conditions!(atmos_sim.integrator.u, new_p, atmos_sim.integrator.t) # to set T_sfc (but SF calculation not necessary - CA modification)\n            atmos_sim.integrator.p.sfc_conditions .= new_p.sfc_conditions\n        end\n\n        import_atmos_fields!(cs.fields, cs.model_sims, cs.boundary_space, turbulent_fluxes) # radiative and/or turbulent\n\n        # monthly callbacks\n        if trigger_callback(cs, Monthly())\n            # step to the next calendar month\n            cs.dates.date1[1] += Dates.Month(1)\n            # checkpoint model state\n            if monthly_checkpoint\n                for sim in cs.model_sims\n                    if get_model_state_vector(sim) !== nothing\n                        checkpoint_model_state(sim, comms_ctx, Int(t), output_dir = COUPLER_ARTIFACTS_DIR)\n                    end\n                end\n            end\n        end\n\n    end\n    @show walltime\n\n    return cs\nend\n\n\n# run the coupled simulation\nsolve_coupler!(cs);","category":"page"},{"location":"generated/amip/coupler_driver_modular/#Postprocessing","page":"AMIP Driver","title":"Postprocessing","text":"","category":"section"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"Currently all postprocessing is performed using the root process only.","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"if ClimaComms.iamroot(comms_ctx)\n\n    # energy check plots\n    if !isnothing(cs.conservation_checks) && cs.mode.name[1:10] == \"slabplanet\"\n        @info \"Conservation Check Plots\"\n        plot_global_conservation(\n            cs.conservation_checks.energy,\n            cs,\n            figname1 = joinpath(COUPLER_ARTIFACTS_DIR, \"total_energy_bucket.png\"),\n            figname2 = joinpath(COUPLER_ARTIFACTS_DIR, \"total_energy_log_bucket.png\"),\n        )\n        plot_global_conservation(\n            cs.conservation_checks.water,\n            cs,\n            figname1 = joinpath(COUPLER_ARTIFACTS_DIR, \"total_water_bucket.png\"),\n            figname2 = joinpath(COUPLER_ARTIFACTS_DIR, \"total_water_log_bucket.png\"),\n        )\n    end\n\n    # sample animations\n    if !is_distributed && config_dict[\"anim\"]\n        @info \"Animations\"\n        include(\"user_io/viz_explorer.jl\")\n        plot_anim(cs, COUPLER_ARTIFACTS_DIR)\n    end\n\n    # plotting AMIP results\n    if cs.mode.name == \"amip\"\n        @info \"AMIP plots\"\n\n        # ClimaESM\n        include(\"user_io/amip_visualizer.jl\")\n        post_spec = (;\n            T = (:regrid, :zonal_mean),\n            u = (:regrid, :zonal_mean),\n            q_tot = (:regrid, :zonal_mean),\n            toa_fluxes = (:regrid, :horizontal_slice),\n            precipitation_rate = (:regrid, :horizontal_slice),\n            T_sfc = (:regrid, :horizontal_slice),\n            tubulent_energy_fluxes = (:regrid, :horizontal_slice),\n            q_liq_ice = (:regrid, :zonal_mean),\n        )\n\n        plot_spec = (;\n            T = (; clims = (190, 320), units = \"K\"),\n            u = (; clims = (-50, 50), units = \"m/s\"),\n            q_tot = (; clims = (0, 30), units = \"g/kg\"),\n            toa_fluxes = (; clims = (-250, 250), units = \"W/m^2\"),\n            precipitation_rate = (clims = (0, 1e-4), units = \"kg/m^2/s\"),\n            T_sfc = (clims = (225, 310), units = \"K\"),\n            tubulent_energy_fluxes = (; clims = (-250, 250), units = \"W/m^2\"),\n            q_liq_ice = (; clims = (0, 10), units = \"g/kg\"),\n        )\n        amip_data = amip_paperplots(\n            post_spec,\n            plot_spec,\n            COUPLER_OUTPUT_DIR,\n            files_root = \".monthly\",\n            output_dir = COUPLER_ARTIFACTS_DIR,\n        )\n\n        # NCEP reanalysis\n        @info \"NCEP plots\"\n        include(\"user_io/ncep_visualizer.jl\")\n        ncep_post_spec = (;\n            T = (:zonal_mean,),\n            u = (:zonal_mean,),\n            q_tot = (:zonal_mean,),\n            toa_fluxes = (:horizontal_slice,),\n            precipitation_rate = (:horizontal_slice,),\n            T_sfc = (:horizontal_slice,),\n            tubulent_energy_fluxes = (:horizontal_slice,),\n        )\n        ncep_plot_spec = plot_spec\n        ncep_data = ncep_paperplots(\n            ncep_post_spec,\n            ncep_plot_spec,\n            COUPLER_OUTPUT_DIR,\n            output_dir = COUPLER_ARTIFACTS_DIR,\n            month_date = cs.dates.date[1],\n        ) ## plot data that correspond to the model's last save_hdf5 call (i.e., last month)\n    end\n\n    # clean up\n    rm(COUPLER_OUTPUT_DIR; recursive = true, force = true)\nend","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"","category":"page"},{"location":"generated/amip/coupler_driver_modular/","page":"AMIP Driver","title":"AMIP Driver","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/sea_breeze/run/#Coupled-Sea-Breeze","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"","category":"section"},{"location":"generated/sea_breeze/run/#Overview","page":"Coupled Sea Breeze","title":"Overview","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"This sea breeze simulation consists of an atmosphere above ocean and land thermal slabs. The difference in heating between the land and ocean components drives circulation: cool ocean air flows towards the land at the surface while warm air over land rises and flows over the ocean.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"In this tutorial we demonstrate the coupling of three component models (atmosphere, ocean, and land) to drive the sea breeze. The primary parts of the ClimaCoupler interface are used and discussed.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Load utilities for running coupled simulation","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"include(\"../CoupledSims/coupled_sim.jl\")\n\nimport ClimaCore.Spaces as Spaces","category":"page"},{"location":"generated/sea_breeze/run/#Model-Initialization","page":"Coupled Sea Breeze","title":"Model Initialization","text":"","category":"section"},{"location":"generated/sea_breeze/run/#Component-Models","page":"Coupled Sea Breeze","title":"Component Models","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Component models are the building blocks of coupled models. They are often developed independently from one another and can be executed by themselves as \"standalone\" simulations. The coupler is used to combine these components into coupled simulations. Importantly, coupled simulations can re-use tendency methods developed for standalone simulations, maximizing code reuse and minimizing the necessary code that must be specialized for a coupled run–only special boundary conditions must be written. This is achieved by multiple dispatch, where methods that deal with boundaries dispatch off of a coupled boundary type. Here, the atmosphere has special boundary conditions for coupling while the ocean and land tendencies are unaltered. See the atmospheric model page for more details.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"In a more mature CliMA ecosystem, the following include statements would be replaced by using statements for the relevant component packages.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"include(\"atmos_rhs.jl\")\ninclude(\"ocean_rhs.jl\")\ninclude(\"land_rhs.jl\")\n\n# model parameters\nconst atm_T_ini = FT(270.0)\nconst MSLP = FT(1e5)\nconst grav = FT(9.8)\nconst R_d = FT(287.058)\nconst γ = FT(1.4)\nconst C_p = FT(R_d * γ / (γ - 1))\nconst C_v = FT(R_d / (γ - 1))\nconst R_m = R_d\ncpl_parameters = (\n    # atmos parameters\n    atm_μ = FT(0.0001), # diffusion coefficient\n    atm_T_top = FT(280.0), # fixed temperature at the top of the domain_atm\n    atm_T_ini = atm_T_ini, # initial condition of at temperature (isothermal) [K]\n    MSLP = MSLP, # mean sea level pressure\n    grav = grav, # gravitational constant\n    R_d = R_d, # R dry (gas constant / mol mass dry air)\n    γ = γ, # heat capacity ratio\n    C_p = C_p, # heat capacity at constant pressure\n    C_v = C_v, # heat capacity at constant volume\n    R_m = R_m, # moist R, assumed to be dry\n    # land slab parameters\n    lnd_h = FT(0.5), # depth of slab layer [m]\n    lnd_ρ = FT(1500), # density [kg m^-3]\n    lnd_c = FT(800), # specific heat [J K^-1 kg^-1]\n    lnd_T_ini = FT(260.0), # initial condition of at temperature (isothermal) [K]\n    # ocean slab parameters\n    ocn_h = FT(0.5), # depth of slab layer [m]\n    ocn_ρ = FT(1025), # density [kg m^-3]\n    ocn_c = FT(3850), # specific heat [J K^-1 kg^-1]\n    ocn_T_ini = FT(260.0), # initial condition of at temperature (isothermal) [K]\n    # coupling parameters\n    C_H = FT(0.0015),\n)\n\n# DSS callback\nfunction make_dss_func()\n    function _dss!(x::Fields.Field)\n        Spaces.weighted_dss!(x)\n    end\n    function _dss!(::Any)\n        nothing\n    end\n    dss_func(Y, t, integrator) = foreach(_dss!, Fields._values(Y))\n    return dss_func\nend\ndss_func = make_dss_func()\ndss_callback = FunctionCallingCallback(dss_func, func_start = true)","category":"page"},{"location":"generated/sea_breeze/run/#Initialization","page":"Coupled Sea Breeze","title":"Initialization","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"The coupled simulation synchronizes the component models at a coupling time step, Δt_cpl. Within that step, components may substep - each component specifies a number of substeps to take within Δt_cpl: atm_nsteps, ocn_nsteps, lnd_nsteps.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Component model states are initialized via the initialization methods each component would use in standalone mode. These states will be modified to reflect the full coupled system before executing the simulation.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"@info \"Init Models and Maps\"\n\nt_start, t_end = (0.0, 1.0)\nΔt_coupled = 0.1\nsaveat = 1e2\natm_nsteps, ocn_nsteps, lnd_nsteps = (5, 1, 1)\n\n# Initialize Models\natm_Y_default, atm_bc, atm_domain = atm_init(\n    xmin = -500,\n    xmax = 500,\n    zmin = 0,\n    zmax = 1000,\n    npoly = 4,\n    helem = 20,\n    velem = 20,\n    bc = (ρθ = (bottom = CoupledFlux(), top = ZeroFlux()),),\n)\n\nocn_Y_default, ocn_domain = ocn_init(xmin = -500, xmax = 0, helem = 10, npoly = 0)\n\nlnd_Y_default, lnd_domain = lnd_init(xmin = 0, xmax = 500, helem = 10, npoly = 0)","category":"page"},{"location":"generated/sea_breeze/run/#Remapping","page":"Coupled Sea Breeze","title":"Remapping","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Because models may live on different grids, remapping is necessary at the boundaries. Maps between coupled components must be constructed for each interacting pair. Remapping utilities are imported from ClimaCore.Operators.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"atm_boundary = Spaces.level(atm_domain.hv_face_space, PlusHalf(0))\n\nmaps = (\n    atmos_to_ocean = Operators.LinearRemap(ocn_domain, atm_boundary),\n    atmos_to_land = Operators.LinearRemap(lnd_domain, atm_boundary),\n    ocean_to_atmos = Operators.LinearRemap(atm_boundary, ocn_domain),\n    land_to_atmos = Operators.LinearRemap(atm_boundary, lnd_domain),\n)\n\n# initialize coupling fields\natm_T_sfc =\n    Operators.remap(maps.ocean_to_atmos, ocn_Y_default.T_sfc) .+\n    Operators.remap(maps.land_to_atmos, lnd_Y_default.T_sfc) # masked arrays; regrid to atm grid\natm_F_sfc = Fields.zeros(atm_boundary)\nocn_F_sfc = Fields.zeros(ocn_domain)\nlnd_F_sfc = Fields.zeros(lnd_domain)","category":"page"},{"location":"generated/sea_breeze/run/#Simulations","page":"Coupled Sea Breeze","title":"Simulations","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Each component is wrapped as a Sim, which contains both the model (tendency) and the time-stepping information (solver, step size, etc). Sims are the standard structures that the coupler works with, enabling dispatch of coupler methods. Here, we create three simulations: AtmosSim, OceanSim, and LandSim.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"atm_Y = Fields.FieldVector(Yc = atm_Y_default.Yc, ρw = atm_Y_default.ρw, F_sfc = atm_F_sfc)\natm_p = (cpl_p = cpl_parameters, T_sfc = atm_T_sfc, bc = atm_bc)\natmos = AtmosSim(atm_Y, t_start, Δt_coupled / atm_nsteps, t_end, SSPRK33(), atm_p, saveat, dss_callback)\n\nocn_Y = Fields.FieldVector(T_sfc = ocn_Y_default.T_sfc)\nocn_p = (cpl_parameters, F_sfc = ocn_F_sfc)\nocean = OceanSim(ocn_Y, t_start, Δt_coupled / ocn_nsteps, t_end, SSPRK33(), ocn_p, saveat)\n\nlnd_Y = Fields.FieldVector(T_sfc = lnd_Y_default.T_sfc)\nlnd_p = (cpl_parameters, F_sfc = lnd_F_sfc)\nland = LandSim(lnd_Y, t_start, Δt_coupled / lnd_nsteps, t_end, SSPRK33(), lnd_p, saveat)","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Additionally, we create a coupled simulation that contains the component simulations and the coupled time-stepping information.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"struct AOLCoupledSim{A <: AtmosSim, O <: OceanSim, L <: LandSim, C <: CouplerState} <: AbstractCoupledSim\n    # Atmosphere Simulation\n    atmos::A\n    # Ocean Simulation\n    ocean::O\n    # Land Simulation\n    land::L\n    # Coupler storage\n    coupler::C\nend","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"step! is a key method within the Sims interface. It advances a simulation to the specified t_stop, with that simulation advancing by its own internal step size to reach the specified time. Each simulation type should specify its own step method, allowing components to have different time integration backends. Here, all components are using OrdinaryDiffEq integrators and can share the same step! method.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"function step!(sim::AbstractSim, t_stop)\n    Δt = t_stop - sim.integrator.t\n    SciMLBase.step!(sim.integrator)\nend","category":"page"},{"location":"generated/sea_breeze/run/#The-Coupler","page":"Coupled Sea Breeze","title":"The Coupler","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"The CouplerState is a coupling struct used to store pointers or copies of the shared boundary information. All components are coupled by updating or accessing data in this CouplerState; component models do not directly interface with one another, only through the coupler.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"After creating the CouplerState object, coupled fields can be registered index the coupler via the coupler_add_field! method. This field is then accessible by coupler_get methods and can be updated via the coupler_put! methods.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Similarly, the coupler_add_map! method registers remapping operators in the coupler. To provide automatic remapping, there is a strict name convention for remap operators: a map from SimA to SimB (where ClimaCoupler.name returns :simA and :simB, respectively) must be named simA_to_simB so that the correct operator can be used.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Here, the models are coupled through heat transfer at the surface. This heat flux is computed by a bulk formula:","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"F_sfc = c_p rho_1 C_H u_1 (theta_sfc - theta_atm1)","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"where theta_sfc is the potential temperature at the land or ocean surface, theta_atm1 is the potential temperature at the lowest atmospheric level, c_p is the specific heat, C_H = 00015 is the bulk transfer coefficient for sensible heat, and u_1 is the near-surface atmospheric wind speed. We assume that the potential temperature is defined with respect to the surface pressure, so that theta_sfc = T_sfc.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"coupler = CouplerState(Δt_coupled)\ncoupler_add_field!(coupler, :T_sfc_ocean, ocean.integrator.u.T_sfc; write_sim = ocean)\ncoupler_add_field!(coupler, :T_sfc_land, land.integrator.u.T_sfc; write_sim = land)\ncoupler_add_field!(coupler, :F_sfc, atmos.integrator.u.F_sfc; write_sim = atmos)\nfor (name, map) in pairs(maps)\n    coupler_add_map!(coupler, name, map)\nend\n\nsim = AOLCoupledSim(atmos, ocean, land, coupler)","category":"page"},{"location":"generated/sea_breeze/run/#Coupled-Time-Integration","page":"Coupled Sea Breeze","title":"Coupled Time Integration","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Finally, the execution sequence of the component models must be specified. This is currently done explicitly with a combination of step!, coupler_pull!, and coupler_push! methods. The coupler_pull! and coupler_push! methods receive and send coupled field info from the coupler, respectively. They must be written for each component simulation, and are simply collections of coupler_get and coupler_put! methods for each component.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Here, the atmosphere steps forward first and then sends updated fields to the coupler. The ocean and land (which are not coupled to each other) then retreive the updated coupled information, advance and send their own updates to the coupler.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Because the models exchange fluxes only at the coupled timestep, the surface flux is accumulated over the coupled time-step coupling time step, Δt_cpl","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"F_integ = int_Delta t_coupler F_sfc  dt","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"where  F_integ has units of J m^-2.","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"function cpl_run(simulation::AOLCoupledSim)\n    @info \"Run model\"\n    @unpack atmos, ocean, land, coupler = simulation\n    Δt_coupled = coupler.Δt_coupled\n    # coupler stepping\n    for t in ((t_start + Δt_coupled):Δt_coupled:t_end)\n        # Atmos\n        coupler_pull!(atmos, coupler)\n        step!(atmos, t)\n        coupler_push!(coupler, atmos)\n\n        # Ocean\n        coupler_pull!(ocean, coupler)\n        step!(ocean, t)\n        coupler_push!(coupler, ocean)\n\n        # Land\n        coupler_pull!(land, coupler)\n        step!(land, t)\n        coupler_push!(coupler, land)\n    end\n    @info \"Simulation Complete\"\nend\n\n# Run simulation\ncpl_run(sim)","category":"page"},{"location":"generated/sea_breeze/run/#References","page":"Coupled Sea Breeze","title":"References","text":"","category":"section"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"Antonelli & Rotunno 2007","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"","category":"page"},{"location":"generated/sea_breeze/run/","page":"Coupled Sea Breeze","title":"Coupled Sea Breeze","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fluxcalculator/#FluxCalculator","page":"FluxCalculator","title":"FluxCalculator","text":"","category":"section"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"This modules contains abstract types and functions to calculate surface fluxes in the coupler, or to call flux calculating functions from the component models.","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"Fluxes over a heterogeneous surface (e.g., from a gridpoint where atmospheric cell is overlying both land and ocean) can be handled in two different ways:","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"Combined fluxes (called with CombinedStateFluxes())","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"these are calculated by averaging the surface properties for each gridpoint (e.g., land and ocean temperatures, albedos and roughness lengths are averaged, based on their respective area fractions), so the flux is calculated only once per gridpoint of the grid where we calculate fluxes. This is computationally faster, but it makes the fluxes on surface boundaries more diffuse. Currently, we use this method for calculating radiative fluxes in the atmosphere, and turbulent fluxes in the coupler (on the atmospheric grid). The fluxes are calculated in the atmospheric (host) model's cache, which can be setup to avoid allocating coupler fields.","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"Partitioned fluxes (called with PartitionedStateFluxes())","category":"page"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"these are calculated separately for each surface type. It is then the fluxes (rather than the surface states) that are combined and passed to the atmospheric model as a boundary condition. This method ensures that each surface model receives fluxes that correspond to its state properties, resulting in a more accurate model evolution. However, it is more computationally expensive, and requires more communication between the component models.","category":"page"},{"location":"fluxcalculator/#FluxCalculator-API","page":"FluxCalculator","title":"FluxCalculator API","text":"","category":"section"},{"location":"fluxcalculator/","page":"FluxCalculator","title":"FluxCalculator","text":"    ClimaCoupler.FluxCalculator.TurbulentFluxPartition\n    ClimaCoupler.FluxCalculator.PartitionedStateFluxes\n    ClimaCoupler.FluxCalculator.CombinedStateFluxes\n    ClimaCoupler.FluxCalculator.combined_turbulent_fluxes!\n    ClimaCoupler.FluxCalculator.atmos_turbulent_fluxes!\n","category":"page"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.TurbulentFluxPartition","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.TurbulentFluxPartition","text":"TurbulentFluxPartition\n\nAbstract type for flags that denote where and how to calculate tubulent fluxes.\n\n\n\n\n\n","category":"type"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.PartitionedStateFluxes","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.PartitionedStateFluxes","text":"PartitionedStateFluxes <: TurbulentFluxPartition\n\nA flag indicating that the turbulent fluxes should be partitioned and calculated over each surface model and then combined. This is calculated on the coupler grid.\n\n\n\n\n\n","category":"type"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.CombinedStateFluxes","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.CombinedStateFluxes","text":"CombinedStateFluxes <: TurbulentFluxPartition\n\nA flag indicating that the turbulent fluxes (e.g. sensible and latent heat fluxes, drag and moisture fluxes) are to be  calculated on the Atmos grid, and saved in Atmos cache.\n\n\n\n\n\n","category":"type"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.combined_turbulent_fluxes!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.combined_turbulent_fluxes!","text":"combined_turbulent_fluxes!(model_sims, csf, turbulent_fluxes::TurbulentFluxPartition)\n\nCalls the method(s) which calculate turbulent surface fluxes from combined surface states in coupler fields, csf.\n\nArguments\n\nmodel_sims: [NamedTuple] containing ComponentModelSimulations.\ncsf: [NamedTuple] containing coupler fields.\nturbulent_fluxes: [TurbulentFluxPartition] denotes a flag for turbulent flux calculation.\n\n\n\n\n\n","category":"function"},{"location":"fluxcalculator/#ClimaCoupler.FluxCalculator.atmos_turbulent_fluxes!","page":"FluxCalculator","title":"ClimaCoupler.FluxCalculator.atmos_turbulent_fluxes!","text":"atmos_turbulent_fluxes!(sim::Interfacer.ComponentModelSimulation, csf)\n\nA function to calculate turbulent surface fluxes using the combined surface states. It is required that a method is defined for the given sim and that the fluxes are saved in that sim's cache. csf refers to the coupler fields.\n\nArguments\n\nsim: [Interfacer.ComponentModelSimulation] object containing the component model simulation.\ncsf: [NamedTuple] containing coupler fields.\n\nExample:\n\nfunction atmos_turbulent_fluxes!(atmos_sim::ClimaAtmosSimulation, csf)\n    atmos_sim.cache.flux .= atmos_sim.c .* (csf.T_S .- atmos_sim.temperature)\nend\n\n\n\n\n\n","category":"function"},{"location":"bcreader/#BCReader","page":"BCReader","title":"BCReader","text":"","category":"section"},{"location":"bcreader/","page":"BCReader","title":"BCReader","text":"This module coordinates reading of boundary conditions from NetCDF files, as well as regridding calls and temporal interpolations from monthly to daily intervals.","category":"page"},{"location":"bcreader/#BCReader-API","page":"BCReader","title":"BCReader API","text":"","category":"section"},{"location":"bcreader/","page":"BCReader","title":"BCReader","text":"ClimaCoupler.BCReader.BCFileInfo\nClimaCoupler.BCReader.bcfile_info_init\nClimaCoupler.BCReader.update_midmonth_data!\nClimaCoupler.BCReader.next_date_in_file\nClimaCoupler.BCReader.interpolate_midmonth_to_daily","category":"page"},{"location":"bcreader/#ClimaCoupler.BCReader.BCFileInfo","page":"BCReader","title":"ClimaCoupler.BCReader.BCFileInfo","text":"BCFileInfo\n\nStores information specific to each boundary condition from a file and each variable.\n\nInputs:\n\nbcfile_dir::b                   # directory of the BC file\ncomms_ctx::X                    # communication context used for MPI\nhdoutfileroot::S              # filename root for regridded data\nvarname::V                      # name of the variable\nall_dates::D                    # vector of all dates contained in the original data file\nmonthly_fields::C               # tuple of the two monthly fields, that will be used for the daily interpolation\nscaling_function::O             # function that scales, offsets or transforms the raw variable\nland_fraction::M                # fraction with 1 = 100% land, 0 = 100% ocean and/or sea-ice\nsegment_idx::Vector{Int}        # index of the monthly data in the file\nsegmentidx0::Vector{Int}       # `segmentidx` of the file data that is closest to date0\nsegment_length::Vector{Int}     # length of each month segment (used in the daily interpolation)\ninterpolate_daily::Bool         # switch to trigger daily interpolation\n\n\n\n\n\n","category":"type"},{"location":"bcreader/#ClimaCoupler.BCReader.bcfile_info_init","page":"BCReader","title":"ClimaCoupler.BCReader.bcfile_info_init","text":"bcfile_info_init(\n    FT,\n    bcfile_dir,\n    datafile_rll,\n    varname,\n    boundary_space,\n    comms_ctx;\n    interpolate_daily = false,\n    segment_idx0 = nothing,\n    scaling_function = no_scaling,\n    land_fraction = nothing,\n    date0 = nothing,\n    mono = true,\n)\n\nRegrids from lat-lon grid to cgll grid, saving the output in a new file, and returns the info packaged in a single struct.\n\nArguments\n\nFT: [DataType] Float type.\nbcfile_dir: [String] directory the BC file is stored in.\ndatafile_rll: [String] file containing data to regrid.\nvarname: [String] name of the variable to be regridded.\nboundary_space: [Spaces.AbstractSpace] the space to which we are mapping.\ncomms_ctx: [ClimaComms.AbstractCommsContext] context used for this operation.\ninterpolate_daily: [Bool] switch to trigger daily interpolation.\nsegment_idx0: [Vector{Int}] index of the file data that is closest to date0.\nscaling function: [Function] scales, offsets or transforms varname.\nland_fraction: [Fields.field] fraction with 1 = land, 0 = ocean / sea-ice.\ndate0: [Dates.DateTime] start date of the file data.\nmono: [Bool] flag for monotone remapping of datafile_rll.\n\nReturns\n\nBCFileInfo\n\n\n\n\n\n","category":"function"},{"location":"bcreader/#ClimaCoupler.BCReader.update_midmonth_data!","page":"BCReader","title":"ClimaCoupler.BCReader.update_midmonth_data!","text":"update_midmonth_data!(date, bcf_info::BCFileInfo{FT}) where {FT}\n\nExtracts boundary condition data from regridded (to model grid) NetCDF files. The times for which data is extracted depends on the specifications in the bcf_info struct).\n\nArguments\n\ndate: [Dates.DateTime] start date for data.\nbcf_info: [BCFileInfo] containing boundary condition data.\n\n\n\n\n\n","category":"function"},{"location":"bcreader/#ClimaCoupler.BCReader.next_date_in_file","page":"BCReader","title":"ClimaCoupler.BCReader.next_date_in_file","text":"next_date_in_file(bcf_info)\n\nReturns the next date stored in the file bcfile_info struct after the current date index given by segment_idx. Note: this function does not update segment_idx, so repeated calls will return the same value unless segment_idx is modified elsewhere in between.\n\nArguments\n\nbcf_info: [BCFileInfo] containing the date information.\n\nReturns\n\nDates.DateTime\n\n\n\n\n\n","category":"function"},{"location":"bcreader/#ClimaCoupler.BCReader.interpolate_midmonth_to_daily","page":"BCReader","title":"ClimaCoupler.BCReader.interpolate_midmonth_to_daily","text":"interpolate_midmonth_to_daily(date, bcf_info::BCFileInfo{FT}) where {FT}\n\nInterpolates linearly between two Fields in the bcf_info struct, or returns the first Field if interpolation is switched off.\n\nArguments\n\ndate: [Dates.DateTime] start date for data.\nbcf_info: [BCFileInfo] contains fields to be interpolated.\n\nReturns\n\nFields.field\n\n\n\n\n\n","category":"function"},{"location":"bcreader/#BCReader-Internal-Functions","page":"BCReader","title":"BCReader Internal Functions","text":"","category":"section"},{"location":"bcreader/","page":"BCReader","title":"BCReader","text":"ClimaCoupler.BCReader.no_scaling\nClimaCoupler.BCReader.interpol","category":"page"},{"location":"bcreader/#ClimaCoupler.BCReader.no_scaling","page":"BCReader","title":"ClimaCoupler.BCReader.no_scaling","text":"no_scaling(field, bcf_info)\n\nRemap the values of a field onto the space of the bcf_info's land_fraction without scaling.\n\nArguments\n\nfield: [Fields.Field] contains the values to be remapped.\nbcf_info: [BCFileInfo] contains a land_fraction to remap onto the space of.\n\n\n\n\n\n","category":"function"},{"location":"bcreader/#ClimaCoupler.BCReader.interpol","page":"BCReader","title":"ClimaCoupler.BCReader.interpol","text":"interpol(f1::FT, f2::FT, Δt_tt1::FT, Δt_t2t1::FT)\n\nPerforms linear interpolation of f at time t within a segment Δt_t2t1 = (t2 - t1), of fields f1 and f2, with t2 > t1.\n\nArguments\n\nf1: [FT] first value to be interpolated (f(t1) = f1).\nf2: [FT] second value to be interpolated.\nΔt_tt1: [FT] time between t1 and some t (Δt_tt1 = (t - t1)).\nΔt_t2t1: [FT] time between t1 and t2.\n\nReturns\n\nFT\n\n\n\n\n\n","category":"function"},{"location":"testhelper/#TestHelper","page":"TestHelper","title":"TestHelper","text":"","category":"section"},{"location":"testhelper/","page":"TestHelper","title":"TestHelper","text":"This module defines helper functions, objects, and constants to be used by various files in the test folder.","category":"page"},{"location":"testhelper/#TestHelper-API","page":"TestHelper","title":"TestHelper API","text":"","category":"section"},{"location":"testhelper/","page":"TestHelper","title":"TestHelper","text":"ClimaCoupler.TestHelper.create_space\nClimaCoupler.TestHelper.gen_ncdata","category":"page"},{"location":"testhelper/#ClimaCoupler.TestHelper.create_space","page":"TestHelper","title":"ClimaCoupler.TestHelper.create_space","text":"create_space(FT; comms_ctx = ClimaComms.SingletonCommsContext(), \n    R = FT(6371e3), ne = 4, polynomial_degree = 3, nz = 1)\n\nInitialize a space on a sphere with the given parameters. Used for debugging and testing.\n\nArguments\n\nFT: [DataType] Float type\ncomms_ctx: [ClimaComms.AbstractCommsContext] context used for this operation.\nR: [FT] radius of the sphere underlying space.\nne: [Integer] number of elements used in the space's mesh.\npolynomial_degree: [Integer] degree of the polynomial used to represent   the space (number of GLL nodes - 1).\nnz: [Integer] number of vertical elements\n\n\n\n\n\n","category":"function"},{"location":"testhelper/#ClimaCoupler.TestHelper.gen_ncdata","page":"TestHelper","title":"ClimaCoupler.TestHelper.gen_ncdata","text":"gen_ncdata(FT, path, varname, val)\n\nCreate an NCDataset with lat/lon dimensions containing the value val for the variable varname, and store it at path.\n\nArguments\n\nFT: [DataType] Float type.\npath: [String] location to store output datafile.\nvarname: [Symbol] variable name.\nval: [FT] value to store as varname at all indices.\n\n\n\n\n\n","category":"function"},{"location":"regridder/#Regridder","page":"Regridder","title":"Regridder","text":"","category":"section"},{"location":"regridder/","page":"Regridder","title":"Regridder","text":"This module contains functions to regrid information between spaces. Many of the functions used in this module call TempestRemap functions via ClimaCoreTempestRemap wrappers.","category":"page"},{"location":"regridder/","page":"Regridder","title":"Regridder","text":"Information about the TempestRemap library can be found here. Multiple remapping approaches from TempestRemap have been tested with our implementation, and information about them is located here.","category":"page"},{"location":"regridder/#Regridder-API","page":"Regridder","title":"Regridder API","text":"","category":"section"},{"location":"regridder/","page":"Regridder","title":"Regridder","text":"ClimaCoupler.Regridder.write_to_hdf5\nClimaCoupler.Regridder.read_from_hdf5\nClimaCoupler.Regridder.dummmy_remap!\nClimaCoupler.Regridder.remap_field_cgll_to_rll\nClimaCoupler.Regridder.land_fraction\nClimaCoupler.Regridder.update_surface_fractions!\nClimaCoupler.Regridder.combine_surfaces!","category":"page"},{"location":"regridder/#ClimaCoupler.Regridder.write_to_hdf5","page":"Regridder","title":"ClimaCoupler.Regridder.write_to_hdf5","text":"write_to_hdf5(REGRID_DIR, hd_outfile_root, time, field, varname, comms_ctx)\n\nFunction to save individual HDF5 files after remapping. If a CommsContext other than SingletonCommsContext is used for comms_ctx, the HDF5 output is readable by multiple MPI processes.\n\nArguments\n\nREGRID_DIR: [String] directory to save output files in.\nhd_outfile_root: [String] root of the output file name.\ntime: [Dates.DateTime] the timestamp of the data being written.\nfield: [Fields.Field] object to be written.\nvarname: [String] variable name of data.\ncomms_ctx: [ClimaComms.AbstractCommsContext] context used for this operation.\n\n\n\n\n\n","category":"function"},{"location":"regridder/#ClimaCoupler.Regridder.read_from_hdf5","page":"Regridder","title":"ClimaCoupler.Regridder.read_from_hdf5","text":"read_from_hdf5(REGIRD_DIR, hd_outfile_root, time, varname, comms_ctx)\n\nRead in a variable varname from an HDF5 file. If a CommsContext other than SingletonCommsContext is used for comms_ctx, the input HDF5 file must be readable by multiple MPI processes.\n\nArguments\n\nREGRID_DIR: [String] directory to save output files in.\nhd_outfile_root: [String] root of the output file name.\ntime: [Dates.DateTime] the timestamp of the data being written.\nvarname: [String] variable name of data.\ncomms_ctx: [ClimaComms.AbstractCommsContext] context used for this operation.\n\nReturns\n\nField or FieldVector\n\n\n\n\n\n","category":"function"},{"location":"regridder/#ClimaCoupler.Regridder.dummmy_remap!","page":"Regridder","title":"ClimaCoupler.Regridder.dummmy_remap!","text":"dummmy_remap!(target, source)\n\nSimple stand-in function for remapping. For AMIP we don't need regridding of surface model fields. When we do, we re-introduce the ClimaCoreTempestRemap remapping functions.\n\nArguments\n\ntarget: [Fields.Field] destination of remapping.\nsource: [Fields.Field] source of remapping.\n\n\n\n\n\n","category":"function"},{"location":"regridder/#ClimaCoupler.Regridder.remap_field_cgll_to_rll","page":"Regridder","title":"ClimaCoupler.Regridder.remap_field_cgll_to_rll","text":"remap_field_cgll_to_rll(\n    name,\n    field::Fields.Field,\n    remap_tmpdir,\n    datafile_rll;\n    nlat = 90,\n    nlon = 180\n)\n\nRemap an individual FT-valued Field from model (CGLL) nodes to a lat-lon (RLL) grid using TempestRemap.\n\nArguments\n\nname: [Symbol] variable name.\nfield: [Fields.Field] data to be remapped.\nremap_tmpdir: [String] directory used for remapping.\ndatafile_rll: [String] filename of remapped data output.\n\n\n\n\n\n","category":"function"},{"location":"regridder/#ClimaCoupler.Regridder.land_fraction","page":"Regridder","title":"ClimaCoupler.Regridder.land_fraction","text":"function land_fraction(\n    FT,\n    REGRID_DIR,\n    comms_ctx::ClimaComms.AbstractCommsContext,\n    infile,\n    varname,\n    boundary_space;\n    outfile_root = \"land_sea_cgll\",\n    mono = false,\n    threshold = 0.7,\n)\n\nInitialize a fraction for land/sea classification of grid squares over the space. With mono = true, remappings are monotone and conservative, (slower). With mono = false, values outside of threshold are cutoff (faster).\n\nSee https://github.com/CliMA/ClimaCoupler.jl/wiki/ClimaCoupler-Lessons-Learned     for a detailed comparison of remapping approaches.\n\nArguments\n\nFT: [DataType] Float type\nREGRID_DIR: [String] directory to save output files in.\ncomms_ctx: [ClimaComms.AbstractCommsContext] context used for this operation.\ninfile: [String] filename containing input data.\nvarname: [Symbol] variable name.\nboundary_space: [Spaces.AbstractSpace] over which we are mapping data.\noutfile_root: [String] root for output file name.\nmono: [Bool] flag for monotone remapping.\nthreshold: [FT] cutoff value for binary_mask when non-monotone remapping.\n\nReturns\n\nFields.Field\n\n\n\n\n\n","category":"function"},{"location":"regridder/#ClimaCoupler.Regridder.update_surface_fractions!","page":"Regridder","title":"ClimaCoupler.Regridder.update_surface_fractions!","text":"update_surface_fractions!(cs::CoupledSimulation)\n\nUpdates dynamically changing area fractions. Maintains the invariant that the sum of area fractions is 1 at all points.\n\nArguments\n\ncs: [CoupledSimulation] containing area fraction information.\n\n\n\n\n\n","category":"function"},{"location":"regridder/#ClimaCoupler.Regridder.combine_surfaces!","page":"Regridder","title":"ClimaCoupler.Regridder.combine_surfaces!","text":"combine_surfaces!(combined_field::Fields.Field, sims, field_name::Val)\n\nSums the fields, specified by field_name, weighted by the respective area fractions of all surface simulations. THe result is saved in combined_field.\n\nArguments\n\ncombined_field: [Fields.Field] output object containing weighted values.\nsims: [NamedTuple] containing simulations .\nfield_name: [Val] containing the name Symbol of the field t be extracted by the get_field functions.\n\nExample\n\ncombine_surfaces!(zeros(boundary_space), cs.model_sims, Val(:surface_temperature))\n\n\n\n\n\n","category":"function"},{"location":"regridder/#Regridder-Internal-Functions","page":"Regridder","title":"Regridder Internal Functions","text":"","category":"section"},{"location":"regridder/","page":"Regridder","title":"Regridder","text":"ClimaCoupler.Regridder.reshape_cgll_sparse_to_field!\nClimaCoupler.Regridder.hdwrite_regridfile_rll_to_cgll\nClimaCoupler.Regridder.write_datafile_cc\nClimaCoupler.Regridder.binary_mask","category":"page"},{"location":"regridder/#ClimaCoupler.Regridder.reshape_cgll_sparse_to_field!","page":"Regridder","title":"ClimaCoupler.Regridder.reshape_cgll_sparse_to_field!","text":"reshape_cgll_sparse_to_field!(field::Fields.Field, in_array::Array, R)\n\nReshapes a sparse vector array in_array (CGLL, raw output of the TempestRemap), and uses its data to populate the input Field object field. Redundant nodes are populated using dss operations.\n\nArguments\n\nfield: [Fields.Field] object populated with the input array.\nin_array: [Array] input used to fill field.\nR: [NamedTuple] containing target_idxs and row_indices used for indexing.\n\n\n\n\n\n","category":"function"},{"location":"regridder/#ClimaCoupler.Regridder.hdwrite_regridfile_rll_to_cgll","page":"Regridder","title":"ClimaCoupler.Regridder.hdwrite_regridfile_rll_to_cgll","text":"hdwrite_regridfile_rll_to_cgll(\n    FT,\n    REGRID_DIR,\n    datafile_rll,\n    varname,\n    space;\n    hd_outfile_root = \"data_cgll\",\n    mono = false,\n)\n\nReads and regrids data of the varname variable from an input NetCDF file and saves it as another NetCDF file using Tempest Remap. The input NetCDF fileneeds to be Exodus formatted, and can contain time-dependent data. The output NetCDF file is then read back, the output arrays converted into Fields and saved as HDF5 files (one per time slice). This function should be called by the root process. The saved regridded HDF5 output is readable by multiple MPI processes.\n\nArguments\n\nFT: [DataType] Float type.\nREGRID_DIR: [String] directory to save output files in.\ndatafile_rll: [String] filename of RLL dataset to be mapped to CGLL.\nvarname: [String] the name of the variable to be remapped.\nspace: [Spaces.AbstractSpace] the space to which we are mapping.\nhd_outfile_root: [String] root of the output file name.\nmono: [Bool] flag to specify monotone remapping.\n\n\n\n\n\n","category":"function"},{"location":"regridder/#ClimaCoupler.Regridder.write_datafile_cc","page":"Regridder","title":"ClimaCoupler.Regridder.write_datafile_cc","text":"write_datafile_cc(datafile_cc, field, name)\n\nWrite the data stored in field to an NCDataset file datafile_cc.\n\nArguments\n\ndatafile_cc: [String] filename of output file.\nfield: [Fields.Field] to be written to file.\nname: [Symbol] variable name.\n\n\n\n\n\n","category":"function"},{"location":"regridder/#ClimaCoupler.Regridder.binary_mask","page":"Regridder","title":"ClimaCoupler.Regridder.binary_mask","text":"binary_mask(var::FT; threshold = 0.5)\n\nConverts a number var to 1, if var is greater or equal than a given threshold value, or 0 otherwise, keeping the same type.\n\nArguments\n\nvar: [FT] value to be converted.\nthreshold: [Float] cutoff value for conversions.\n\n\n\n\n\n","category":"function"},{"location":"generated/sea_breeze/ocean_rhs/#Ocean-Model","page":"Ocean Model","title":"Ocean Model","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"Load coupled simulation code","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"include(\"../CoupledSims/coupled_sim.jl\")","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Slab-Ocean-ODE","page":"Ocean Model","title":"Slab Ocean ODE","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"For our ocean component, we solve a simple slab ocean ODE just as we did for the land:","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"rho_o c_o H_o partial_t T_ocn = - F_integ  Delta t_coupler","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"where rho_o = 1025 kg m ^-3, c_o=3850 J K ^-1 kg ^-1, H_o = 100 m are the density, specific heat and depth of the ocean,\nand F_integ is the integrated surface fluxes in time.","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Model-Code","page":"Ocean Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"function ocn_rhs!(du, u, (parameters, F_accumulated), t)\n    \"\"\"\n    Slab layer equation\n        d(T_sfc)/dt = - (F_accumulated) / (h_ocn * ρ_ocn * c_ocn)\n        where\n            F_accumulated = F_integrated / Δt_coupler\n    \"\"\"\n    @unpack ocn_h, ocn_ρ, ocn_c = parameters\n    @unpack T_sfc = du\n\n    @. T_sfc = (-F_accumulated) / (ocn_h * ocn_ρ * ocn_c)\nend\n\n# set up domain\nfunction hspace_1D(xlim = (-π, π), npoly = 0, helem = 10)\n    FT = Float64\n\n    domain = Domains.IntervalDomain(Geometry.XPoint{FT}(xlim[1]) .. Geometry.XPoint{FT}(xlim[2]), periodic = true)\n    mesh = Meshes.IntervalMesh(domain; nelems = helem)\n    topology = Topologies.IntervalTopology(mesh)\n\n    # Finite Volume Approximation: Gauss-Lobatto with 1pt per element\n    quad = Spaces.Quadratures.GL{npoly + 1}()\n    space = Spaces.SpectralElementSpace1D(topology, quad)\n\n    return space\nend\n\n# init simulation\nfunction ocn_init(; xmin = -1000, xmax = 1000, helem = 20, npoly = 0)\n\n    # construct domain spaces - get only surface layer (NB: z should be zero, not z = first central height)\n    space = hspace_1D((xmin, xmax), npoly, helem)\n    coords = Fields.coordinate_field(space)\n    domain = space\n\n    # initial condition\n    T_sfc = map(coords) do coord\n        T_sfc = 267.0\n    end\n\n    # prognostic variable\n    Y = Fields.FieldVector(T_sfc = T_sfc)\n\n    return Y, domain\nend","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/#Coupled-Ocean-Wrappers","page":"Ocean Model","title":"Coupled Ocean Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"# Ocean Simulation - Later to live in Oceananigans\nstruct OceanSim <: AbstractOceanSim\n    integrator::Any\nend\n\nfunction OceanSim(Y_init, t_start, dt, t_end, timestepper, p, saveat, callbacks = CallbackSet())\n    ocn_prob = ODEProblem(ocn_rhs!, Y_init, (t_start, t_end), p)\n    ocn_integ = init(ocn_prob, timestepper, dt = dt, saveat = saveat, callback = callbacks)\n    return OceanSim(ocn_integ)\nend\n\nfunction coupler_push!(coupler::CouplerState, ocean::OceanSim)\n    coupler_put!(coupler, :T_sfc_ocean, ocean.integrator.u.T_sfc, ocean)\nend\n\nfunction coupler_pull!(ocean::OceanSim, coupler::CouplerState)\n    coupler_get!(ocean.integrator.p.F_sfc, coupler, :F_sfc, ocean)\n    ocean.integrator.p.F_sfc ./= coupler.Δt_coupled\nend","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"","category":"page"},{"location":"generated/sea_breeze/ocean_rhs/","page":"Ocean Model","title":"Ocean Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"conservation/#Conservation-Checks","page":"Conservation Checks","title":"Conservation Checks","text":"","category":"section"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"If the model is a physically closed system (e.g., in the slabplanet configuration with free slip conditions), it should conserve mass (including water), energy and momentum. The conservation checker logs global conservation.","category":"page"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"Only energy and water are currently implemented. ","category":"page"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"Note that kinetic energy is not included in the calculation of the global energy, reflecting the formulation on ClimaAtmos, which assumes that kinetic energy is negligible in comparison with the moist static energy components. ","category":"page"},{"location":"conservation/#Coupler-Object-API","page":"Conservation Checks","title":"Coupler Object API","text":"","category":"section"},{"location":"conservation/","page":"Conservation Checks","title":"Conservation Checks","text":"ClimaCoupler.ConservationChecker.EnergyConservationCheck\nClimaCoupler.ConservationChecker.WaterConservationCheck\nClimaCoupler.ConservationChecker.check_conservation!\nClimaCoupler.ConservationChecker.plot_global_conservation","category":"page"},{"location":"conservation/#ClimaCoupler.ConservationChecker.EnergyConservationCheck","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.EnergyConservationCheck","text":"EnergyConservationCheck{A} <: AbstractConservationCheck\n\nStruct of type AbstractConservationCheck containing global energy conservation logs.\n\n\n\n\n\n","category":"type"},{"location":"conservation/#ClimaCoupler.ConservationChecker.WaterConservationCheck","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.WaterConservationCheck","text":"WaterConservationCheck{A} <: AbstractConservationCheck\n\nStruct of type AbstractConservationCheck containing global water mass conservation logs.\n\n\n\n\n\n","category":"type"},{"location":"conservation/#ClimaCoupler.ConservationChecker.check_conservation!","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.check_conservation!","text":"check_conservation!(coupler_sim::Interfacer.CoupledSimulation; runtime_check = false)\n\nitertes over all specified conservation checks.\n\n\n\n\n\n    check_conservation!(\n    cc::EnergyConservationCheck,\n    coupler_sim::Interfacer.CoupledSimulation,\n    runtime_check = false,\n    )\n\ncomputes the total energy, ∫ ρe dV, of the model components of the coupled simulations and the TOA radiation, and updates cc with these values.\n\n\n\n\n\ncheck_conservation!(\ncc::WaterConservationCheck,\ncoupler_sim::Interfacer.CoupledSimulation,\nruntime_check = false,\n)\n\ncomputes the total water, ∫ ρq_tot dV, of the various components of the coupled simulations, and updates cc with the values.\n\nNote: in the future this should not use push!.\n\n\n\n\n\n","category":"function"},{"location":"conservation/#ClimaCoupler.ConservationChecker.plot_global_conservation","page":"Conservation Checks","title":"ClimaCoupler.ConservationChecker.plot_global_conservation","text":"plot_global_conservation(\n    cc::EnergyConservationCheck,\n    coupler_sim::Interfacer.CoupledSimulation;\n    figname1 = \"total_energy.png\",\n    figname2 = \"total_energy_log.png\",\n)\n\nCreates two plots of the globally integrated quantity (energy, rho e):\n\nglobal quantity of each model component as a function of time,\n\nrelative to the initial value;\n\nfractional change in the sum of all components over time on a log scale.\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#TimeManager","page":"TimeManager","title":"TimeManager","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"This module contains functions that handle dates and times in simulations. The functions in this module often call functions from Julia's Dates module.","category":"page"},{"location":"timemanager/#TimeManager-API","page":"TimeManager","title":"TimeManager API","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"ClimaCoupler.TimeManager.current_date\nClimaCoupler.TimeManager.strdate_to_datetime\nClimaCoupler.TimeManager.datetime_to_strdate\nClimaCoupler.TimeManager.trigger_callback\nClimaCoupler.TimeManager.Monthly\nClimaCoupler.TimeManager.EveryTimestep","category":"page"},{"location":"timemanager/#ClimaCoupler.TimeManager.current_date","page":"TimeManager","title":"ClimaCoupler.TimeManager.current_date","text":"current_date(cs::CoupledSimulation, t::Int)\n\nReturn the model date at the current timestep.\n\nArguments\n\ncs: [CoupledSimulation] containing info about the simulation\nt: [Real] number of seconds since simulation began\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ClimaCoupler.TimeManager.strdate_to_datetime","page":"TimeManager","title":"ClimaCoupler.TimeManager.strdate_to_datetime","text":"strdate_to_datetime(strdate::String)\n\nConvert from String (\"YYYYMMDD\") to Date format, required by the official AMIP input files.\n\nArguments\n\nstrdate: [String] to be converted to Date type\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ClimaCoupler.TimeManager.datetime_to_strdate","page":"TimeManager","title":"ClimaCoupler.TimeManager.datetime_to_strdate","text":"datetime_to_strdate(datetime::DateTime)\n\nConvert from Date to String (\"YYYYMMDD\") format.\n\nArguments\n\ndatetime: [DateTime] object to be converted to string\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ClimaCoupler.TimeManager.trigger_callback","page":"TimeManager","title":"ClimaCoupler.TimeManager.trigger_callback","text":"trigger_callback(cs, ::Monthly)\n\nReturns true if the current date is equal to or exceeds the saved first of the month at time of 00:00:00.\n\nArguments\n\ncs: [CoupledSimulation] containing info about the simulation\n\n\n\n\n\n","category":"function"},{"location":"generated/sea_breeze/atmos_rhs/#Atmospheric-Model","page":"Atmospheric Model","title":"Atmospheric Model","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/#Atmosphere-Conservation-Equations","page":"Atmospheric Model","title":"Atmosphere Conservation Equations","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Density:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rhopartial t + nabla cdot (rho vecu)= S(chi )","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Momentum (flux form):","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho vecupartial t + nabla cdot (rho vecu otimes vecu + pI)= nabla cdot (rho tau) - rho g + F_B()","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Potential temperature:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho thetapartial t + nabla cdot (rho theta vecu) = nabla cdot (kappa rho nabla theta)","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Total Energy (possibly replace potential temperature equation with total energy conservation):","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho e_totpartial t + nabla cdot ((rho e_tot + p )vecu) = nabla cdot (kappa rho nabla h_tot)","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"where h_tot is the total specific enthalpy given by internal and potential energy contributions.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Tracer transport:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"fracpartial rho chipartial t + nabla cdot (rho chi vecu) = nabla cdot (kappa rho nabla chi) + S(chi )","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Diffusion (Constant Viscosity): The simplest model to represent diffusive processes is a constant-viscosity model, with prescribed kinematic viscosity nu such that the stress tensor can be modelled by","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"rhotau = -2rhonunabla u","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Smagorinsky Closure: The Smagorinsky closure is an eddy-viscosity model that captures the effect of energy transfer to the smallest scales of motion in the flow.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\nrhotau = -2rhonuvecS \nvecS = frac12((nabla u) + (nabla u)^T) \nnu = (C_sDelta_xyz)^2sqrt2S_ijS_ij\nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"with Delta_xyz the grid lengthscale (sometimes approximated as a geometric average Delta = (Delta_xDelta_yDelta_z)^13), nu is a spatially varying kinematic viscosity that depends on the local shear, vecS the symmetric rate-of-strain tensor, tau the diffusive momentum flux tensor. In stratified flows, we can apply a correction to the eddy viscosity to account for buoyancy effects. Thermal diffusivities are related to the modelled eddy-viscosity through the turbulent Prandtl number which takes a typical value of Pr_t= 13 such that kappa_2 = nuPr_t.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Tendencies for fourth-order hyperdiffusion are included in the rhs! construction, but the coefficient kappa_4 is 0 in this demonstrative case. Hyperdiffusive tendencies are typically included as a scale-selective diffusion mechanism for high-frequency noise (e.g. stabilization in GCMs).","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Consider components of the viscous stress tensor in three dimensions:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\ntau_xx = 2nu fracpartial upartial x \n\ntau_yy = 2nu fracpartial vpartial y \n\ntau_zz = 2nu fracpartial wpartial z \n\ntau_xy = nu Big(fracpartial upartial y +  fracpartial vpartial xBig) \n\ntau_xz = nu Big(fracpartial upartial z +  fracpartial wpartial xBig) \n\ntau_yz = nu Big(fracpartial vpartial z +  fracpartial wpartial yBig)\nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Assume terms in the y-direction are neglected (2-dimensional simplicfication). The contributions to the momentum equation are then given by:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"beginaligned\n(rho u)  partial_x (rho tau_xx) + partial_z(rhotau_xz)  = partial_x  Big(2nu fracpartial upartial xBig) + partial_zBig(nu fracpartial upartial zBig) + partial_zBig(nu fracpartial wpartial xBig) \n(rho w) partial_x (rho tau_zx)+ partial_z(rhotau_zz)  = partial_xBig(nu fracpartial upartial zBig) +  partial_xBig(nu fracpartial wpartial xBig) + partial_zBig(2nufracpartial wpartial z Big) \nendaligned","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Which can be interpreted as, for horizontal-momentum:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Horizontal divergence of vertical gradients of cell-centered variables u\nVertical divergence of vertical gradients of cell-centered variables u\nVertical divergence of horizontal gradients of cell-face variables w","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"and for vertical-momentum, as:","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Horizontal divergence of vertical gradients of cell-centered variables u\nHorizontal divergence of horizontal gradients of cell-face variables w\nVertical divergence of vertical gradients of cell-face variables w.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Model-Code","page":"Atmospheric Model","title":"Model Code","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"push!(LOAD_PATH, joinpath(@__DIR__, \"..\", \"..\", \"..\"))\n\nusing Test\nusing StaticArrays, IntervalSets, LinearAlgebra, UnPack\n\nimport ClimaCore: ClimaCore, slab, Spaces, Domains, Meshes, Geometry, Topologies, Spaces, Fields, Operators\nusing ClimaCore.Geometry\nusing ClimaCore.Utilities: PlusHalf\n\nusing Logging: global_logger\nusing TerminalLoggers: TerminalLogger\nglobal_logger(TerminalLogger())\n\nusing ClimaCoupler","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"Load coupled simulation code","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"include(\"../CoupledSims/coupled_sim.jl\")\n\n# set up function space\nfunction hvspace_2D(xlim = (-π, π), zlim = (0, 4π), helem = 20, velem = 20, npoly = 1)\n    FT = Float64\n    vertdomain = Domains.IntervalDomain(\n        Geometry.ZPoint{FT}(zlim[1]),\n        Geometry.ZPoint{FT}(zlim[2]);\n        boundary_tags = (:bottom, :top),\n    )\n    vertmesh = Meshes.IntervalMesh(vertdomain, nelems = velem)\n    vert_center_space = Spaces.CenterFiniteDifferenceSpace(vertmesh)\n\n    horzdomain = Domains.IntervalDomain(Geometry.XPoint{FT}(xlim[1]) .. Geometry.XPoint{FT}(xlim[2]), periodic = true)\n    horzmesh = Meshes.IntervalMesh(horzdomain; nelems = helem)\n    horztopology = Topologies.IntervalTopology(horzmesh)\n\n    quad = Spaces.Quadratures.GLL{npoly + 1}()\n    horzspace = Spaces.SpectralElementSpace1D(horztopology, quad)\n\n    hv_center_space = Spaces.ExtrudedFiniteDifferenceSpace(horzspace, vert_center_space)\n    hv_face_space = Spaces.FaceExtrudedFiniteDifferenceSpace(hv_center_space)\n    return (hv_center_space, hv_face_space)\nend\n\nfunction pressure(ρθ)\n    if ρθ >= 0\n        return MSLP * (R_d * ρθ / MSLP)^γ\n    else\n        return NaN\n    end\nend\n\nΦ(z) = grav * z\n\nabstract type BCtag end\nstruct ZeroFlux <: BCtag end\n\nbc_divF2C_bottom!(::ZeroFlux, dY, Y, p, t) = Operators.SetValue(Geometry.WVector(0.0))\nbc_divF2C_top!(::ZeroFlux, dY, Y, p, t) = Operators.SetValue(Geometry.WVector(0.0))\n\nfunction init_sea_breeze_2d(x, z)\n    θ₀ = atm_T_ini\n    cp_d = C_p\n    cv_d = C_v\n    p₀ = MSLP\n    g = grav\n    γ = cp_d / cv_d\n    z_c = 100.0\n    θ_b = atm_T_ini\n    θ_p = z < z_c ? rand() - 0.5 : 0.0 # potential temperature perturbation\n    θ = θ_b + θ_p # potential temperature\n    π_exn = 1.0 - g * z / cp_d / θ # exner function\n    T = π_exn * θ # temperature\n    p = p₀ * π_exn^(cp_d / R_d) # pressure\n    ρ = p / R_d / T # density\n    ρθ = ρ * θ # potential temperature density\n    return (ρ = ρ, ρθ = ρθ, ρuₕ = ρ * Geometry.UVector(0.0))\nend\n\nfunction atm_rhs!(dY, Y, params, t)\n    ρw = Y.ρw\n    Yc = Y.Yc\n    dYc = dY.Yc\n    dρw = dY.ρw\n\n    center_coords = Fields.coordinate_field(axes(Yc))\n\n    # spectral horizontal operators\n    hdiv = Operators.Divergence()\n    hgrad = Operators.Gradient()\n    hwdiv = Operators.WeakDivergence()\n    hwgrad = Operators.WeakGradient()\n\n    # vertical FD operators with BC's\n    vdivf2c = Operators.DivergenceF2C(\n        bottom = Operators.SetValue(Geometry.WVector(0.0)),\n        top = Operators.SetValue(Geometry.WVector(0.0)),\n    )\n    vvdivc2f = Operators.DivergenceC2F(\n        bottom = Operators.SetDivergence(Geometry.WVector(0.0)),\n        top = Operators.SetDivergence(Geometry.WVector(0.0)),\n    )\n    uvdivf2c = Operators.DivergenceF2C(\n        bottom = Operators.SetValue(Geometry.WVector(0.0) ⊗ Geometry.UVector(0.0)),\n        top = Operators.SetValue(Geometry.WVector(0.0) ⊗ Geometry.UVector(0.0)),\n    )\n    If = Operators.InterpolateC2F(bottom = Operators.Extrapolate(), top = Operators.Extrapolate())\n    Ic = Operators.InterpolateF2C()\n    ∂ = Operators.DivergenceF2C(\n        bottom = Operators.SetValue(Geometry.WVector(0.0)),\n        top = Operators.SetValue(Geometry.WVector(0.0)),\n    )\n    ∂f = Operators.GradientC2F()\n    ∂c = Operators.GradientF2C()\n    B = Operators.SetBoundaryOperator(\n        bottom = Operators.SetValue(Geometry.WVector(0.0)),\n        top = Operators.SetValue(Geometry.WVector(0.0)),\n    )\n\n    ∇_z_ρθ = Operators.DivergenceF2C(\n        bottom = bc_divF2C_bottom!(params.bc.ρθ.bottom, dY, Y, params, t),\n        top = bc_divF2C_top!(params.bc.ρθ.top, dY, Y, params, t),\n    )\n\n    uₕ = @. Yc.ρuₕ / Yc.ρ\n    w = @. ρw / If(Yc.ρ)\n    wc = @. Ic(ρw) / Yc.ρ\n    p = @. pressure(Yc.ρθ)\n    θ = @. Yc.ρθ / Yc.ρ\n    Yfρ = @. If(Yc.ρ)\n\n    ### HYPERVISCOSITY\n    # 1) compute hyperviscosity coefficients\n    @. dYc.ρθ = hwdiv(hgrad(θ))\n    @. dYc.ρuₕ = hwdiv(hgrad(uₕ))\n    @. dρw = hwdiv(hgrad(w))\n    Spaces.weighted_dss!(dYc)\n    Spaces.weighted_dss!(dρw)\n\n    κ₄ = 0.0 # m^4/s\n    @. dYc.ρθ = -κ₄ * hwdiv(Yc.ρ * hgrad(dYc.ρθ))\n    @. dYc.ρuₕ = -κ₄ * hwdiv(Yc.ρ * hgrad(dYc.ρuₕ))\n    @. dρw = -κ₄ * hwdiv(Yfρ * hgrad(dρw))\n\n    # density\n    @. dYc.ρ = -∂(ρw)\n    @. dYc.ρ -= hdiv(Yc.ρuₕ)\n\n    # potential temperature\n    @. dYc.ρθ += -(∇_z_ρθ(ρw * If(Yc.ρθ / Yc.ρ)))\n    @. dYc.ρθ -= hdiv(uₕ * Yc.ρθ)\n\n    # horizontal momentum\n    Ih = Ref(Geometry.Axis2Tensor((Geometry.UAxis(), Geometry.UAxis()), @SMatrix [1.0]))\n    @. dYc.ρuₕ += -uvdivf2c(ρw ⊗ If(uₕ))\n    @. dYc.ρuₕ -= hdiv(Yc.ρuₕ ⊗ uₕ + p * Ih)\n\n    # vertical momentum\n    @. dρw +=\n        B(Geometry.transform(Geometry.WAxis(), -(∂f(p)) - If(Yc.ρ) * ∂f(Φ(center_coords.z))) - vvdivc2f(Ic(ρw ⊗ w)))\n    uₕf = @. If(Yc.ρuₕ / Yc.ρ) # requires boundary conditions\n    @. dρw -= hdiv(uₕf ⊗ ρw)\n\n    # DIFFUSION\n    κ₂ = 5.0 # m^2/s\n    #  1a) horizontal div of horizontal grad of horiz momentun\n    @. dYc.ρuₕ += hwdiv(κ₂ * (Yc.ρ * hgrad(Yc.ρuₕ / Yc.ρ)))\n    #  1b) vertical div of vertical grad of horiz momentun\n    @. dYc.ρuₕ += uvdivf2c(κ₂ * (Yfρ * ∂f(Yc.ρuₕ / Yc.ρ)))\n\n    #  1c) horizontal div of horizontal grad of vert momentum\n    @. dρw += hwdiv(κ₂ * (Yfρ * hgrad(ρw / Yfρ)))\n    #  1d) vertical div of vertical grad of vert momentun\n    @. dρw += vvdivc2f(κ₂ * (Yc.ρ * ∂c(ρw / Yfρ)))\n\n    #  2a) horizontal div of horizontal grad of potential temperature\n    @. dYc.ρθ += hwdiv(κ₂ * (Yc.ρ * hgrad(Yc.ρθ / Yc.ρ)))\n    #  2b) vertical div of vertial grad of potential temperature\n    @. dYc.ρθ += ∇_z_ρθ(κ₂ * (Yfρ * ∂f(Yc.ρθ / Yc.ρ)))\n\n    Spaces.weighted_dss!(dYc)\n    Spaces.weighted_dss!(dρw)\n    return dY\nend\n\n# init simulation\nfunction atm_init(; xmin = -500, xmax = 500, zmin = 0, zmax = 1000, npoly = 3, helem = 20, velem = 20, bc = nothing)\n\n    # construct domain spaces\n    hv_center_space, hv_face_space = hvspace_2D((xmin, xmax), (zmin, zmax), helem, velem, npoly) # [m]\n    center_coords = Fields.coordinate_field(hv_center_space)\n    face_coords = Fields.coordinate_field(hv_face_space)\n    domain = (hv_center_space = hv_center_space, hv_face_space = hv_face_space)\n\n    # initialize prognostic variables\n    Yc = map(center_coords) do coord\n        sea_breeze = init_sea_breeze_2d(coord.x, coord.z)\n        sea_breeze\n    end\n\n    ρw = map(face_coords) do coord\n        Geometry.WVector(0.0)\n    end\n\n    Y = Fields.FieldVector(Yc = Yc, ρw = ρw)\n\n    # select boundary conditions\n    if bc === nothing\n        bc = (\n            ρθ = (bottom = CoupledFlux(), top = ZeroFlux()),\n            ρu = nothing, # for now BCs are hard coded, except for ρθ\n        )\n    end\n\n    return Y, bc, domain\nend\n\nusing OrdinaryDiffEq\nfunction atm_run!(Y, bc, domain)\n    dYdt = similar(Y)\n    params = (aux_params = 0.0, T_sfc = 1.0, bc = bc, domain = domain)\n    atm_rhs!(dYdt, Y, params, 0.0)\n    prob = ODEProblem(atm_rhs!, Y, (0.0, 250.0), params)\n    Δt = 0.025\n    sol = solve(prob, SSPRK33(), dt = Δt, saveat = 1.0, progress = true, progress_message = (dt, u, params, t) -> t)\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Coupled-Atmos-Wrappers","page":"Atmospheric Model","title":"Coupled Atmos Wrappers","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"# Atmos Simulation - later to live in ClimaAtmos\nstruct AtmosSim <: AbstractAtmosSim\n    integrator::Any\nend\n\nfunction AtmosSim(Y_init, t_start, dt, t_end, timestepper, p, saveat, callbacks = CallbackSet())\n    atm_prob = ODEProblem(atm_rhs!, Y_init, (t_start, t_end), p)\n\n    atm_integ = init(\n        atm_prob,\n        timestepper,\n        dt = dt,\n        saveat = saveat,\n        progress = true,\n        progress_message = (dt, u, params, t) -> t,\n        callback = callbacks,\n    )\n\n    return AtmosSim(atm_integ)\nend\n\nfunction coupler_push!(coupler::CouplerState, atmos::AtmosSim)\n    coupler_put!(coupler, :F_sfc, atmos.integrator.u.F_sfc, atmos)\nend\n\nfunction coupler_pull!(atmos::AtmosSim, coupler::CouplerState)\n    # reset flux accumulator\n    atmos.integrator.u.F_sfc .= 0.0 # reset surface flux to be accumulated\n\n    T_sfc_ocean = coupler_get(coupler, :T_sfc_ocean, atmos)\n    T_sfc_land = coupler_get(coupler, :T_sfc_land, atmos)\n    atmos.integrator.p.T_sfc .= T_sfc_land .+ T_sfc_ocean\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/#Coupled-Boundary-Conditions","page":"Atmospheric Model","title":"Coupled Boundary Conditions","text":"","category":"section"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"The standalone atmosphere model uses two boundary condition methods in its tendency: bc_divF2C_bottom! and bc_divF2C_top!. Since the bottom boundary is coupled, bc_divF2C_bottom! must be altered when running in coupled mode to properly calculate and accumulate the boundary flux from the ocean and land components.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"To solve this, a CoupledFlux boundary tag is set for the bottom boundary during initialization. Then, a new method of bc_divF2C_bottom! is written to dispatch on the CoupledFlux boundary tag. This method can then compute the flux appropriately.","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"struct CoupledFlux <: BCtag end\nfunction bc_divF2C_bottom!(::CoupledFlux, dY, Y, p, t)\n    # flux calculation\n    Yc = Y.Yc\n    uₕ = Yc.ρuₕ ./ Yc.ρ\n    ρw = Y.ρw\n    If2c = Operators.InterpolateF2C()\n    Ic2f = Operators.InterpolateC2F(bottom = Operators.Extrapolate(), top = Operators.Extrapolate())\n    w = If2c.(ρw) ./ Yc.ρ\n    cuv = @. Geometry.UWVector(uₕ)\n    windspeed = @. norm(cuv)\n    windspeed_boundary = Fields.level(windspeed, 1)\n    θ_boundary = Fields.level(Yc.ρθ ./ Yc.ρ, 1)\n    ρ_boundary = Fields.level(Yc.ρ, 1)\n\n    # build atmos face fields on surface boundary space to enable broadcasting\n    windspeed_boundary = Fields.Field(Fields.field_values(windspeed_boundary), axes(p.T_sfc))\n    θ_boundary = Fields.Field(Fields.field_values(θ_boundary), axes(p.T_sfc))\n    ρ_boundary = Fields.Field(Fields.field_values(ρ_boundary), axes(p.T_sfc))\n\n    λ = @. p.cpl_p.C_p * p.cpl_p.C_H * ρ_boundary * windspeed_boundary\n    dθ = @. θ_boundary - p.T_sfc\n    heat_flux = @. -λ * dθ\n    @. dY.F_sfc += heat_flux # accumulation\n\n    return Operators.SetValue(Geometry.WVector.(heat_flux))\nend","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"","category":"page"},{"location":"generated/sea_breeze/atmos_rhs/","page":"Atmospheric Model","title":"Atmospheric Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ClimaCoupler.jl","page":"Home","title":"ClimaCoupler.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Coupling CliMA Models","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ClimaCoupler","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaCoupler.jl provides a means to couple CliMA  model components. It is designed to provide a flexible way to map boundary fluxes of quantities, like moisture and heat, that leave one component model (for example the atmosphere) to boundary fluxes of another component model (for example the ocean model). Functionality includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"coupled system time stepping control that integrates fluxes in time for sharing between components with differing time steps and/or time stepping schemes.\nsupport for mapping import and export boundary information between components so that fluxes of properties transferred between components are conserved.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ClimaCoupler supports coupling components that are all within the same process or coupling components (using MPI) that are running on different processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Coupler Scheme)\nClimaCoupler.jl allows for independent development of interchangeable component models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaCoupler","category":"page"},{"location":"#ClimaCoupler.ClimaCoupler","page":"Home","title":"ClimaCoupler.ClimaCoupler","text":"ClimaCoupler\n\nModule for atmos-ocean-land coupled simulations.\n\n\n\n\n\n","category":"module"}]
}
